Non-co-safe objective: $\Globally \Finally \varphi$.

Practical application (link yt-video?), with real world problems (e.g. time discretization, linearization, numerical errors).

\startsubsection[title={Derivation}]

    Equation of motion: Angular momentum changes when torque is applied

    \startformula
        \dot\AngularMomentum = \sum_{i} \Torque_i = \sum_{i} \Length_i \Force_i
    \stopformula

    First torque from gravitational acceleration $ \Force_g = \Mass \Gravity \sin(\Angle) $.
    Second torque from friction, here friction force assumed to be proportional to the velocity of the swinging mass which is $\Length \dot\Angle$: $\Force_f = \Friction \Length \dot\Angle$.
    Third torque is control torque, applied as a force $\Force_c = \MaxForce \Thrust$ at the end of the pendulum.
    Using $\AngularMomentum = \MomentOfInertia \dot\Angle$ where $\MomentOfInertia = \Length^2 \Mass$ is the moment of inertia, and $\Torque = \Length \Force$:

    \startformula
        \startalign[n=3,align={middle,right,left}]
            \NC
            \NC \dot\AngularMomentum =
            \NC \sum_{i} \Length_i \Force_i
            \NR
            \NC \Leftrightarrow \quad
            \NC \Length^2 \Mass \ddot\Angle =
            \NC \Length (\Force_g + \Force_f + \Force_c)
            \NR
            \NC \Leftrightarrow \quad
            \NC \Length \Mass \ddot\Angle =
            \NC \Mass \Gravity \sin(\Angle) + \Friction \Length \dot\Angle + \MaxForce \Thrust
            \NR
            \NC \Leftrightarrow \quad
            \NC \ddot\Angle =
            \NC \frac{\Gravity}{\Length} \sin(\Angle) + \frac{\Friction}{\Mass} \dot\Angle + \frac{\MaxForce}{\Length \Mass} \Thrust
            \NR
        \stopalign
    \stopformula

    Linearization with small angle approximation $\sin(\Angle) \approx \Angle$.
    Discuss error size.

    \startformula
        \ddot\Angle = \frac{\Gravity}{\Length} \Angle + \frac{\Friction}{\Mass} \dot\Angle + \frac{1}{\Length \Mass} \Force_c
    \stopformula

    Rewrite as first-order system

    \startformula
        \DDt \TwoByOne{\Angle}{\dot\Angle}
        = \TwoByTwo{0}{1}{\frac{\Gravity}{\Length}}{\frac{\Friction}{\Mass}} \TwoByOne{\Angle}{\dot\Angle}
        + \TwoByOne{0}{\frac{\MaxForce}{\Length \Mass} } u
    \stopformula

    Introduce $\VecState_t = \TwoByOne{\Angle(t)}{\dot\Angle(t)}$ and $\VecControl_t = \OneByOne{u(t)}$ and discretize with an Euler-forward step:

    \startformula
        \startalign[n=3,align={middle,right,left}]
            \NC 
            \NC \DDt \TwoByOne{\Angle(t)}{\dot\Angle(t)} = 
            \NC \frac{\VecState_{t+1} - \VecState_{t}}{\Deltat} + O(...)
            \NR
            \NC \Rightarrow \quad
            \NC \VecState_{t+1} =
            \NC \VecState_{t}
                + \DDt \TwoByOne{\Angle(t)}{\dot\Angle(t)} \Deltat
                + O(...)
            \NR
            \NC \Rightarrow \quad
            \NC \VecState_{t+1} =
            \NC \VecState_{t}
                + \Deltat \TwoByTwo{0}{1}{\frac{\Gravity}{\Length}}{\frac{\Friction}{\Mass}} \VecState_t
                + \Deltat \TwoByOne{0}{\frac{\MaxForce}{\Length \Mass} } \VecControl_t
                + O(...)
            \NR
            \NC \Rightarrow \quad
            \NC \VecState_{t+1} =
            \NC \TwoByTwo{1}{1}{\frac{\Gravity}{\Length} \Deltat}{1 + \frac{\Friction}{\Mass} \Deltat} \VecState_t
                + \TwoByOne{0}{\frac{\MaxForce}{\Length \Mass} \Deltat } \VecControl_t
                + \VecRandom_t
            \NR
        \stopalign
    \stopformula

    Where the discretization error has been approximated by $\VecRandom_t \in \ClosedInterval{?}{?} \times \ClosedInterval{?}{?}$.

\stopsubsection


\startsubsection[title={Solution}]

    Implementation in interactive application.
    Symplectic integrator.
    Demonstraction that approach works.
    Controller synthesis and plots of a few angle/input vs. time graphs.

\stopsubsection

