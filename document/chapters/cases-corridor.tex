Consider the linear stochastic system

\startformula
    \VecX_{t+1} = \TwoByTwo{1}{0}{0}{1} \VecState_{t} + \TwoByTwo{1}{0}{0}{1} \VecControl_{t} + \VecRandom_{t} \EndComma
\stopformula

where $\VecState_{t} \in \StateSpace = \ClosedInterval{0}{4} \times \ClosedInterval{0}{3}$, $\VecControl_{t} \in \ControlSpace = \ClosedInterval{-0.5}{0.5}^2$ and $\VecRandom_{t} \in \RandomSpace = \ClosedInterval{-0.1}{0.1}^2$.

Linear predicates $\Predicate_1$, $\Predicate_2$, $\Predicate_3$ and $\Predicate_4$ corresponding to halfspaces $x < 1.3$, $x > 2.7$, $y < 1.3$ and $y > 2.7$, respectively.
With these predicates, the state space is divided into two rooms on the left and right, connected by a narrow corridor in the center of the state space.
The propositional formulas $\phi = \Predicate_1$ and $\mu = \Predicate_2$ define the rooms, while $\theta = \neg \Predicate_1 \wedge \neg \Predicate_2 \wedge (\Predicate_3 \vee \Predicate_4)$ defines the walls of the corridor.

\startsubsection[title={Reachability Analysis},reference=sec:cases-corridor-reachability]

    \placetable[top][tab:cases-corridor-reachability]{
        TODO
        See \in{section}[sec:cases-corridor-reachability] for discussion.
    }{
        \RefinementTable{
            \RefinementTableRow[iteration={},polys=65,onestates=140,oneactions=6856,twostates=6778,twoactions=85804,
                                total={1:35},refinement={0:02},gamegraph={1:29},analysis={0:04},
                                yes=69.7,no=30.3,maybe=0.0,figure=cases-corridor-reachability]
        }
    }

    First look at avoidance and reachability specification for this system.
    The objective is to reach the room on the right while avoiding the walls around the corridor, expressed in LTL as

    \startformula
        ( \neg \theta ) \,\Until\, \phi \EndPeriod
    \stopformula

    Choose the co-safe interpretation.
    Automaton from \in{Table}[tab:TODO].

    Challenge of this system is the narrow corridor.
    Precise control is needed to enter and stay in the corridor.
    Therefore, small polytopes have to be generated by the refinement which restricts the post-processing options.

    Based on the good performance in the double integrator example, choose layer decomposition and 4-step robust refinement again but do not supress the creation of small polytopes.
    Refined state space partition and analysis results are shown in \in{Table}[tab:cases-corridor-reachability].
    As expected, the partition of the entrace region of the corridor is finer than in the rest of the left room.
    The product game size and run time is comparable to that of the integrator solution using the layered $\PreR$ without shrinking the control space (\in{Table}[tab:cases-integrator-layers-prer100]) despite a partition that has only about a third of the number of polytopes.
    Can be explained by the additional dimension in the control space which results in many more actions for the player states which in turn increases the cost of the game construction.

\stopsubsection


\startsubsection[title={Reachability Controller}]

    \placefigure[top][fig:cases-corridor-reachability-trace]{
        TODO
    }{
        \startcombination[nx=2,ny=1,distance=10mm]
            {\externalfigure[cases-corridor-reachability-trace-robin][width=0.49\textwidth]}{}
            {\externalfigure[cases-corridor-reachability-trace-layers][width=0.49\textwidth]}{}
        \stopcombination
    }

    Bad performance of round-robin controller which does not violate avoidance objective but does not want to enter the corridor.
    Problem is that controller has no sense of direction.
    It manages to keep the trace safe but in order to navigate the corridor, the trace evolution has to be controlled to the right for multiple steps.
    But there is no coordination of actions in the round-robin controller so it is very unlikely that the right combination of actions is chosen in sequence.
    It will happen eventually, but waiting time could be very long.

    A more efficient controller could be synthesized from deeper analysis of the game.
    Alternatively, the layer-approach can be used to define a distance metric for transitions of the automaton.
    This is possible here because a robust solution to the problem exists.
    The desired transition is obviously $q_0 \rightarrow q_1$, so layers are generated analogously to the layered refinement decomposition for the transition target region $\phi$ from the robust predecessor.
    Robust reachability guarantees that a trace can move from layer to layer inward until it reaches the transition region where the co-safe reachability specification will be satisfied.
    A action for each state is selected by calculating a cost of the action's $\Post$ region using a volume-weighted distance metric derived from the layers.
    The further outward a layer, the higher its associated cost and unsafe regions are assigned infinite cost so they are avoided.
    Cost-minimization over all actions of a state then yields a control input that should lead a trace passing the state toward the target region.

    A trace initialized from the same starting point of the round-robin example has been controlled with a strategy derived from this layer-scheme and is shown in \in{Figure}[fig:cases-corridor-reachability-trace-layers], right.
    The controller steers the trace directly towards the corridor and has no problem navigating through the corridor.

\stopsubsection


\startreusableMPgraphic{cases-corridor-recurrence-automaton}
    beginfig(0);
        with spacing((17,15)) matrix.a(9,9);
        node_double.a[1][1](btex $q_0$ etex);
        node_dash.a[1][8](btex $q_1$ etex);
        node_dash.a[8][1](btex $q_2$ etex);
        % Outgoing transitions of q0
        incoming(0, "") (a[1][1]) 180;
        loop.top(.4, btex \small \;$ \neg \theta \wedge \phi \wedge \mu$ etex) (a[1][1]) 90;
        arrow.top(.5, btex \small $ \neg \theta \wedge \phi $ etex) (a[1][1],a[1][8]) a[1][1].c..a[0][4].c..a[0][5].c..a[1][8].c;
        arrow.rt(.5, btex \small $ \neg (\theta \vee \phi)$ etex) (a[1][1],a[8][1]) a[1][1].c..a[4][2].c..a[5][2].c..a[8][1].c;
        % Outgoing transitions of q1
        loop.top(.4, btex \small \;$ \neg (\theta \vee \phi) $ etex) (a[1][8]) 90;
        arrow.bot(.5, btex \small $ \neg \theta \wedge \phi \wedge \mu $ etex) (a[1][8],a[1][1]) a[1][8].c..a[2][5].c..a[2][4].c..a[1][1].c;
        arrow.rt(.4, btex \small \qquad$ \neg (\theta \vee \mu) \wedge \phi $ etex) (a[1][8],a[8][1]) a[1][8].c..a[2][8].c..a[8][2].c..a[8][1].c;
        % Outgoing transitions of q2
        loop.bot(.5, btex \small \;$ \neg (\theta \vee \mu) $ etex) (a[8][1]) 270;
        arrow.lft(.5, btex \small $ \neg \theta \wedge \mu $ etex) (a[8][1],a[1][1]) a[8][1].c..a[5][0].c..a[4][0].c..a[1][1].c;
    endfig;
\stopreusableMPgraphic

\startreusableMPgraphic{cases-corridor-recurrence-automaton-pruned}
    beginfig(0);
        with spacing((17,15)) matrix.a(9,9);
        node_double.a[1][1](btex $q_0$ etex);
        node_dash.a[1][8](btex $q_1$ etex);
        node_dash.a[8][1](btex $q_2$ etex);
        % Outgoing transitions of q0
        incoming(0, "") (a[1][1]) 180;
        arrow.top(.5, btex \small $ \neg \theta \wedge \phi $ etex) (a[1][1],a[1][8]) a[1][1].c..a[0][4].c..a[0][5].c..a[1][8].c;
        arrow.rt(.5, btex \small $ \neg (\theta \vee \phi)$ etex) (a[1][1],a[8][1]) a[1][1].c..a[4][2].c..a[5][2].c..a[8][1].c;
        % Outgoing transitions of q1
        loop.top(.4, btex \small \;$ \neg (\theta \vee \phi) $ etex) (a[1][8]) 90;
        arrow.rt(.4, btex \small \qquad$ \neg (\theta \vee \mu) \wedge \phi $ etex) (a[1][8],a[8][1]) a[1][8].c..a[2][8].c..a[8][2].c..a[8][1].c;
        % Outgoing transitions of q2
        loop.bot(.5, btex \small \;$ \neg (\theta \vee \mu) $ etex) (a[8][1]) 270;
        arrow.lft(.5, btex \small $ \neg \theta \wedge \mu $ etex) (a[8][1],a[1][1]) a[8][1].c..a[5][0].c..a[4][0].c..a[1][1].c;
    endfig;
\stopreusableMPgraphic

\startsubsection[title={2-Recurrence and Safety},reference=sec:cases-corridor-recurrence]

    \placefigure[top][fig:cases-corridor-recurrence-automaton]{
        TODO
    }{
        \startcombination[nx=2,ny=1,distance=10mm]
            {\reuseMPgraphic{cases-corridor-recurrence-automaton}}{}
            {\reuseMPgraphic{cases-corridor-recurrence-automaton-pruned}}{}
        \stopcombination
    }

    Finally consider a sighly more complex objective that requires traces to visit both rooms over and over again while avoiding the walls of the corridor

    \startformula
        \Globally (\neg \theta \wedge \Finally \phi \wedge \Finally \mu )
    \stopformula

    i.e.\ both rooms have to be visited infinitely often while avoiding the walls given by region $\theta$ and the boundaries of the state space.
    This is an inifinite objective.
    Corresponding automaton shown in \in{Figure}[fig:cases-corridor-recurrence-automaton], left.
    The state $q_0$ has to be visited infinitely often in an accepting run.
    State $q_1$ is a waiting state for a visit of room $\phi$ and $q_2$ a waiting state for room $\mu$.
    Because the rooms $\phi$ and $\mu$ do not overlap, two transitions can be removed from the automaton because their conditions can never be satisfied.
    The pruned automaton is shown on the right of \in{Figure}[fig:cases-corridor-recurrence-automaton].

    Negative attractors are empty, use positive robust refinement.
    Transitions for reachability decomposition have to be selected.
    Because $q_0$ has to be visited infinitely often it makes sense to refine with respect to transitions that return the system into $q_0$.
    Therefore, the transitions $q_1 \rightarrow q_2$ and $q_2 \rightarrow q_0$ are chosen.
    The possible satisfying runs that are enabled by such refinement are then of the form $(q_0 q_1 q_2)^\omega$ and $(q_0 q_2)^\omega$ as well as all stutter equivalent runs to these.

    \placetable[top][tab:cases-corridor-recurrence]{
        TODO
        See \in{section}[sec:cases-corridor-recurrence] for discussion.
    }{
        \RefinementTable{
            \RefinementTableRow[iteration={},polys=122,onestates=339,oneactions=46768,twostates=25139,twoactions=610511,
                                total={3:11},refinement={0:02},gamegraph={2:09},analysis={1:00},
                                yes=69.7,no=30.3,maybe=0.0,figure=cases-corridor-recurrence]
        }
    }

    Apply layered refinement for both transitions at once, then analyse.
    Results in \in{Table}[tab:cases-corridor-recurrence].
    Compared to reachability, number of states has approximately doubled while game graph construction time has increased by 45\%.
    The size of the product game has increased significantly, particularly when comparing the number of player actions with the reachability problem.
    The time required for the game solutions is 15 times that of the reachability problem.
    Growth of analysis demands because game graph has to be constructed only once but product game size grows with every additional automaton state.
    Therefore expected that the importance of the performance of the solution procedure grows with growing complexity of specification.
    
    Use layered approach again for controller synthesis.
    The controller is configured such actions in $q_1$ are selected such that the $\PreR$-based distance to the $q_2$ transition region is minimized, i.e.\ when the trace is in state $q_1$, the controller aims to visit room $\phi$.
    For states in $q_2$, the $q_0$ transition region is targeted, i.e.\ the controller tries to visit room $\mu$.
    In state $q_0$, the trace is just kept safe, as the next transitions immediately leads to $q_1$ or $q_2$.

    60 steps with this controller shown in \in{Figure}[fig:cases-corridor-recurrence-trace].
    The trace does not enter the unsafe regions, and visits each room TODO times, navigating back and forth through the corridor.

    \placefigure[top][fig:cases-corridor-recurrence-trace]{
        TODO
    }{
        \externalfigure[cases-corridor-recurrence-trace][width=0.8\textwidth]
    }

\stopsubsection

