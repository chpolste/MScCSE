<!doctype html>

<html>
  <head>
    <meta charset="utf-8">
    <title>Linear Stochastic System Analysis and Abstraction Refinement</title>
    <link rel="stylesheet" type="text/css" href="css/inspector.css">
    <link rel="stylesheet" type="text/css" href="css/widgets.css">
    <!-- INJECT KATEX -->
  </head>

  <body>
    
    <div class="header" id="top">
      <h1>Linear Stochastic System Analysis and Abstraction Refinement</h1>
    </div>

    <h2>Introduction</h2>
    <div>
      <p>
        Welcome! Additional text will arrive soon.
      </p>
    </div>

    <div class="navigation">
      → <a href="#inspector">Algorithm Inspector</a><br>
      → <a href="#theory">Theoretical Foundations</a><br>
      → <a href="#solution">Problem Setup and Solution</a><br>
      → <a href="#about">About</a><br>
      → <a href="#references">References</a>
    </div>

    <div class="wide">
      <div class="wide-inner" id="inspector">
        <p>Please wait while the application is loading...</p>
      </div>
    </div>

    <h2 id="theory">Theoretical Foundations</h2>
    <div>
      <h3>Linear Stochastic Systems</h3>
      <p>
        ...
      </p>

      <h3>Abstraction Refinement</h3>
      <p>
        ...
      </p>

      <h3>Deterministic ω-Automata</h3>
      <p>
        ...
      </p>

      <h3>Linear Temporal Logic and GR(1)</h3>
      <p>
        ...
      </p>

      <h3>Probabilistic Games</h3>
      <p>
        ...
      </p>

      <h3>Parity-3 Objectives</h3>
      <p>
        ...
      </p>
    </div>

    <h2 id="solution">Problem Setup and Solution</h2>
    <div>
      <p>
        The following problem formulation and algorithm were originally developed by <a href ="#Svorenova2017">Svorenova et al. (2017)</a>.
        The presentation here follows their approach closely.
      </p>

      <h3>Problem</h3>
      <p>
        Given a linear stochastic system with a discrete time evolution specified by the evolution equation <span class="math">x_{t+1} = A x_t + B u_t + w_t</span>, find a the set of initial states <span class="math">X_{init} \subseteq X \subset \mathbb{R}^n</span> for which a control strategy exists such that the probability of a trace starting in <span class="math">x</span> and satisfying an objective given as a GR(1) formula <span class="math">\phi</span> over a set of linear predicates is 1.
        A trace is an infinite sequence of states <span class="math">x_t \in X, \; t = 0, 1, 2, ...</span> obtained from application of the evolution equation.
        Control is exerted in the system by choosing a control input <span class="math">u_t \in U \subset \mathbb{R}^m</span> at every time step, while stochasticity is introduced by the term <span class="math">w_t</span> which is selected from a probability distribution over <span class="math">W \subset \mathbb{R}^n</span> at every time step.
        The search for satisfying initial states is complemented by the task of synthesizing the corresponding strategies that ensure the objective with probability 1.
      </p>

      
      <h3>Approach</h3>
      <ol>
        <li>Translate the objective from a temporal logic formula to a one-pair Streett automaton.</li>
        <li>Create the initial abstraction of the LSS based on the set of linear predicates used in the objective formula.</li>
        <li>Obtain a 2½-player game from the synchronized product of the LSS abstraction-induced game and the objective automaton.</li>
        <li>Analysis of the game identifies which states of the current abstraction are satisfying and non-satisfying and for which states satisfiability cannot be decided in the current abstraction.</li>
        <li>If no undecided states remain, a solution is found. Otherwise refine the undecided states heuristically using information about the dynamics of the LSS, and go back to step 3.</li>
      </ol>

      <h3>Polytopic Operators</h3>
      <p>
        Some polytopic operators expressing meaningful aspects of the system dynamics are introduced to aid the description of the components required to implement the algorithm.
        The posterior operator
      </p>
      <p class="math">
        \mathrm{Post}(X', U') = \{ x \in X \cup X_{out} \mid \exists x' \in X',~\exists u \in U',~\exists w \in W : x = Ax' + Bu + w \}
      </p>
      <p>
        yields the one step-reachable set originating from a polytope <span class="math">X'</span> of the state space partition when applying the control input <span class="math">U' \subset U</span>.
        The predecessor operator 
      </p>
      <p class="math">
          \mathrm{Pre}(X', U', \{X_j\}_{j \in J}) = \{ x \in X' \mid \exists u \in U' : \mathrm{Post}(x, u) \cap \textstyle\bigcup_{j \in J} X_j \ne \emptyset \}
      </p>
      <p>
        yields a subset of <span class="math">X'</span> from which the union of <span class="math">X_j</span> is reachable with <em>at least one</em> control input from the given set of control inputs <span class="math">U' \subset U</span>.
        A robust and a precise variant of the predecessor operator are defined by
      </p>
      <p class="math">
        \begin{aligned}
          \mathrm{PreR}(X', U', \{X_j\}_{j \in J}) &amp; = \{ x \in X' \mid \exists u \in U' : \mathrm{Post}(x, u) \subseteq \textstyle\bigcup_{j \in J} X_j \} \\
          \mathrm{PreP}(X', U', \{X_j\}_{j \in J}) &amp; = \{ x \in X' \mid \exists u \in U' : \mathrm{Post}(x, u) \subseteq \textstyle\bigcup_{j \in J} X_j \;\mathrm{and}\; \forall j \in J : \mathrm{Post}(x, u) \cap X_j \ne \emptyset \} \;\mathrm{.}
        \end{aligned}
      </p>
      <p>
        The robust predecessor adds the restriction that the union of <span class="math">X_j</span> must contain the <em>entire</em> one step-reachable set from <span class="math">X'</span>.
        The precise Predecessor further requires that a non-empty subset of <em>every</em> set in the collection <span class="math">\{X_j\}_{j \in J}</span> is reachable.
        The attractor and robust attractor operators mirror their predecessor counterparts but require that the conditions are met for <em>every</em> control input in the set <span class="math">U'</span>
      </p>
      <p class="math">
        \begin{aligned}
          \mathrm{Attr}(X', U', \{X_j\}_{j \in J}) &amp; = \{ x \in X' \mid \forall u \in U' : \mathrm{Post}(x, u) \cap \textstyle\bigcup_{j \in J} X_j \ne \emptyset \} \\
          \mathrm{AttrR}(X', U', \{X_j\}_{j \in J}) &amp; = \{ x \in X' \mid \forall u \in U' : \mathrm{Post}(x, u) \subseteq \textstyle\bigcup_{j \in J} X_j \} \;\mathrm{.}
        \end{aligned}
      </p>
      
      <h3>Initial LSS Partition</h3>
      <p>
        The state space <span class="math">X</span> is initially partitioned by splitting it with the linear predicates used in the temporal logic formula of the objective specification.
        For <span class="math">n</span> linear predicates, there can be at most disjunct <span class="math">2^n</span> parts <span class="math">X_i</span> of the state space, each a convex polytope since the intersection of halfspaces with a convex polytope is either empty or a convex polytope.
        The partition creates equivalence classes of states for which the exact same (sub-)set of linear predicates holds.
        The collection of state space subsets from the partition is denoted by <span class="math">\{ X_i \}</span> and complemented by a set of outer states <span class="math">\{ X_{i_{out}} \}</span>, which are obtained by partitioning <span class="math">\mathrm{Post}(X, U) \setminus X</span>, the set of states outside <span class="math">X</span> which can be reached in one step, into convex polytopes.
      </p>
      <p>
        Based on this partition, a game-based abstraction of the linear stochastic system is built.
      </p>

      <h3>Game-based LSS Abstraction</h3>
      <p>
        ...
      </p>

      <h3>Product of Game and Objective Automaton</h3>
      <p>
        ...
      </p>

      <h3>Game analysis</h3>
      <p>
        ...
      </p>

      <h3>Controller Synthesis</h3>
      <p>
        ...
      </p>
    </div>

    <h2 id="about">About</h2>
    <div>
      <p>
        This application is an implementation of an algorithm developed by <a href="#Svorenova2017">Svoreňová et al. (2017)</a>.
        Their original implementation, written in Matlab and Java, served as a guideline for this port to JavaScript.
        It is part of the Master's thesis of Christopher Polster, supervised by <a href="https://www7.in.tum.de/~kretinsk/">Jan Křetínský</a> from the <a href="https://www7.in.tum.de/home/index.php">Chair for Foundations of Software Reliability and Theoretical Computer Science</a> at Technische Universität München.
      </p>
      <p>
        Source code is available on <a href="https://github.com/chpolste/MScCSE">GitHub</a>.
      </p>
    </div>

    <h2 id="references">References</h2>
    <div>
      <p id="Svorenova2017">
        Svoreňová, M., Křetínský, J., Chmelík, M., Chatterjee, K., Černá, I., & Belta, C. (2017).
        Temporal logic control for stochastic linear systems using abstraction refinement of probabilistic games.
        <em>Nonlinear Analysis: Hybrid Systems, 23(15)</em>, 230–253.
        DOI: <a href="https://doi.org/10.1016/j.nahs.2016.04.006">10.1016/j.nahs.2016.04.006</a>
      </p>
    </div>


    <div class="info_content" id="info_view_settings">
      The <span class="math">x_{t+1} = Ax_t</span> part of the LSS-equation <span class="math">x_{t+1} = Ax_t + Bu_t + w_t</span> is visualized by the <b>vector field</b>.
      The <b>highlight operator</b> shows one of the following polytopic operators related to the selected state <span class="math">X'</span>:
      <ul>
        <li class="math">\mathrm{Post}(X', U) \subseteq (X \cup X_{out})</li>
        <li class="math">\mathrm{Pre}(X, U, \{X'\}) \subseteq X</li>
        <li class="math">\mathrm{PreR}(X, U, \{X'\}) \subseteq X</li>
        <li class="math">\mathrm{Attr}(X, U, \{X'\}) \subseteq X</li>
        <li class="math">\mathrm{AttrR}(X, U, \{X'\}) \subseteq X</li>
      </ul>
      where <span class="math">X</span> and <span class="math">U</span> are the (entire) state and control space, respectively.
    </div>
    <div class="info_content" id="info_pathcontrol">
      <p>
        <b>Figure</b>: view of the control space polytope <span class="math">U</span> with highlighted action polytopes <span class="math">U_i^J</span> when an action is selected.
      </p>
      <p>
        <b>Controls</b>: Sampling of paths through the system based on the selected strategy.
        Paths are initiated from the currently selected polytope or the state space polytope if the selection is empty.
        Paths are terminated when they have left the state space polytope.
        The slider can be used to restrict the path length with a maximum of 50 steps.
      </p>
    </div>
    <div class="info_content" id="info_selected_state">
      TODO
    </div>
    <div class="info_content" id="info_actions">
      TODO
    </div>
    <div class="info_content" id="info_action_supports">
      TODO
    </div>
    <div class="info_content" id="info_analysis">
      Create a game from the synchronized product of the transition system induced by the abstracted LSS and the objective automaton and analyze it.<br>
      The analysis is offloaded to a web worker.
    </div>
    <div class="info_content" id="info_abstraction_refinement">
      TODO
    </div>
    <div class="info_content" id="info_snapshots">
      Save and restore the current state of the system.
    </div>

    <script src="js/inspector.js"></script>
  </body>
</html>
