(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.renderTeX=renderTeX;exports.create=create;exports.createSVG=createSVG;exports.nodeify=nodeify;exports.setAttributes=setAttributes;exports.addEventListeners=addEventListeners;exports.removeChildren=removeChildren;exports.appendChildren=appendChildren;exports.replaceChildren=replaceChildren;exports.appendAfter=appendAfter;exports.createButton=createButton;exports.fromChildElement=fromChildElement;exports.setCursor=setCursor;exports.popupDownload=popupDownload;exports.infoBox=infoBox;exports.snLabel=exports.Keybindings=exports.SVGNS=exports.TEXTAREA=exports.TABLE=exports.SPAN=exports.SELECT=exports.P=exports.OPTION=exports.LABEL=exports.INPUT=exports.H3=exports.FORM=exports.DIV=exports.BUTTON=exports.A=void 0;function renderTeX(tex,element){katex.render(tex,element,{throwOnError:false});return element}function create(tag,attributes,children){const node=document.createElement(tag);if(attributes!=null)setAttributes(node,attributes);if(children!=null)appendChildren(node,children);return node}const A=(a,c)=>create("a",a,c);exports.A=A;const BUTTON=(a,c)=>create("button",a,c);exports.BUTTON=BUTTON;const DIV=(a,c)=>create("div",a,c);exports.DIV=DIV;const FORM=(a,c)=>create("form",a,c);exports.FORM=FORM;const H3=(a,c)=>create("h3",a,c);exports.H3=H3;const INPUT=(a,c)=>create("input",a,c);exports.INPUT=INPUT;const LABEL=(a,c)=>create("label",a,c);exports.LABEL=LABEL;const OPTION=(a,c)=>create("option",a,c);exports.OPTION=OPTION;const P=(a,c)=>create("p",a,c);exports.P=P;const SELECT=(a,c)=>create("select",a,c);exports.SELECT=SELECT;const SPAN=(a,c)=>create("span",a,c);exports.SPAN=SPAN;const TABLE=(a,c)=>create("table",a,c);exports.TABLE=TABLE;const TEXTAREA=(a,c)=>create("textarea",a,c);exports.TEXTAREA=TEXTAREA;const SVGNS="http://www.w3.org/2000/svg";exports.SVGNS=SVGNS;function createSVG(tag,attributes,children){const node=document.createElementNS(SVGNS,tag);if(attributes!=null)setAttributes(node,attributes);if(children!=null)appendChildren(node,children);return node}function nodeify(item){return typeof item==="string"?document.createTextNode(item):item}function setAttributes(node,attributes){for(let name in attributes){node.setAttribute(name,attributes[name])}}function addEventListeners(node,handlers){for(let event in handlers){node.addEventListener(event,handlers[event])}}function removeChildren(node){while(node.firstChild){node.removeChild(node.firstChild)}}function appendChildren(parentNode,children){for(let child of children){parentNode.appendChild(nodeify(child))}}function replaceChildren(parentNode,childNodes){let i=0;for(let childNode of childNodes){const oldNode=parentNode.childNodes[i];const newNode=nodeify(childNode);if(oldNode!=null){parentNode.replaceChild(newNode,oldNode)}else{parentNode.appendChild(newNode)}i++}while(parentNode.childNodes[i]!=null){parentNode.removeChild(parentNode.childNodes[i])}}function appendAfter(parent,before,after){const sibling=before.nextSibling;if(sibling==null){parent.appendChild(nodeify(after))}else{parent.insertBefore(nodeify(after),sibling)}}function createButton(a,c,f){const button=BUTTON(a,c);button.addEventListener("click",f);return button}function fromChildElement(node,e){let tgt=e.relatedTarget;if(tgt instanceof Node){while(tgt!=null&&tgt!==node){tgt=tgt.parentNode}}return tgt===node}function setCursor(cursor){let body=document.body;if(body!=null){body.style.cursor=cursor}}function popupDownload(content,filename){const body=document.body;if(body!=null){const a=document.createElement("a");a.href=content;a.setAttribute("download",filename);body.appendChild(a);a.click();body.removeChild(a)}else{window.open(content)}}class Keybindings{constructor(){this.bindings=new Map;document.addEventListener("keypress",e=>this.keyPress(e))}bind(key,callback){this.bindings.set(key,callback)}keyPress(event){const callback=this.bindings.get(event.key);if(event.target===document.body&&!event.ctrlKey&&!event.altKey&&callback!=null){callback(event)}}}exports.Keybindings=Keybindings;const SPLIT_LABEL_REGEX=/^([a-zA-Z]+)(\d+)$/;const NUM_TSPAN_ATTRS={"dy":"2","font-size":"0.8em"};const snLabel={split:function(text){const match=SPLIT_LABEL_REGEX.exec(text);return match==null?[text,""]:[match[1],match[2]]},toTeX:function(text){const[name,num]=snLabel.split(text);return num.length===0?name:name+"_"+num},toHTML:function(text){const[name,num]=snLabel.split(text);return SPAN({},num.length===0?[name]:[name,create("sub",{},[num])])},toSVG:function(text){const[name,num]=snLabel.split(text);return createSVG("text",{},num.length===0?[name]:[name,createSVG("tspan",NUM_TSPAN_ATTRS,[num])])}};exports.snLabel=snLabel;function infoBox(contentID){const node=DIV({"class":"info-button"},["?"]);node.addEventListener("mouseover",e=>{const content=document.getElementById(contentID);if(content!=null){content.style.display="block";content.style.top=String(node.offsetTop)+"px";content.style.left=String(node.offsetLeft-content.offsetWidth-5)+"px"}});node.addEventListener("mouseout",e=>{const content=document.getElementById(contentID);if(content!=null){content.style.display="none"}});return node}

},{}],2:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.autoProjection=autoProjection;exports.Horizontal1D=exports.Cartesian2D=exports.Layer=exports.Figure=void 0;var linalg=_interopRequireWildcard(require("./linalg.js"));var _tools=require("./tools.js");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}}newObj.default=obj;return newObj}}class Figure extends _tools.ObservableMixin{constructor(){super();this.layers=[]}newLayer(style){let layer=new Layer(this,style);this.layers.push(layer);this.notify({event:"newLayer",layer:layer});return layer}}exports.Figure=Figure;class Layer extends _tools.ObservableMixin{constructor(figure,style){super();this.figure=figure;this._shapes=[];this.style=style!=null?style:{}}get shapes(){return this._shapes}set shapes(shapes){this._shapes=Array.from(shapes);this.notify()}}exports.Layer=Layer;function largestPowerOf10In(x){return Math.pow(10,Math.floor(Math.log10(x)))}function linearTicks(min,max,n){const diff=(max-min)/n;const lp10=largestPowerOf10In(diff);const increment=Math.ceil(diff/lp10)*lp10;let init;if(min<=0&&0<=max){init=0}else if(max-min>lp10*10){init=Math.ceil(min/lp10/10)*lp10*10}else{init=Math.ceil(min/lp10)*lp10}const ticks=[];for(let i=-n;i<=n;i++){const tick=init+i*increment;if(min<tick&&tick<max)ticks.push(tick)}return ticks}class Cartesian2D{constructor(limX,limY){this.minX=limX[0];this.maxX=limX[1];this.minY=limY[0];this.maxY=limY[1]}get center(){return[(this.minX+this.maxX)/2,(this.minY+this.maxY)/2]}fwd(coords){let[x,y]=coords;return[(x-this.minX)/(this.maxX-this.minX),(y-this.minY)/(this.maxY-this.minY)]}bwd(coords){let[x,y]=coords;return[x*(this.maxX-this.minX)+this.minX,y*(this.maxY-this.minY)+this.minY]}project(shape){let primitives=[];if(shape.kind==="polytope"){primitives.push({kind:"polygon",points:shape.vertices.map(vertex=>this.fwd(vertex))})}else if(shape.kind==="arrow"){primitives.push({kind:"arrow",origin:this.fwd(shape.origin),target:this.fwd(shape.target)})}else if(shape.kind==="label"){primitives.push({kind:"label",coords:this.fwd(shape.coords),text:shape.text})}else if(shape.kind==="marker"){primitives.push({kind:"marker",coords:this.fwd(shape.coords),size:shape.size})}else if(shape.kind==="halfspace"){const normal=shape.normal;const offset=shape.offset;const cs=[[this.minX,this.minY],[this.minX,this.maxY],[this.maxX,this.maxY],[this.maxX,this.minY]];const csIn=cs.map(v=>linalg.dot(v,normal)-offset<linalg.TOL);const vertices=[];if(csIn[0])vertices.push(cs[0]);if((0,_tools.xor)(csIn[0],csIn[1]))vertices.push([cs[0][0],(offset-normal[0]*cs[0][0])/normal[1]]);if(csIn[1])vertices.push(cs[1]);if((0,_tools.xor)(csIn[1],csIn[2]))vertices.push([(offset-normal[1]*cs[1][1])/normal[0],cs[1][1]]);if(csIn[2])vertices.push(cs[2]);if((0,_tools.xor)(csIn[2],csIn[3]))vertices.push([cs[2][0],(offset-normal[0]*cs[2][0])/normal[1]]);if(csIn[3])vertices.push(cs[3]);if((0,_tools.xor)(csIn[3],csIn[0]))vertices.push([(offset-normal[1]*cs[3][1])/normal[0],cs[3][1]]);primitives.push({kind:"polygon",points:vertices.map(v=>this.fwd(v))})}else if(shape.kind==="vectorField"){const s=shape.scaling==null?1:shape.scaling;for(let x of linearTicks(this.minX,this.maxX,shape.n==null?10:shape.n[0])){for(let y of linearTicks(this.minY,this.maxY,shape.n==null?10:shape.n[1])){const o=this.fwd([x,y]);const t=this.fwd(shape.fun([x,y]));primitives.push({kind:"arrow",origin:o,target:linalg.add(o,linalg.sub(t,o).map(_=>s*_))})}}}else if(shape.kind==="state"){const coords=this.fwd(shape.coords);primitives.push({kind:"marker",coords:coords,size:20,style:shape.member.indexOf("E")!==-1?{"stroke-dasharray":"5 3"}:{}});if(shape.member.indexOf("F")!==-1){primitives.push({kind:"marker",coords:coords,size:16})}}else if(shape.kind==="transition"){primitives.push({kind:"arrow",origin:this.fwd(shape.origin),target:this.fwd(shape.target),deltaO:[20,-6],deltaT:[-21,-6]})}else if(shape.kind==="loop"){primitives.push({kind:"loop",coords:this.fwd(shape.coords),angle:shape.angle})}else if(shape.kind==="transitionLabel"){primitives.push({kind:"__label",text:shape.text,p1:this.fwd(shape.origin),p2:this.fwd(shape.target),offset:-17})}else if(shape.kind==="loopLabel"){const[x,y]=shape.coords;const dx=Math.cos(Math.PI*shape.angle/180);const dy=-Math.sin(Math.PI*shape.angle/180);primitives.push({kind:"__label",text:shape.text,p1:this.fwd([x-dx,y-dy]),p2:this.fwd([x+dx,y+dy]),offset:-49})}else{throw new Error("unknown shape kind '"+shape.kind+"' (Cartesian2D)")}return primitives}zoom(factor){let center=this.center;let lengthX=(this.maxX-this.minX)/2;let lengthY=(this.maxY-this.minY)/2;let limX=[center[0]-lengthX*factor,center[0]+lengthX*factor];let limY=[center[1]-lengthY*factor,center[1]+lengthY*factor];return new Cartesian2D(limX,limY)}translate(start,end){let diffX=end[0]-start[0];let diffY=end[1]-start[1];let limX=[this.minX-diffX,this.maxX-diffX];let limY=[this.minY-diffY,this.maxY-diffY];return new Cartesian2D(limX,limY)}getXTicks(n){return linearTicks(this.minX,this.maxX,n).map(t=>[this.fwd([t,0])[0],(0,_tools.n2s)(t)])}getYTicks(n){return linearTicks(this.minY,this.maxY,n).map(t=>[this.fwd([0,t])[1],(0,_tools.n2s)(t)])}}exports.Cartesian2D=Cartesian2D;class Horizontal1D{constructor(lim,ylim){this.minX=lim[0];this.maxX=lim[1];this.minY=ylim==null?0.4:ylim[0];this.maxY=ylim==null?0.6:ylim[1]}get center(){return[(this.minX+this.maxX)/2]}fwd(coords){return[(coords[0]-this.minX)/(this.maxX-this.minX),0.5]}bwd(coords){return[coords[0]*(this.maxX-this.minX)+this.minX]}project(shape){let primitives=[];if(shape.kind==="polytope"){if(shape.vertices.length<2){return[]}let[l,r]=shape.vertices.map(vertex=>this.fwd(vertex));primitives.push({kind:"polygon",points:[[l[0],this.maxY],[l[0],this.minY],[r[0],this.minY],[r[0],this.maxY]]})}else if(shape.kind==="arrow"){primitives.push({kind:"arrow",origin:this.fwd(shape.origin),target:this.fwd(shape.target)})}else if(shape.kind==="label"){primitives.push({kind:"label",coords:this.fwd(shape.coords),text:shape.text})}else if(shape.kind==="marker"){primitives.push({kind:"marker",coords:this.fwd(shape.coords),size:shape.size})}else if(shape.kind==="halfspace"){const normal=shape.normal;const offset=shape.offset;let left=0;let right=1;if(normal[0]<0){left=Math.max(left,this.fwd([-offset])[0])}else{right=Math.min(right,this.fwd([offset])[0])}if(left<right){primitives.push({kind:"polygon",points:[[left,0],[left,1],[right,1],[right,0]]})}}else if(shape.kind==="vectorField"){const s=shape.scaling==null?1:shape.scaling;for(let x of linearTicks(this.minX,this.maxX,shape.n==null?10:shape.n[0])){const o=this.fwd([x]);const t=this.fwd(shape.fun([x]));primitives.push({kind:"arrow",origin:o,target:linalg.add(o,linalg.sub(t,o).map(_=>s*_))})}}else{throw new Error("unknown shape kind '"+shape.kind+"' (Horizontal1D)")}return primitives}zoom(factor){let center=this.center[0];return new Horizontal1D([center-(center-this.minX)*factor,center+(this.maxX-center)*factor],[this.minY,this.maxY])}translate(start,end){let diff=end[0]-start[0];return new Horizontal1D([this.minX-diff,this.maxX-diff],[this.minY,this.maxY])}getXTicks(n){return linearTicks(this.minX,this.maxX,n).map(t=>[this.fwd([t])[0],(0,_tools.n2s)(t)])}getYTicks(n){return[[0.5,"1D"]]}}exports.Horizontal1D=Horizontal1D;const PADDING=1.2;function autoProjection(aspectRatio,...ranges){let dim=ranges.length;if(dim==0){return new Cartesian2D([NaN,NaN],[NaN,NaN])}else if(dim==1){let[min,max]=ranges[0];let radius=(max-min)/2*PADDING;let mid=(min+max)/2;return new Horizontal1D([mid-radius,mid+radius])}else if(dim==2){let[minX,maxX]=ranges[0];let[minY,maxY]=ranges[1];let radiusX=(maxX-minX)/2*PADDING;let radiusY=(maxY-minY)/2*PADDING;let midX=(minX+maxX)/2;let midY=(minY+maxY)/2;let ratio=radiusX/radiusY;let factorX=ratio<aspectRatio?aspectRatio/ratio:1;let factorY=ratio>aspectRatio?ratio/aspectRatio:1;return new Cartesian2D([midX-radiusX*factorX,midX+radiusX*factorX],[midY-radiusY*factorY,midY+radiusY*factorY])}else{throw new Error("dim not supported")}}

},{"./linalg.js":4,"./tools.js":7}],3:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.Union=exports.Polygon=exports.Interval=exports.Polytope=exports.Halfspace=exports.TOL=void 0;var linalg=_interopRequireWildcard(require("./linalg.js"));var _tools=require("./tools.js");var _parser=require("./parser.js");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}}newObj.default=obj;return newObj}}const TOL=linalg.TOL;exports.TOL=TOL;function cartesian(...tuples){let cart=[[]];for(let tuple of tuples){cart=[].concat(...cart.map(xs=>tuple.map(y=>xs.concat([y]))))}return cart}function angleOrder(v){const angle=Math.atan2(v[1],v[0]);return angle===Math.PI?angle-2*Math.PI:angle}function angleCCW(g,h){const det=g[0]*h[1]-g[1]*h[0];const dot=g[0]*h[0]+g[1]*h[1];let angle=Math.atan2(det,dot);if(angle<0){angle=angle+2*Math.PI}return angle===2*Math.PI?0:angle}function isCCWTurn(p,q,r,zero){return(p[0]-r[0])*(q[1]-r[1])-(p[1]-r[1])*(q[0]-r[0])>zero}function reduceHullPart(hull,p,zero){while(hull.length>1&&!isCCWTurn(hull[hull.length-2],hull[hull.length-1],p,zero)){hull.pop()}}function halfplaneIntersection(g,h){const[g0,g1]=g.normal;const[h0,h1]=h.normal;const det=g0*h1-g1*h0;if(Math.abs(det)<TOL){return null}else{return[(h1*g.offset-g1*h.offset)/det,(g0*h.offset-h0*g.offset)/det]}}const hsieParse=(0,_parser.ASTParser)(/\+|-|([0-9\.]+\s*\*?\s*[a-z]?)|[0-9\.]+|[a-z]/,[{op:"+",precedence:20,associativity:-1},{op:"-",precedence:20,associativity:-1},{op:"+",precedence:50,associativity:0},{op:"-",precedence:50,associativity:0}]);function hsieSplit(text){const parts=text.split(/\s*([<>]=?)\s*/);if(parts.length!=3)throw new _parser.ParseError("not a valid inequality (requires exactly one of <=, <, >, >=)");return[hsieParse(parts[0]),parts[1][0],hsieParse(parts[2])]}const hsieNumVarPattern=/^((?:\d+(?:\.\d+)?)|(?:\.\d+))?\s*\*?\s*([a-z])?$/;function hsieTerms(node,flip){if(typeof node==="string"){const match=node.match(hsieNumVarPattern);if(match==null)throw new _parser.ParseError("unrecognized term "+node);return[{coefficient:(flip?-1:1)*(match[1]==null?1:parseFloat(match[1])),variable:match[2]==null?"":match[2]}]}else if(node.op==="-"||node.op==="+"){const isMinus=node.op==="-";const isUnary=node.args.length===1;const out=hsieTerms(node.args[0],isUnary&&isMinus?!flip:flip);if(!isUnary)out.push(...hsieTerms(node.args[1],isMinus?!flip:flip));return out}else{throw new _parser.ParseError("unexpected operator "+node.op)}}class Halfspace{constructor(normal,offset){this.normal=normal;this.offset=offset;this.dim=normal.length}static deserialize(json){return new Halfspace(json.normal,json.offset)}static normalized(normal,offset){let norm=linalg.norm2(normal);if(norm<TOL){offset=offset===0?Infinity:Math.sign(offset)*Infinity;norm=1}return new Halfspace(normal.map(x=>x/norm),offset/norm)}static parse(text,variables){const[lhs,comp,rhs]=hsieSplit(text);const terms=hsieTerms(lhs,comp===">").concat(hsieTerms(rhs,comp==="<"));let offset=0;let normal=new Array(variables.length);normal.fill(0);for(let term of terms){if(term.variable===""){offset-=term.coefficient}else{const idx=variables.indexOf(term.variable);if(idx<0)throw new _parser.ParseError("unexpected variable '"+term.variable+"'");normal[idx]+=term.coefficient}}return Halfspace.normalized(normal,offset)}get isInfeasible(){return this.offset===-Infinity}get isTrivial(){return this.offset===Infinity}applyRight(m){return Halfspace.normalized(linalg.applyRight(m,this.normal),this.offset)}contains(point){linalg.assertEqualDims(this.dim,point.length);return linalg.dot(this.normal,point)-this.offset<TOL}flip(){return new Halfspace(this.normal.map(x=>-x),-this.offset)}isSameAs(other){return linalg.areClose(this.normal,other.normal)&&Math.abs(this.offset-other.offset)<TOL}translate(v){return Halfspace.normalized(this.normal,this.offset+linalg.dot(this.normal,v))}serialize(){return{normal:this.normal,offset:this.offset}}}exports.Halfspace=Halfspace;class Polytope{constructor(vertices,halfspaces){if(this.constructor.name==="Polytope"){throw new TypeError("must not instanciate Polytope")}this._vertices=vertices;this._halfspaces=halfspaces;this._isEmpty=null}static deserialize(json){if(json.dim===1)return new Interval(json.vertices,null);if(json.dim===2)return new Polygon(json.vertices,null);throw new _tools.NotImplementedError}static empty(){throw new _tools.NotImplementedError}static hull(ps){throw new _tools.NotImplementedError}static intersection(hs){throw new _tools.NotImplementedError}static noredund(hs){throw new _tools.NotImplementedError}static ofDim(dim){if(dim===1)return Interval;if(dim===2)return Polygon;throw new _tools.NotImplementedError}get boundingBox(){if(this.isEmpty)return this;let bbox=cartesian(...this.extent);return this.constructor.hull(bbox)}get centroid(){throw new _tools.NotImplementedError}get extent(){let mins=new Array(this.dim);mins.fill(Infinity);let maxs=new Array(this.dim);maxs.fill(-Infinity);for(let vertex of this.vertices){vertex.map((x,i)=>{if(x<mins[i]){mins[i]=x}if(x>maxs[i]){maxs[i]=x}})}return _tools.arr.zip2(mins,maxs)}get halfspaces(){if(this._halfspaces!=null)return this._halfspaces;this._VtoH();return this.halfspaces}get isDisjunct(){return true}get isEmpty(){if(this._isEmpty!=null)return this._isEmpty;this._isEmpty=this._vertices!=null&&this._vertices.length<=this.dim||this._halfspaces!=null&&this._halfspaces.length<=this.dim||this.volume<TOL;return this._isEmpty}get polytopes(){return this.isEmpty?[]:[this]}get vertices(){if(this._vertices!=null)return this._vertices;this._HtoV();return this.vertices}get volume(){throw new _tools.NotImplementedError}apply(m){linalg.assertEqualDims(m[0].length,this.dim);return Polytope.ofDim(m.length).hull(this.vertices.map(v=>linalg.apply(m,v)))}applyRight(m){linalg.assertEqualDims(m.length,this.dim);return Polytope.ofDim(m[0].length).intersection(this.halfspaces.map(h=>h.applyRight(m)))}contains(p){linalg.assertEqualDims(this.dim,p.length);return _tools.iter.every(this.halfspaces.map(h=>h.contains(p)))}covers(other){if(this.isEmpty)return other.isEmpty;return other.remove(this).isEmpty}disjunctify(){return this}fulfils(predicate){linalg.assertEqualDims(this.dim,predicate.dim);return _tools.iter.every(this.vertices.map(v=>predicate.contains(v)))}hull(){return this}intersect(other){linalg.assertEqualDims(this.dim,other.dim);if(other instanceof Union){return other.intersect(this)}else{if(other.isEmpty||this.isEmpty)return other.constructor.empty();return this._intersectPolytope(other)}}intersects(other){for(let p of other.polytopes){if(!this.intersect(p).isEmpty)return true}return false}invert(){return this.constructor.hull(this.vertices.map(v=>v.map(x=>-x)))}isSameAs(other){if(other instanceof Union){return other.isSameAs(this)}else{const vs=this.vertices;const ws=other.vertices;if(this.dim!==other.dim||vs.length!==ws.length){return false}let idxoff=0;while(idxoff<vs.length){if(linalg.areClose(vs[idxoff],ws[0])){break}idxoff++}for(let i=0;i<vs.length;i++){if(!linalg.areClose(vs[(idxoff+i)%vs.length],ws[i])){return false}}return idxoff<vs.length}}minkowski(other){linalg.assertEqualDims(this.dim,other.dim);let points=[];for(let v of this.vertices){for(let w of other.vertices){points.push(linalg.add(v,w))}}return this.constructor.hull(points)}pontryagin(other){linalg.assertEqualDims(this.dim,other.dim);const ws=other.invert().vertices;const halfspaces=[];for(let h of this.halfspaces){for(let w of ws){halfspaces.push(h.translate(w))}}return this.constructor.noredund(halfspaces)}remove(other){const polytopes=other.polytopes;if(polytopes.length===0)return this;let k=0;let halfspaces=null;while(halfspaces==null&&k<polytopes.length){const intersection=this.intersect(polytopes[k]);if(intersection.isEmpty){k++}else{halfspaces=intersection.halfspaces}}if(halfspaces==null)return this;const out=[];let poly=this;for(let halfspace of halfspaces){const[_poly,polyCandidate]=poly.split(halfspace);if(!polyCandidate.isEmpty){if(k<polytopes.length-1){const toRemove=new Union(this.dim,polytopes.slice(k+1),null);out.push(...polyCandidate.remove(toRemove).polytopes)}else{out.push(polyCandidate)}}poly=_poly}return out.length===1?out[0]:new Union(this.dim,out,true)}sample(){const extent=this.extent;for(let i=0;i<10*this.dim;i++){const point=this.extent.map(([l,u])=>l+(u-l)*Math.random());if(this.contains(point))return point}return this.centroid}scale(factor){const c=this.centroid;return this.constructor.hull(this.vertices.map(v=>_tools.arr.zip2map((a,b)=>a+factor*(b-a),c,v)))}serialize(){return{dim:this.dim,vertices:this.vertices}}simplify(){return this}shatter(){throw new _tools.NotImplementedError}split(h){const intersection=this.constructor.intersection;return[intersection([...this.halfspaces,h]),intersection([...this.halfspaces,h.flip()])]}toUnion(){return new Union(this.dim,[this],true)}translate(v){linalg.assertEqualDims(v.length,this.dim);return this.constructor.hull(this.vertices.map(x=>linalg.add(x,v)))}union(other){return Union.from([this,...other.polytopes])}_intersectPolytope(other){return other.constructor.intersection([...this.halfspaces,...other.halfspaces])}_VtoH(){throw new _tools.NotImplementedError}_HtoV(){throw new _tools.NotImplementedError}}exports.Polytope=Polytope;class Interval extends Polytope{constructor(vertices,halfspaces){super(vertices,halfspaces);this.dim=1}static empty(){return new Interval([],[])}static hull(ps){ps.forEach(p=>linalg.assertEqualDims(p.length,1));let leftIdx=0;let rightIdx=0;for(let idx=1;idx<ps.length;idx++){if(ps[idx][0]<ps[leftIdx][0]){leftIdx=idx}if(ps[idx][0]>ps[rightIdx][0]){rightIdx=idx}}if(ps.length<2||linalg.areClose(ps[leftIdx],ps[rightIdx])){return Interval.empty()}else{return new Interval([ps[leftIdx],ps[rightIdx]],null)}}static intersection(halfspaces){return Interval.noredund(halfspaces)}static noredund(halfspaces){const hs=[];for(let h of halfspaces){linalg.assertEqualDims(h.dim,1);if(h.isInfeasible){return Interval.empty()}else if(!h.isTrivial){hs.push(h)}}let leftIdx=-1;let rightIdx=-1;for(let idx=0;idx<hs.length;idx++){if(hs[idx].normal[0]<0&&(leftIdx<0||hs[idx].offset<hs[leftIdx].offset)){leftIdx=idx}if(hs[idx].normal[0]>0&&(rightIdx<0||hs[idx].offset<hs[rightIdx].offset)){rightIdx=idx}}if(leftIdx<0||rightIdx<0||hs[rightIdx].offset+hs[leftIdx].offset<TOL){return Interval.empty()}else{return new Interval(null,[hs[leftIdx],hs[rightIdx]])}}get boundingBox(){return this}get centroid(){const[l,r]=this.vertices;return[(l[0]+r[0])/2]}get volume(){const vs=this.vertices;if(vs.length===0)return 0;return vs[1][0]-vs[0][0]}shatter(){const vertices=this.vertices;const centroid=this.centroid;return new Union(this.dim,[Interval.hull([centroid,vertices[0]]),Interval.hull([centroid,vertices[1]])],true)}_HtoV(){if(this._halfspaces==null){throw new _tools.ValueError}this._vertices=[[-this._halfspaces[0].offset],[this._halfspaces[1].offset]]}_VtoH(){if(this._vertices==null){throw new _tools.ValueError}const[left,right]=this._vertices;this._halfspaces=[new Halfspace([-1],-left[0]),new Halfspace([1],right[0])]}}exports.Interval=Interval;class Polygon extends Polytope{constructor(vertices,halfspaces){super(vertices,halfspaces);this.dim=2}static empty(){return new Polygon([],[])}static hull(ps){ps.forEach(p=>linalg.assertEqualDims(p.length,2));const points=ps.slice().sort((p,q)=>p[0]==q[0]?q[1]-p[1]:p[0]-q[0]);const ls=[];for(let i=0;i<points.length;i++){reduceHullPart(ls,points[i],0);ls.push(points[i])}const us=[];for(let i=points.length-1;i>=0;i--){reduceHullPart(us,points[i],0);us.push(points[i])}if(ls.length+us.length<5){return Polygon.empty()}const vs=[];for(let i=0;i<ls.length-1;i++){reduceHullPart(vs,ls[i],TOL);vs.push(ls[i])}for(let i=0;i<us.length-1;i++){reduceHullPart(vs,us[i],TOL);vs.push(us[i])}reduceHullPart(vs,vs[0],TOL);while(vs.length>1&&!isCCWTurn(vs[vs.length-1],vs[0],vs[1],TOL)){vs.shift()}return vs.length<3?Polygon.empty():new Polygon(vs,null)}static intersection(halfspaces){const hs=[];for(let h of halfspaces){linalg.assertEqualDims(h.dim,2);if(h.isInfeasible){return Polygon.empty()}hs.push(h)}return Polygon.noredund(hs.sort((g,h)=>{const gOrder=angleOrder(g.normal);const hOrder=angleOrder(h.normal);return gOrder==hOrder?angleCCW(g.normal,h.normal)-Math.PI:gOrder-hOrder}))}static noredund(halfplanes){const loop=[];const cuts=[];let idx=0;while(idx<halfplanes.length){const next=halfplanes[idx];if(next.isTrivial){idx++;continue}if(loop.length==0){loop.push(next);idx++;continue}const last=loop[loop.length-1];const angle=angleCCW(last.normal,next.normal);if(angle>Math.PI-TOL){return Polygon.empty()}const nextCut=halfplaneIntersection(last,next);if(nextCut==null){if(last.offset>next.offset){cuts.pop();loop.pop()}else{idx++}continue}if(cuts.length>0&&(!next.contains(cuts[cuts.length-1])||linalg.areClose(nextCut,cuts[cuts.length-1]))){cuts.pop();loop.pop();continue}cuts.push(nextCut);loop.push(next);idx++}let lidx=0;let ridx=loop.length;while(ridx-lidx>=3){const angle=angleCCW(loop[ridx-1].normal,loop[lidx].normal);if(angle>Math.PI-TOL){return Polygon.empty()}const endCut=halfplaneIntersection(loop[lidx],loop[ridx-1]);if(endCut==null){if(loop[lidx].offset>loop[ridx-1].offset){lidx++}else{ridx--}}else if(!loop[ridx-2].contains(endCut)||linalg.areClose(cuts[ridx-2],endCut)){ridx--}else if(!loop[lidx+1].contains(endCut)||linalg.areClose(cuts[lidx],endCut)){lidx++}else{break}}const out=ridx-lidx<3||angleCCW(loop[ridx-1].normal,loop[lidx].normal)>Math.PI-TOL?[]:loop.slice(lidx,ridx);return new Polygon(null,out)}get centroid(){const vol=this.volume;const x=_tools.iter.sum(_tools.arr.cyc2map((a,b)=>(a[0]+b[0])*(a[0]*b[1]-b[0]*a[1]),this.vertices));const y=_tools.iter.sum(_tools.arr.cyc2map((a,b)=>(a[1]+b[1])*(a[0]*b[1]-b[0]*a[1]),this.vertices));return[x/6/vol,y/6/vol]}get volume(){return 0.5*_tools.iter.sum(_tools.arr.cyc2map((a,b)=>a[0]*b[1]-b[0]*a[1],this.vertices))}shatter(){const c=this.centroid;const vs=this.vertices;const l=vs.length;const polys=[[c,vs[0],linalg.midpoint(vs[l-1],vs[0]),linalg.midpoint(vs[0],vs[1])],[c,vs[l-1],linalg.midpoint(vs[l-2],vs[l-1]),linalg.midpoint(vs[l-1],vs[0])]];for(let i=1;i<l-1;i++){polys.push([c,vs[i],linalg.midpoint(vs[i-1],vs[i]),linalg.midpoint(vs[i],vs[i+1])])}return new Union(this.dim,polys.map(Polygon.hull),true)}_HtoV(){if(this._halfspaces==null){throw new _tools.ValueError}else{this._vertices=_tools.arr.cyc2map(function(v,w){const cut=halfplaneIntersection(v,w);if(cut==null){throw{}}else{return cut}},this._halfspaces)}}_VtoH(){if(this._vertices==null){throw new _tools.ValueError}else{this._halfspaces=_tools.arr.cyc2map(function(v,w){return Halfspace.normalized([w[1]-v[1],v[0]-w[0]],v[0]*w[1]-w[0]*v[1])},this._vertices)}}}exports.Polygon=Polygon;class Union{constructor(dim,polytopes,isDisjunct){this.dim=dim;this.polytopes=polytopes.filter(_=>!_.isEmpty);this.isEmpty=this.polytopes.length===0;this._isDisjunct=this.polytopes.length<2||isDisjunct}static deserialize(json){return new Union(json.dim,json.polytopes.map(Polytope.deserialize),null)}static empty(dim){return new Union(dim,[],true)}static from(polytopes,fallbackDim){const dim=polytopes.length>0?polytopes[0].dim:fallbackDim;if(dim==null)throw new _tools.ValueError("Unable to determine dimension from empty set of polytopes (no fallback provided)");polytopes.forEach(_=>linalg.assertEqualDims(_.dim,dim));return new Union(dim,polytopes,null)}get boundingBox(){const Poly=Polytope.ofDim(this.dim);return this.isEmpty?Poly.empty():Poly.hull(cartesian(...this.extent))}get extent(){const init=new Array(this.dim);init.fill([Infinity,-Infinity]);return this.polytopes.map(_=>_.extent).reduce((ext,cur)=>{return _tools.arr.zip2map((a,b)=>[a[0]<b[0]?a[0]:b[0],a[1]<b[1]?b[1]:a[1]],ext,cur)},init)}get isDisjunct(){return this._isDisjunct!=null&&this._isDisjunct}get volume(){const polytopes=this.isDisjunct?this.polytopes:this.simplify().polytopes;return _tools.iter.sum(polytopes.map(_=>_.volume))}apply(m){return new Union(this.dim,this.polytopes.map(_=>_.apply(m)),this._isDisjunct)}applyRight(m){linalg.assertEqualDims(m.length,this.dim);return new Union(m[0].length,this.polytopes.map(_=>_.applyRight(m)),this._isDisjunct)}contains(v){for(let p of this.polytopes){if(p.contains(v))return true}return false}covers(other){if(this.isEmpty)return other.isEmpty;return other.remove(this).isEmpty}disjunctify(){const ps=this.polytopes.slice().sort((x,y)=>x.volume-y.volume);const out=[];while(ps.length>0){const p=ps.pop();out.push(...p.remove(new Union(this.dim,out,true)).polytopes)}return new Union(this.dim,out,true)}fulfils(h){return _tools.iter.every(this.polytopes.map(_=>_.fulfils(h)))}hull(){const vertices=[];for(let polytope of this.polytopes){vertices.push(...polytope.vertices)}return Polytope.ofDim(this.dim).hull(vertices)}intersect(other){const out=[];for(let x of this.polytopes){for(let y of other.polytopes){const intersection=x.intersect(y);if(!intersection.isEmpty){out.push(intersection)}}}return out.length===1?out[0]:new Union(this.dim,out,this._isDisjunct?true:null)}intersects(other){for(let p of this.polytopes){if(p.intersects(other))return true}return false}invert(){return new Union(this.dim,this.polytopes.map(_=>_.invert()),this._isDisjunct)}isSameAs(other){return this.covers(other)&&other.covers(this)}minkowski(other){return new Union(this.dim,this.polytopes.map(_=>_.minkowski(other)),null)}pontryagin(other){const bbox=this.boundingBox;const complement=bbox.remove(this);return bbox.pontryagin(other).remove(complement.minkowski(other.invert()))}remove(other){const out=[];for(let p of this.polytopes){out.push(...p.remove(other).polytopes)}return new Union(this.dim,out,this._isDisjunct?true:null)}sample(){if(this.polytopes.length>=1){return this.polytopes[0].sample()}throw new _tools.NotImplementedError}serialize(){return{dim:this.dim,polytopes:this.polytopes.map(_=>_.serialize())}}shatter(){const pieces=[];for(let x of this.polytopes){pieces.push(...x.shatter().polytopes)}return new Union(this.dim,pieces,this._isDisjunct)}simplify(){if(this.isEmpty)return this;if(this.polytopes.length===1)return this.polytopes[0];const hull=this.hull();const rest=hull.remove(this);if(rest.isEmpty){return hull}else{return hull.remove(rest)}}toUnion(){return this}translate(v){return new Union(this.dim,this.polytopes.map(_=>_.translate(v)),this._isDisjunct)}union(other){linalg.assertEqualDims(this.dim,other.dim);return new Union(this.dim,[...this.polytopes,...other.polytopes],null)}}exports.Union=Union;

},{"./linalg.js":4,"./parser.js":5,"./tools.js":7}],4:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.assertEqualDims=assertEqualDims;exports.norm2=norm2;exports.dot=dot;exports.add=add;exports.sub=sub;exports.midpoint=midpoint;exports.areClose=areClose;exports.apply=apply;exports.applyRight=applyRight;exports.eye=eye;exports.det=det;exports.inv=inv;exports.transpose=transpose;exports.matmul=matmul;exports.minkowski=exports.TOL=exports.MathError=exports.DimensionMismatch=void 0;var _tools=require("./tools.js");class DimensionMismatch extends Error{}exports.DimensionMismatch=DimensionMismatch;class MathError extends Error{}exports.MathError=MathError;const TOL=1e-8;exports.TOL=TOL;function assertEqualDims(n,m){if(n!=m){throw new DimensionMismatch(String(n)+" != "+String(m))}}function norm2(v){let squares=0;for(let x of v){squares+=x*x}return Math.sqrt(squares)}function dot(v,w){assertEqualDims(v.length,w.length);let sum=0;for(let i=0;i<v.length;i++){sum+=v[i]*w[i]}return sum}function add(v,w){assertEqualDims(v.length,w.length);return _tools.arr.zip2map((a,b)=>a+b,v,w)}function sub(v,w){assertEqualDims(v.length,w.length);return _tools.arr.zip2map((a,b)=>a-b,v,w)}function midpoint(v,w){assertEqualDims(v.length,w.length);return _tools.arr.zip2map((a,b)=>a+0.5*(b-a),v,w)}function areClose(v,w){assertEqualDims(v.length,w.length);return norm2(sub(v,w))<TOL}function apply(m,v){assertEqualDims(m[0].length,v.length);return m.map(row=>dot(row,v))}function applyRight(m,v){return matmul([v],m)[0]}function eye(size){const m=[];for(let i=0;i<size;i++){const row=new Array(size);row.fill(0);row[i]=1;m.push(row)}return m}function det(m){assertEqualDims(m.length,m[0].length);switch(m.length){case 1:return m[0][0];case 2:return m[0][0]*m[1][1]-m[0][1]*m[1][0];default:throw new _tools.NotImplementedError;}}function inv(m){assertEqualDims(m.length,m[0].length);const d=det(m);if(Math.abs(d)<TOL){throw new MathError("matrix not invertible")}else{switch(m.length){case 1:return[[1/d]];case 2:return[[m[1][1]/d,-m[0][1]/d],[-m[1][0]/d,m[0][0]/d]];default:throw new _tools.NotImplementedError;}}}function transpose(m){const result=[];for(let j=0;j<m[0].length;j++){const row=[];for(let i=0;i<m.length;i++){row.push(m[i][j])}result.push(row)}return result}function matmul(m,n){assertEqualDims(m[0].length,n.length);const result=[];for(let i=0;i<m.length;i++){const row=[];for(let j=0;j<n[0].length;j++){let akkumulator=0;for(let k=0;k<n.length;k++){akkumulator+=m[i][k]*n[k][j]}row.push(akkumulator)}result.push(row)}return result}const minkowski={xmy(xs,ys){const out=[];for(let x of xs){for(let y of ys){out.push(sub(x,y))}}return out},axpy(A,xs,ys){const out=[];for(let x of xs){const Ax=apply(A,x);for(let y of ys){out.push(add(Ax,y))}}return out}};exports.minkowski=minkowski;

},{"./tools.js":7}],5:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.ASTParser=ASTParser;exports.printAST=printAST;exports.ParseError=void 0;class ParseError extends Error{}exports.ParseError=ParseError;function ASTParser(tokenPattern,operators){const pcparser=new PCParser(operators);return function(text){const tokenStream=new TokenStream(text,tokenPattern);return pcparser.parse(tokenStream)}}function printAST(node){return typeof node==="string"?node:node.op+"("+node.args.map(printAST).join(", ")+")"}class TokenStream{constructor(text,pattern){this.text=text;this.pattern=RegExp("\\s*("+pattern.source+")\\s*","gy");this.advance()}advance(){if(this.pattern.lastIndex==this.text.length){this.current=null}else{const lastIndex=this.pattern.lastIndex;const match=this.pattern.exec(this.text);if(match==null)throw new ParseError("unable to tokenize '"+this.text.slice(lastIndex)+"'");this.current=match[1]}}list(){const tokens=[];while(this.current!=null){tokens.push(this.current);this.advance()}return tokens}}class PCParser{constructor(operators){this.uProp={};this.bProp={};for(let operator of operators){if(operator.associativity===0){this.uProp[operator.op]=operator.precedence}else{this.bProp[operator.op]=[operator.precedence,operator.associativity<0]}}}parse(tokens){const ast=this.computeExpr(tokens,0);if(tokens.current!=null)throw new ParseError("expected end token but found token "+tokens.current);return ast}computeExpr(tokens,minPrec){let left=this.computeAtom(tokens);while(true){const token=tokens.current;if(token==null||!this.bProp.hasOwnProperty(token)){break}const[prec,lAssoc]=this.bProp[token];if(prec<minPrec){break}tokens.advance();const right=this.computeExpr(tokens,lAssoc?prec+1:prec);left={op:token,args:[left,right]}}return left}computeAtom(tokens){const token=tokens.current;if(token==null)throw new ParseError("unexpected end of token stream");tokens.advance();if(this.uProp.hasOwnProperty(token)){const arg=this.computeExpr(tokens,this.uProp[token]);return{op:token,args:[arg]}}else if(token==="("){const inner=this.computeExpr(tokens,0);if(tokens.current!==")")throw new ParseError("unexpected token "+String(tokens.current)+", expected closing parenthesis");tokens.advance();return inner}else{return token}}}

},{}],6:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.SelectableNodes=void 0;var dom=_interopRequireWildcard(require("./dom.js"));var _figure=require("./figure.js");var _geometry=require("./geometry.js");var _tools=require("./tools.js");var _widgetsInput=require("./widgets-input.js");var _widgetsPlot=require("./widgets-plot.js");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}}newObj.default=obj;return newObj}}class SelectableNodes extends _tools.ObservableMixin{constructor(itemToNode,emptyMessage){super();this.itemToNode=itemToNode;this.emptyMessage=emptyMessage;this._selection=null;this.hoverSelection=null;this.nodeMap=new Map;this.node=dom.DIV({"class":"items"},[emptyMessage])}set items(items){this.nodeMap.clear();this.selection=null;this.hoverSelection=null;if(items.length==0){this.node.innerHTML=this.emptyMessage}else{dom.replaceChildren(this.node,items.map(item=>this.createNode(item)))}this.notify()}get selection(){return this._selection}set selection(item){if(this.selection!=null){let curNode=this.nodeMap.get(this.selection);if(curNode!=null){curNode.className="item"}}if(item!=null){(0,_tools.just)(this.nodeMap.get(item)).className="item selection"}this._selection=item;this.notify(true)}createNode(item){if(this.nodeMap.has(item))throw new Error("Duplicate item in nodeMap of SelectableNodes");const node=this.itemToNode(item);node.className="item";node.addEventListener("click",()=>this.onClick(item));node.addEventListener("mouseover",()=>this.onMouseOver(item));node.addEventListener("mouseout",()=>this.onMouseOut(item));this.nodeMap.set(item,node);return node}onClick(item){this.selection=this.selection===item?null:item}onMouseOver(item){this.hoverSelection=item;this.notify(false)}onMouseOut(item){this.hoverSelection=null;this.notify(false)}}exports.SelectableNodes=SelectableNodes;function longColor(color){return color.length===4?"#"+color[1]+color[1]+color[2]+color[2]+color[3]+color[3]:color}class PolytopeItem extends _tools.ObservableMixin{constructor(polytopes,polytope,label){super();this.polytopes=polytopes;this.polytope=polytope;this.label=[false,label];this.fill=[false,"#FFFFFF"];this.stroke=[true,"#000000"];this.attach(()=>this.polytopes.notify())}asShapes(){const shapes=[];shapes.push({kind:"polytope",vertices:this.polytope.vertices,style:{fill:this.fill[0]?this.fill[1]:"none",stroke:this.stroke[0]?this.stroke[1]:"none"}});if(this.label[0])shapes.push({kind:"label",coords:this.polytope.centroid,text:this.label[1],style:{dy:"3"}});return shapes}remove(){this.polytopes.remove(this)}moveup(){this.polytopes.moveup(this)}movedown(){this.polytopes.movedown(this)}serialize(){return[this.polytope.serialize(),this.label,this.fill,this.stroke]}static deserialize(data,polytopes){const[poly,label,fill,stroke]=data;const item=new PolytopeItem(polytopes,_geometry.Polytope.deserialize(poly),"");fill[1]=longColor(fill[1]);stroke[1]=longColor(stroke[1]);item.label=label;item.fill=fill;item.stroke=stroke;return item}static toNode(item){const fig=new _figure.Figure;fig.newLayer().shapes=item.asShapes().filter(_=>_.kind==="polytope");const plot=new _widgetsPlot.ShapePlot([40,40],fig,(0,_figure.autoProjection)(1,...item.polytope.extent),false);return dom.DIV({"class":"poly"},[dom.DIV({"class":"left"},[plot.node]),dom.DIV({"class":"right"},[dom.DIV({"class":"label"},[item.label[1]]),dom.DIV({},["Hull: [",item.polytope.vertices.map(_=>"["+_.map(n=>(0,_tools.n2s)(n,2)).join(",")+"]").join(", "),"]"])])])}}class PolytopeList extends _tools.ObservableMixin{constructor(){super();this.items=[]}get length(){return this.items.length}get extent(){return this.items.length>0?_geometry.Union.from(this.items.map(_=>_.polytope)).extent:[]}add(polytope,name){const item=new PolytopeItem(this,polytope,name);if(this.items.length===0||this.items[0].polytope.dim===polytope.dim){this.items.unshift(item)}else throw new Error("polytope dimension mismatch");this.notify()}remove(item){const idx=this.items.indexOf(item);if(idx>-1){this.items.splice(idx,1)}this.notify()}moveup(item){const idx1=this.items.indexOf(item);const idx2=Math.max(idx1-1,0);this.swap(idx1,idx2)}movedown(item){const idx1=this.items.indexOf(item);const idx2=Math.min(idx1+1,this.items.length-1);this.swap(idx1,idx2)}swap(idx1,idx2){const temp=this.items[idx1];this.items[idx1]=this.items[idx2];this.items[idx2]=temp;this.notify()}save(){return this.items.map(_=>_.serialize())}load(data){this.items=[];for(let datum of data){const item=PolytopeItem.deserialize(datum,this);if(this.items.length===0||this.items[0].polytope.dim===item.polytope.dim){this.items.push(item)}else throw new Error("polytope dimension mismatch")}this.notify()}}class TraceContainer extends _tools.ObservableMixin{constructor(){super();this._steps=[]}set steps(steps){this._steps=steps;this.notify()}asShapes(){return this._steps.map(([x,y])=>({kind:"arrow",origin:x,target:y}))}save(){return this._steps}load(json){this.steps=json}}class InputField{constructor(polytopes,trace,items){this.polytopes=polytopes;this.trace=trace;this.items=items;this.errorBox=dom.DIV({"class":"error"});this.inputBox=dom.TEXTAREA({rows:"6",cols:"70"},[]);const submitPoly=dom.createButton({},["add hull"],()=>this.addPolytope());const clearPoly=dom.createButton({},["clear all polytopes"],()=>this.clearPolytopes());const submitTrace=dom.createButton({},["add trace"],()=>this.addTrace());const clearTrace=dom.createButton({},["clear trace"],()=>this.clearTrace());this.node=dom.DIV({},[dom.P({},[this.inputBox]),dom.P({},[submitPoly," ",clearPoly," :: ",submitTrace," ",clearTrace]),this.errorBox]);this.counter=1}addPolytope(){const selection=this.items.selection;let vs=[];try{vs=JSON.parse(this.inputBox.value);if(vs.length===0)throw new Error("Polytope is empty")}catch(err){this.setError(err.message)}try{const dim=vs[0].length;const polytope=_geometry.Polytope.ofDim(dim).hull(vs);const name=this.genName();this.polytopes.add(polytope,name);this.items.selection=selection;this.setError(null)}catch(err){this.setError(err.message)}}clearPolytopes(){this.polytopes.load([])}addTrace(){let steps=[];try{const json=JSON.parse(this.inputBox.value);for(let step of json){steps.push([step.xOrigin[0],step.xTarget[0]])}this.setError(null)}catch(err){this.setError(err.message)}this.trace.steps=steps}clearTrace(){this.trace.steps=[]}setError(message){if(message==null){dom.removeChildren(this.errorBox)}else{dom.replaceChildren(this.errorBox,[message])}}genName(){return"Polytope #"+this.counter++}}class SelectionView{constructor(items){this.items=items;this.inputs={showLabel:dom.INPUT({"type":"checkbox"}),label:dom.INPUT({"type":"text","id":"label","size":"40"}),showFill:dom.INPUT({"type":"checkbox"}),fill:dom.INPUT({"type":"color"}),showStroke:dom.INPUT({"type":"checkbox"}),stroke:dom.INPUT({"type":"color"})};for(let name in this.inputs){this.inputs[name].addEventListener("change",()=>this.updateItem())}this.buttons={remove:dom.INPUT({"type":"button","value":"remove"},[]),moveup:dom.INPUT({"type":"button","value":"up"},[]),movedown:dom.INPUT({"type":"button","value":"down"},[])};this.buttons.remove.addEventListener("click",()=>{const item=this.items.selection;if(item!=null)item.remove()});this.buttons.moveup.addEventListener("click",()=>{const item=this.items.selection;if(item!=null)item.moveup();this.items.selection=item});this.buttons.movedown.addEventListener("click",()=>{const item=this.items.selection;if(item!=null)item.movedown();this.items.selection=item});this.node=dom.DIV({"class":"cols polytope-selection"},[dom.DIV({"class":"left"},[dom.DIV({},[this.inputs.label,this.inputs.showLabel]),dom.DIV({},[this.buttons.remove," :: ",this.buttons.movedown,this.buttons.moveup])]),dom.DIV({"class":"right"},[dom.DIV({},["fill ",this.inputs.showFill,this.inputs.fill]),dom.DIV({},["stroke ",this.inputs.showStroke,this.inputs.stroke])])]);this.items.attach(isClick=>{if(isClick)this.handleChange()},true)}handleChange(){const item=this.items.selection;for(let name in this.inputs){this.inputs[name].disabled=item==null}for(let name in this.buttons){this.buttons[name].disabled=item==null}this.inputs.showLabel.checked=item!=null&&item.label[0];this.inputs.label.value=item==null?"":item.label[1];this.inputs.showStroke.checked=item!=null&&item.stroke[0];this.inputs.stroke.value=item!=null?item.stroke[1]:"#000000";this.inputs.showFill.checked=item!=null&&item.fill[0];this.inputs.fill.value=item!=null?item.fill[1]:"#FFFFFF"}updateItem(){const item=this.items.selection;if(item!=null){item.label=[this.inputs.showLabel.checked,this.inputs.label.value];item.stroke=[this.inputs.showStroke.checked,this.inputs.stroke.value];item.fill=[this.inputs.showFill.checked,this.inputs.fill.value];item.notify();this.items.selection=item}}}class PlotView extends _tools.ObservableMixin{constructor(polytopes,trace){super();this.polytopes=polytopes;this.polytopes.attach(()=>this.drawPolytopes());this.trace=trace;this.trace.attach(()=>this.drawTrace());const fig=new _figure.Figure;this.layers={polytopes:fig.newLayer({"font-family":"DejaVu Sans, sans-serif","font-size":"8pt","text-anchor":"middle"}),arrows:fig.newLayer({"stroke":"#000","stroke-width":"1","fill":"#000"})};this.plot=new _widgetsPlot.InteractivePlot([100,100],fig,(0,_figure.autoProjection)(1));this.plotSizeX=new _widgetsInput.LineInput(parseInt,5,"700");this.plotSizeY=new _widgetsInput.LineInput(parseInt,5,"500");this.plotSizeX.attach(()=>this.resizePlot());this.plotSizeY.attach(()=>this.resizePlot());this.node=dom.DIV({},[dom.DIV({"class":"plot-settings"},["plot size: ",this.plotSizeX.node," by ",this.plotSizeY.node]),this.plot.node]);this._lastNumberOfPolytopes=0;this.resizePlot()}get plotParameters(){return[this.plotSizeX.value,this.plotSizeY.value,this.polytopes.extent]}drawPolytopes(){if(this._lastNumberOfPolytopes===0){this.resizePlot()}else{this.resetReferenceProjection()}const shapes=[];for(let i=this.polytopes.length-1;i>=0;i--){shapes.push(...this.polytopes.items[i].asShapes())}this.layers.polytopes.shapes=shapes;this._lastNumberOfPolytopes=this.polytopes.length}drawTrace(){this.layers.arrows.shapes=this.trace.asShapes()}resizePlot(){const[x,y,extent]=this.plotParameters;this.plot.size=[x,y];this.plot.projection=(0,_figure.autoProjection)(x/y,...extent);this.resetReferenceProjection();this.notify()}resetReferenceProjection(){const[x,y,extent]=this.plotParameters;this.plot.referenceProjection=(0,_figure.autoProjection)(x/y,...extent)}save(){return{size:[this.plotSizeX.value,this.plotSizeY.value]}}load(data){if(data.size!=null){const[sizeX,sizeY]=data.size;this.plotSizeX.text=sizeX.toString();this.plotSizeY.text=sizeY.toString()}}}function toExportURL(view,polytopes,trace){const data={view:view.save(),polytopes:polytopes.save(),trace:trace.save()};return window.btoa(JSON.stringify(data))}function fromExportURL(url,view,polytopes,trace){const data=JSON.parse(window.atob(url));if(data.view!=null)view.load(data.view);if(data.polytopes!=null)polytopes.load(data.polytopes);if(data.trace!=null)trace.load(data.trace)}document.addEventListener("DOMContentLoaded",function(){const polytopes=new PolytopeList;const trace=new TraceContainer;const plotView=new PlotView(polytopes,trace);const itemView=new SelectableNodes(PolytopeItem.toNode,"no polytopes");polytopes.attach(()=>{itemView.items=polytopes.items});const selectionView=new SelectionView(itemView);const input=new InputField(polytopes,trace,itemView);const keys=new dom.Keybindings;keys.bind("d",()=>{const selection=itemView.selection;if(selection!=null)selection.remove()});const contentNode=(0,_tools.just)(document.getElementById("content"));dom.replaceChildren(contentNode,[dom.DIV({"class":"left"},[plotView.node,input.node]),dom.DIV({"class":"right"},[selectionView.node,itemView.node])]);if(window.location.hash.length>0){const hash=window.location.hash.substring(1);fromExportURL(hash,plotView,polytopes,trace)}const updateHash=()=>{window.location.hash="#"+toExportURL(plotView,polytopes,trace)};plotView.attach(updateHash);polytopes.attach(updateHash)});

},{"./dom.js":1,"./figure.js":2,"./geometry.js":3,"./tools.js":7,"./widgets-input.js":8,"./widgets-plot.js":9}],7:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.just=just;exports.xor=xor;exports.replaceAll=replaceAll;exports.hashString=hashString;exports.n2s=n2s;exports.t2s=t2s;exports.UniqueCollection=exports.ObservableMixin=exports.obj=exports.sets=exports.arr=exports.iter=exports.ValueError=exports.NotImplementedError=void 0;class NotImplementedError extends Error{}exports.NotImplementedError=NotImplementedError;class ValueError extends Error{}exports.ValueError=ValueError;function just(val,err){if(val==null)throw new ValueError(err==null?"Value is null but shouldn't be":err);return val}function xor(p,q){return p?!q:q}const iter={some:function(xs){for(let x of xs){if(x)return true}return false},every:function(xs){for(let x of xs){if(!x)return false}return true},sum:function(xs){let s=0;for(let x of xs){s+=x}return s},count:function(xs){let c=0;for(let x of xs){c++}return c},map:function*(fun,xs){for(let x of xs){yield fun(x)}},filter:function*(test,xs){for(let x of xs){if(test(x)){yield x}}},chain:function*(...xss){for(let xs of xss){yield*xs}},argmax:function(value,xs){let maxArg=null;let maxVal=-Infinity;for(let x of xs){const val=value(x);if(val>maxVal){maxArg=x;maxVal=val}}return maxArg}};exports.iter=iter;const arr={zip2map:function(fun,xs,ys){let zs=[];for(let i=0;i<xs.length;i++){zs[i]=fun(xs[i],ys[i])}return zs},zip2:function(xs,ys){return arr.zip2map((x,y)=>[x,y],xs,ys)},cyc2map:function(fun,xs){if(xs.length==0)return[];const zs=[];for(let i=0;i<xs.length-1;i++){zs.push(fun(xs[i],xs[i+1]))}zs.push(fun(xs[xs.length-1],xs[0]));return zs},intersperse:function(delim,items){const out=[];for(let item of items){out.push(item);out.push(delim)}out.pop();return out},sample:function(items){return items[Math.floor(Math.random()*items.length)]}};exports.arr=arr;const sets={areEqual:function(xs,ys){if(xs.size!==ys.size){return false}for(let y of ys){if(!xs.has(y)){return false}}return true},isSubset:function(subs,sups){for(let sub of subs){if(!sups.has(sub)){return false}}return true},doIntersect:function(xs,ys){for(let x of xs){if(ys.has(x)){return true}}return false},union:function(...xss){return new Set(iter.chain(...xss))},intersection:function(xs,ys){return new Set(iter.filter(x=>ys.has(x),xs))},difference:function(xs,ys){return new Set(iter.filter(x=>!ys.has(x),xs))},map:function(fun,xs){return new Set(iter.map(fun,xs))},filter:function(fun,xs){return new Set(iter.filter(fun,xs))}};exports.sets=sets;const obj={forEach:function(fun,kvs){for(let key in kvs){if(kvs.hasOwnProperty(key)){fun(key,kvs[key])}}},map2Array:function(fun,kvs){const out=[];obj.forEach((key,val)=>{out.push(fun(key,val))},kvs);return out},map:function(fun,kvs){const out={};obj.forEach((key,val)=>{out[key]=fun(key,val)},kvs);return out},values:function(kvs){return obj.map2Array((k,v)=>v,kvs)},keys:function(kvs){return obj.map2Array((k,v)=>k,kvs)},merge:function(...kvss){const out={};for(let kvs of kvss){obj.forEach((key,val)=>{out[key]=val},kvs)}return out},clone:function(kvs){return Object.assign({},kvs)},fromMap:function(fun,ks){const out={};for(let k of ks){out[k]=fun(k)}return out}};exports.obj=obj;function replaceAll(haystack,needle,substitute){return haystack.split(needle).join(substitute)}function hashString(s){let hash=0;if(s.length!==0){for(let i=0;i<s.length;i++){hash=(hash<<5)-hash+s.charCodeAt(i);hash|=0}}return hash}function n2s(x,places){if(places==null)places=5;return x.toFixed(places).replace(/\.?0*$/,"")}const MSINS=1000;const MSINM=60*MSINS;const MSINH=60*MSINM;function t2s(x){const hor=Math.floor(x/MSINH);const min=Math.floor((x-hor*MSINH)/MSINM);const sec=Math.floor((x-hor*MSINH-min*MSINM)/MSINS);if(sec===0&&min===0&&hor===0){return(x/1000).toFixed(3)+" s"}else{const parts=[];if(hor>0)parts.push(hor+" h");if(min>0)parts.push(min+" min");if(sec>0)parts.push(sec+" s");return parts.join(" ")}}class ObservableMixin{constructor(){this.observers=[];this.isSendingNotifications=true}attach(observer,callImmediately){this.observers.push(observer);if(callImmediately===true)observer()}detach(observer){let idx=this.observers.indexOf(observer);if(idx<0){throw new Error("observer was not attached")}this.observers.splice(idx,1)}notify(event){if(this.isSendingNotifications){for(let observer of this.observers){observer(event)}}}}exports.ObservableMixin=ObservableMixin;class UniqueCollection{constructor(hash,areEqual){this._hash=hash;this._areEqual=areEqual;this._buckets=new Map;this._size=0}get size(){return this._size}has(value){const hash=this._hash(value);const bucket=this._buckets.get(hash);if(bucket!=null){for(let item of bucket){if(this._areEqual(item,value)){return true}}}return false}take(value){const hash=this._hash(value);let bucket=this._buckets.get(hash);if(bucket==null){bucket=this._newBucket(hash);bucket.add(value);this._size++;return value}for(let item of bucket){if(this._areEqual(item,value)){return item}}bucket.add(value);this._size++;return value}_newBucket(hash){const bucket=new Set;this._buckets.set(hash,bucket);return bucket}*[Symbol.iterator](){for(let values of this._buckets.values()){yield*values}}}exports.UniqueCollection=UniqueCollection;

},{}],8:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.inputTextRotation=inputTextRotation;exports.MatrixInput=exports.CheckboxInput=exports.RadioInput=exports.DropdownInput=exports.MultiLineInput=exports.LineInput=exports.ValidationError=void 0;var dom=_interopRequireWildcard(require("./dom.js"));var _tools=require("./tools.js");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}}newObj.default=obj;return newObj}}class ValidationError extends Error{}exports.ValidationError=ValidationError;;function inputTextRotation(input,texts){if(texts.length<1)throw new Error("texts must contain at least one choice");return function(){const idx=texts.indexOf(input.text);input.text=idx<0?texts[0]:texts[(idx+1)%texts.length]}}class LineInput extends _tools.ObservableMixin{constructor(parse,size,initialText){super();this.parse=parse;this.node=dom.INPUT({"type":"text"});if(size!=null){this.size=size}if(initialText!=null){this.text=initialText}this.node.addEventListener("change",()=>this.handleChange())}get value(){return this.parse(this.text)}get text(){return this.node.value}set text(text){this.node.value=text;this.handleChange()}set disabled(tf){this.node.disabled=tf}get isValid(){return this.node.checkValidity()}set size(size){this.node.size=size}handleChange(){try{this.value;this.node.setCustomValidity("")}catch(e){this.node.setCustomValidity("Parse Error: "+e.message)}this.notify()}}exports.LineInput=LineInput;class MultiLineInput extends _tools.ObservableMixin{constructor(parseLine,size,initialText){super();this.node=dom.TEXTAREA();this.node.addEventListener("change",()=>this.handleChange());this.parseLine=parseLine;if(size!=null){this.size=size}if(initialText!=null){this.text=initialText}}get value(){return this.text.split("\n").filter(line=>line.length>0).map((line,i)=>{try{return this.parseLine(line)}catch(e){e.message="Line "+(i+1)+": "+e.message;throw e}})}get text(){return this.node.value}set text(text){this.node.value=text;this.handleChange()}set disabled(tf){this.node.disabled=tf}get isValid(){return this.node.checkValidity()}set size(size){this.node.rows=size[0];this.node.cols=size[1]}handleChange(){try{this.value;this.node.setCustomValidity("")}catch(e){this.node.setCustomValidity("Parse Error: "+e.message)}this.notify()}}exports.MultiLineInput=MultiLineInput;class DropdownInput extends _tools.ObservableMixin{constructor(options,initialText){super();this.node=dom.SELECT();this.node.addEventListener("change",()=>this.handleChange());this.isValid=true;this.setOptions(options,initialText)}get value(){return this._options[this.text]}get text(){return this.node.value}set text(text){if(!this._options.hasOwnProperty(text))throw new Error("text '"+text+"' not in options: "+_tools.obj.keys(this._options).join(", "));this.node.value=text;this.handleChange()}set disabled(tf){this.node.disabled=tf}setOptions(options,initialText){this._options=options;dom.replaceChildren(this.node,_tools.obj.map2Array((k,v)=>dom.OPTION({},[k]),options));this.text=initialText!=null?initialText:Object.keys(options)[0]}handleChange(){this.notify()}static rangeOptions(start,stop,step){const options={};for(let i=start;i<stop;i+=step){options[String(i)]=i}return options}}exports.DropdownInput=DropdownInput;let ID_GEN=0;class RadioInput extends _tools.ObservableMixin{constructor(options,initialText,nodeify){super();this.nodeify=nodeify==null?null:nodeify;this.isValid=true;this._disabled=false;this.name="radio_id_"+ID_GEN++;this.node=dom.DIV();this.setOptions(options,initialText)}get value(){return this._options[this.text]}get text(){for(let radio of this._radios){if(radio.checked)return radio.value}throw new Error("no radio is selected")}set text(text){if(!this._options.hasOwnProperty(text))throw new Error("text '"+text+"' not in options: "+_tools.obj.keys(this._options).join(", "));for(let radio of this._radios){radio.checked=radio.value===text}this.notify()}set disabled(tf){this._disabled=tf;for(let radio of this._radios){radio.disabled=tf}}setOptions(options,initialText){this._radios=[];this._options=options;dom.replaceChildren(this.node,_tools.obj.map2Array((text,_)=>{const radio=dom.INPUT({"type":"radio","name":this.name,"value":text});radio.addEventListener("change",()=>this.handleChange());radio.disabled=this._disabled;this._radios.push(radio);return dom.LABEL({},[radio,this.nodeify==null?text:this.nodeify(text)])},options));this.text=initialText!=null?initialText:Object.keys(options)[0]}handleChange(){this.notify()}}exports.RadioInput=RadioInput;class CheckboxInput extends _tools.ObservableMixin{constructor(initialValue,label){super();this.isValid=true;this._box=dom.INPUT({"type":"checkbox"});this._box.addEventListener("change",()=>this.handleChange());this._box.checked=initialValue!=null&&initialValue;this.node=dom.LABEL({},label==null?[this._box]:[this._box,label])}get value(){return this._box.checked}get text(){return this.value?"t":"f"}set text(text){this._box.checked=text==="t";this.handleChange()}set disabled(tf){this._box.disabled=tf}handleChange(){this.notify()}}exports.CheckboxInput=CheckboxInput;class MatrixInput extends _tools.ObservableMixin{constructor(parse,shape,size,initialText){super();this.parse=parse;this._shape=shape;this._size=size;this._disabled=false;this.node=dom.TABLE({"class":"matrix"});this._createLineInputs();if(initialText!=null){this.text=initialText}}get value(){let[nrows,ncols]=this._shape;let value=[];for(let i=0;i<nrows;i++){let row=[];for(let j=0;j<ncols;j++){row.push(this.lineInputs[i*ncols+j].value)}value.push(row)}return value}get text(){return this.lineInputs.map(lineInput=>lineInput.text).join("\n")}set text(text){this.isSendingNotifications=false;_tools.arr.zip2map((lineInput,text)=>{lineInput.text=text},this.lineInputs,text.split("\n"));this.isSendingNotifications=true;this.handleChange()}set disabled(tf){this._disabled=tf;for(let lineInput of this.lineInputs){lineInput.disabled=tf}}get isValid(){for(let lineInput of this.lineInputs){if(!lineInput.isValid){return false}}return true}set size(size){this._size=size;for(let lineInput of this.lineInputs){lineInput.size=size}}get shape(){return this._shape}set shape(shape){let[nrowsOld,ncolsOld]=this._shape;let oldTexts=this.text.split("\n");this.isSendingNotifications=false;this._shape=shape;this._createLineInputs();let[nrows,ncols]=shape;for(let i=0;i<Math.min(nrows,nrowsOld);i++){for(let j=0;j<Math.min(ncols,ncolsOld);j++){this.lineInputs[i*ncols+j].text=oldTexts[i*ncolsOld+j]}}this.isSendingNotifications=true;this.handleChange()}_createLineInputs(){const[nrows,ncols]=this._shape;this.lineInputs=[];const callback=()=>this.handleChange();const trs=[];for(let i=0;i<nrows;i++){const tds=[];for(let j=0;j<ncols;j++){const input=new LineInput(this.parse,this._size,"");input.attach(callback);input.disabled=this._disabled;tds.push(dom.create("td",{},[input.node]));this.lineInputs.push(input)}trs.push(dom.create("tr",{},tds))}dom.replaceChildren(this.node,trs)}handleChange(){this.notify()}}exports.MatrixInput=MatrixInput;

},{"./dom.js":1,"./tools.js":7}],9:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.ShapePlot=exports.AxesPlot=exports.InteractivePlot=void 0;var linalg=_interopRequireWildcard(require("./linalg.js"));var dom=_interopRequireWildcard(require("./dom.js"));var _tools=require("./tools.js");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}}newObj.default=obj;return newObj}}function toStr(x){return x.toFixed(3)}class InteractivePlot{constructor(size,figure,projection){this._referenceProjection=projection;const resetButton=dom.create("a",{"href":""},["reset"]);resetButton.addEventListener("click",e=>{this.projection=this._referenceProjection;e.preventDefault()});const saveButton=dom.create("a",{"href":"","download":"plot.svg"},["export"]);saveButton.addEventListener("click",()=>{saveButton.setAttribute("href","data:image/svg+xml;base64,"+window.btoa(this.axesPlot.source))});const coordsDisplay=dom.SPAN({"class":"coords"});this.menu=dom.DIV({"class":"menu"},[coordsDisplay,"hold shift to pan and zoom :: ",resetButton," :: ",saveButton]);this.axesPlot=new AxesPlot(size,figure,projection);this.node=dom.DIV({"class":"plot"},[this.menu,this.axesPlot.node]);const shapePlot=this.axesPlot.shapePlot;shapePlot.node.addEventListener("mousemove",e=>{const coords=shapePlot.getCoords(e.clientX,e.clientY);dom.replaceChildren(coordsDisplay,[coords.map(_=>(0,_tools.n2s)(_,2)).join(", ")])});shapePlot.node.addEventListener("wheel",e=>{if(e.shiftKey){this.projection=this.projection.zoom(e.deltaY>0?1.12:1/1.12);e.preventDefault()}});let panningState=null;shapePlot.node.addEventListener("mouseleave",()=>{dom.removeChildren(coordsDisplay);if(panningState!=null){panningState=null;dom.setCursor("auto")}});shapePlot.node.addEventListener("mousedown",e=>{if(e.buttons==1&&e.shiftKey){panningState=shapePlot.getCoords(e.clientX,e.clientY);e.preventDefault();dom.setCursor("grabbing")}});shapePlot.node.addEventListener("mouseup",e=>{if(panningState!=null&&e.target!=shapePlot.node){this.projection=this.projection.translate(panningState,shapePlot.getCoords(e.clientX,e.clientY));panningState=null;dom.setCursor("auto");e.stopPropagation()}});shapePlot.node.addEventListener("click",e=>{if(panningState!=null){this.projection=this.projection.translate(panningState,shapePlot.getCoords(e.clientX,e.clientY));panningState=null;dom.setCursor("auto");e.stopPropagation()}})}get size(){return this.axesPlot.size}set size(size){this.axesPlot.size=size}get projection(){return this.axesPlot.projection}set projection(projection){this.axesPlot.projection=projection}set referenceProjection(projection){this._referenceProjection=projection}get figure(){return this.axesPlot.figure}addMenuElement(node){dom.appendChildren(this.menu,[" :: ",node])}}exports.InteractivePlot=InteractivePlot;class AxesPlot{constructor(size,figure,projection){this.ticks=dom.createSVG("g",{"stroke":"#000","stroke-width":"1"});this.tickLabels=dom.createSVG("g",{"font-family":"DejaVu Sans, sans-serif","font-size":"8pt"});this.shapePlot=new ShapePlot(size,figure,projection);this.shapePlot.node.setAttribute("x","5");this.shapePlot.node.setAttribute("y","5");this.node=dom.createSVG("svg",{xmlns:dom.SVGNS},[this.tickLabels,this.shapePlot.node,this.ticks]);this.draw()}get size(){return this.shapePlot.size}set size(size){this.shapePlot.size=size;this.draw()}get figure(){return this.shapePlot.figure}get projection(){return this.shapePlot.projection}set projection(projection){this.shapePlot.projection=projection;this.draw()}get source(){return this.node.outerHTML}draw(){let[sizeX,sizeY]=this.size;this.node.setAttribute("width",String(sizeX+45));this.node.setAttribute("height",String(sizeY+25));const ticks=[];const labels=[];for(let tick of this.projection.getXTicks(Math.ceil(sizeX/43))){let x=5+tick[0]*sizeX;ticks.push(this._createTickLine(x,x,sizeY+1,sizeY+4.5));labels.push(this._createTickLabel(x,sizeY+20,"middle",tick[1]))}for(let tick of this.projection.getYTicks(Math.ceil(sizeY/30))){let y=(1-tick[0])*sizeY+5;ticks.push(this._createTickLine(sizeX+1,sizeX+4.5,y,y));labels.push(this._createTickLabel(12+sizeX,y+4,"start",tick[1]))}dom.replaceChildren(this.ticks,ticks);dom.replaceChildren(this.tickLabels,labels)}_createTickLine(x1,x2,y1,y2){return dom.createSVG("line",{"x1":toStr(x1),"y1":toStr(y1),"x2":toStr(x2),"y2":toStr(y2)})}_createTickLabel(x,y,anchor,label){return dom.createSVG("text",{"x":toStr(x),"y":toStr(y),"text-anchor":anchor},[label])}}exports.AxesPlot=AxesPlot;class ShapePlot{constructor(size,figure,projection,drawBorder){this._projection=projection;this.figure=figure;this.figure.attach(e=>{if(e!=null&&e.event=="newLayer"){let group=new ShapeGroup(this,e.layer);this.groups.push(group)}this.draw()});this.groups=[];for(let layer of figure.layers){this.groups.push(new ShapeGroup(this,layer))}this._background=dom.createSVG("rect",{x:"0",y:"0",width:"0",height:"0",stroke:"none",fill:"#FFFFFF"});this._drawBorder=drawBorder==null||drawBorder;this._border=dom.createSVG("rect",{x:"0.5",y:"0.5",width:"0",height:"0",stroke:"#000000","stroke-width":"1",fill:"none"});this.node=dom.createSVG("svg",{xmlns:dom.SVGNS});this.size=size}get size(){return[this._sizeX,this._sizeY]}set size(size){this._sizeX=size[0];this._sizeY=size[1];this.node.setAttribute("width",String(this._sizeX));this.node.setAttribute("height",String(this._sizeY));this._background.setAttribute("width",String(this._sizeX));this._background.setAttribute("height",String(this._sizeY));this._border.setAttribute("width",String(this._sizeX-1));this._border.setAttribute("height",String(this._sizeY-1));this.draw()}get projection(){return this._projection}set projection(projection){this._projection=projection;this.draw()}getCoords(clientX,clientY){let rect=this.node.getBoundingClientRect();let x=Math.floor(clientX-rect.left)/(rect.width-1)*rect.width;let y=Math.floor(clientY-rect.top)/(rect.height-1)*rect.height;return this.projection.bwd(this.scaleBwd([x,y]))}scaleFwd(coords){let[x,y]=coords;return[x*this._sizeX,(1-y)*this._sizeY]}scaleBwd(coords){let x=coords[0]/this._sizeX;let y=1-coords[1]/this._sizeY;return[x,y]}project(shape){return this.projection.project(shape)}draw(){const children=[this._background];for(let group of this.groups){children.push(group.node);group.draw()}if(this._drawBorder){children.push(this._border)}dom.replaceChildren(this.node,children)}}exports.ShapePlot=ShapePlot;class ShapeGroup{constructor(shapePlot,layer){this.shapePlot=shapePlot;this.layer=layer;this.layer.attach(()=>this.draw());this.node=dom.createSVG("g",this.layer.style)}draw(){const children=[];for(let shape of this.layer.shapes){const primitives=this.shapePlot.project(shape);const shapeStyle=shape.style==null?{}:shape.style;const events=shape.events==null?{}:shape.events;for(let primitive of primitives){const style=_tools.obj.merge(primitive.style==null?{}:primitive.style,shapeStyle);if(primitive.kind==="polygon"){let node=dom.createSVG("polygon",{points:primitive.points.map(point=>{return this.fwd(point).map(toStr).join(",")}).join(" ")});dom.setAttributes(node,style);dom.addEventListeners(node,events);children.push(node)}else if(primitive.kind==="label"){let xy=this.fwd(primitive.coords);let node=dom.snLabel.toSVG(primitive.text);node.setAttribute("x",toStr(xy[0]));node.setAttribute("y",toStr(xy[1]));dom.setAttributes(node,style);dom.addEventListeners(node,events);children.push(node)}else if(primitive.kind==="marker"){const[x,y]=this.fwd(primitive.coords);const node=dom.createSVG("circle",{cx:toStr(x),cy:toStr(y),r:toStr(primitive.size)});dom.setAttributes(node,style);dom.addEventListeners(node,events);children.push(node)}else if(primitive.kind==="arrow"){let[x1,y1]=this.fwd(primitive.origin);let[x2,y2]=this.fwd(primitive.target);if(linalg.areClose(primitive.origin,primitive.target)){const node=dom.createSVG("circle",{cx:toStr(x1),cy:toStr(y1),r:"3"});dom.setAttributes(node,style);dom.addEventListeners(node,events);children.push(node)}else{let nvec=[x2-x1,y2-y1];let norm=linalg.norm2(nvec);nvec=[nvec[0]/norm,nvec[1]/norm];if(primitive.deltaO!=null){const[dxO,dyO]=primitive.deltaO;x1+=dxO*nvec[0]-dyO*nvec[1];y1+=dxO*nvec[1]+dyO*nvec[0]}if(primitive.deltaT!=null){const[dxT,dyT]=primitive.deltaT;x2+=dxT*nvec[0]-dyT*nvec[1];y2+=dxT*nvec[1]+dyT*nvec[0]}const line=dom.createSVG("line",{x1:toStr(x1),y1:toStr(y1),x2:toStr(x2),y2:toStr(y2)});const scale=6/Math.sqrt(2);const l=[x2-(nvec[0]-nvec[1])*scale,y2-(nvec[0]+nvec[1])*scale];const r=[x2-(nvec[0]+nvec[1])*scale,y2-(nvec[1]-nvec[0])*scale];const triangle=dom.createSVG("polygon",{points:[[x2,y2],l,r].map(p=>p.map(toStr).join(",")).join(" ")});dom.setAttributes(line,style);dom.addEventListeners(line,events);dom.setAttributes(triangle,style);dom.addEventListeners(triangle,events);children.push(line,triangle)}}else if(primitive.kind==="loop"){const[x,y]=this.fwd(primitive.coords);const line=dom.createSVG("path",{d:"M -6,-20 C -18,-35 -6,-40 0,-40 C 6,-40 18,-35 7,-22",fill:"none",transform:"translate("+toStr(x)+" "+toStr(y)+") rotate("+toStr(primitive.angle)+")"});const triangle=dom.createSVG("polygon",{points:"4.95,-26.63 12.63,-23.05 7,-21",transform:"translate("+toStr(x)+" "+toStr(y)+") rotate("+toStr(primitive.angle)+")"});dom.setAttributes(line,style);line.setAttribute("fill","none");dom.addEventListeners(line,events);dom.setAttributes(triangle,style);dom.addEventListeners(triangle,events);children.push(line,triangle)}else if(primitive.kind==="__label"){const[x1,y1]=this.fwd(primitive.p1);const[x2,y2]=this.fwd(primitive.p2);const nvec=[x2-x1,y2-y1];const scale=-primitive.offset/linalg.norm2(nvec);const x=0.5*(x1+x2)+nvec[1]*scale;const y=0.5*(y1+y2)-nvec[0]*scale;const angle=180*Math.atan2(nvec[1],nvec[0])/Math.PI;let textAnchor="middle";if(angle>15&&angle<165)textAnchor="start";if(angle<-15&&angle>-165)textAnchor="end";const text=dom.createSVG("text",{"x":toStr(x),"y":toStr(y),"text-anchor":textAnchor,"transform":"rotate("+0+" "+toStr(x)+" "+toStr(y)+")"},[primitive.text]);dom.setAttributes(text,style);dom.addEventListeners(text,events);children.push(text)}else{throw new Error("unknown primitive kind '"+primitive.kind+"'")}}}dom.replaceChildren(this.node,children)}fwd(coords){return this.shapePlot.scaleFwd(coords)}}

},{"./dom.js":1,"./linalg.js":4,"./tools.js":7}]},{},[6]);
