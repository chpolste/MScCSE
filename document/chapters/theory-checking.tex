Model checking is a formal technique for the automatic verification of a system model with respect to a given specification \cite[authoryears][Baier2008].
Its general field of application is the verification of soft- and hardware systems with respect to specifications, typically formulated in a temporal logic.
Specifications may concern qualitative (e.g.\ \quotation{can something bad happen?}) or quantitative (e.g.\ \quotation{can something bad happen with more than 20\% probability in the first hour of operation?}) questions about the system.

The process of model checking starts with the construction of a system model.
A system under consideration has to be transformed into an finite and unambiguous representation which reproduces all essential behaviour and provides the information required to verify the specification.
The model checker will then explore this system representation exhaustively by brute-force, considering every possible state of the system model and looking for counterexamples that violate the specification.
This approach ensures that no malicious behaviour of the system is missed and the produced counterexamples can be used to guide the search for system or system model errors \cite[alternative=authoryears,left={(e.g.\ }][Clarke2000].
However, the exhaustive approach also often means that substantial resources are required to carry out the verification.
Systems with rich behaviour require complex models for accurate representation, leading to a large number of possible states that need to be checked by the procedure.
Dealing with this so-called state-space explosion is a major challenge when designing a model checking procedure.
While the continuous increase in available computing power allows for the verification of increasingly complex systems, techniques such as partial order reduction and abstraction refinement are available to combat the state-space explosion problem \cite[authoryears][Baier2008].

