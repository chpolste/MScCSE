To decide desired properties, game needs to be analysed twice:
once with adversarial player 2 (to yield winning states where even in the "worst case", game can be won by player 1) and once with cooperative player 2 (to yield states where winning is possible, but not guaranteed).
From membership in these 2 solution sets, it can be decided if states are satisfying, non-satisfying or if the abstraction is too coarse to decide and further refinement is necessary.


\startbuffer[buf:abstraction-analysis-solution-algorithm]
    \startalgorithmic[numbering=no,margin=0em]
        \INPUT{$\Pre^{\mathrm set}_1$, $\Pre^{\mathrm set}_2$, $\Pre^{\mathrm set}_3$ of game $\ProductGame = ( P_1, P_2, Act, \Transition, \Tuple{E}{F} )$}
        \OUTPUT{$\AlmostSure^{\mathrm set}(\ProductGame)$} % TODO coop or adv
    \stopalgorithmic
    \startalgorithmic
        \STATE{ $P \leftarrow P_1 \cup P_2$ }
        \STATE{ $D \leftarrow P \setminus (E \cup F)$ }
        \STATE{ $X, {\bar X}, Y, {\bar Y}, Z, {\bar Z}$: Set}
        \STATE{ ${\bar X} \leftarrow P$ }
        \STATE{ ${\bar Y} \leftarrow P$ }
        \STATE{ ${\bar Z} \leftarrow \emptyset$ }
        \DO
            \STATE{ $X \leftarrow {\bar X}$ }
            \DO
                \STATE{ $Y \leftarrow {\bar Y}$ }
                \DO
                    \STATE{ $Z \leftarrow {\bar Z}$ }
                    \STATE{ ${\bar Z} \leftarrow (F \cap \Pre_1(X)) \cup (E \cap \Pre_2(X, Y)) \cup (D \cap \Pre_3(X, Y, Z))$ }
                \ENDDOWHILE{ $Z \ne {\bar Z}$ }
                \STATE{ ${\bar Y} \leftarrow Z$ }
                \STATE{ ${\bar Z} \leftarrow P$ }
            \ENDDOWHILE{ $Y \ne {\bar Y}$ }
            \STATE{ ${\bar X} \leftarrow Y$ }
            \STATE{ $Y \leftarrow \emptyset$ }
        \ENDDOWHILE{ $X \ne {\bar X}$ }
        \RETURN{$X$}
    \stopalgorithmic
\stopbuffer

\startsubsection[title={Product Game Solution},reference=sec:abstraction-analysis-solution]

    Analysis in both adversarial and cooperative settings achievable with same algorithm.
    A quadratic-complexity algorithm exists, but a cubic, fixed-point algorithm is much easier to implement and therefore used here.
    The correctness of the algorithm follows from \cite[TODO].

    Based on the successor operator

    \startformula
        \Successor{s}{a} = \Support{\Transition(s, a)} \EndComma
    \stopformula

    two conditions

    \startformula
        \startalign[n=2,align={right,left}]
            \NC C_1(X) =
            \NC \Set{ (s, a) \mid \Successor{s}{a} \subseteq X } \EndAnd
            \NR
            \NC C_2(X, Y) =
            \NC \Set{ (s, a) \mid \Successor{s}{a} \subseteq X \MidAnd \Successor{s}{a} \cap Y \ne \emptyset }
            \NR
        \stopalign
    \stopformula

    for state-action pairs of the product game graph are defined.  
    Using these conditions, two sets of predecessor operators are defined, one for the adversarial setting

    \startformula
        \startalign[n=2,align={right,left}]
            \NC \Pre_1^{\Adversarial}(X) =
            \NC \Set{ s \in P_1 \mid \exists a \in Act : (s, a) \in C_1(X) }
            \NR
            \NC \empty
            \NC \quad \cup \Set{ s \in P_2 \mid \forall a \in \Act : (s, a) \in C_1(X) } \EndComma
            \NR
            \NC \Pre_2^{\Adversarial}(X, Y) =
            \NC \Set{ s \in P_1 \mid \exists a \in Act : (s, a) \in C_2(X, Y) }
            \NR
            \NC \empty
            \NC \quad \cup \Set{ s \in P_2 \mid \forall a \in \Act : (s, a) \in C_2(X, Y) } \EndComma
            \NR
            \NC \Pre_3^{\Adversarial}(X, Y, Z) =
            \NC \Set{ s \in P_1 \mid \exists a \in Act : (s, a) \in C_2(X, Y) \cup C_1(Z) }
            \NR
            \NC \empty
            \NC \quad \cup \Set{ s \in P_2 \mid \forall a \in Act : (s, a) \in C_2(X, Y) \cup C_1(Z) }
            \NR
        \stopalign
    \stopformula

    and for the cooperative setting

    \startformula
        \startalign[n=2,align={right,left}]
            \NC \Pre_1^{\Cooperative}(X) =
            \NC \Set{ s \in P_1 \cup P_2 \mid \exists a \in Act : (s, a) \in C_1(X) } \EndComma
            \NR
            \NC \Pre_2^{\Cooperative}(X, Y) =
            \NC \Set{ s \in P_1 \cup P_2 \mid \exists a \in Act : (s, a) \in C_2(X, Y) } \EndComma
            \NR
            \NC \Pre_3^{\Cooperative}(X, Y, Z) =
            \NC \Set{ s \in P_1 \cup P_2 \mid \exists a \in Act : (s, a) \in C_2(X, Y) \cup C_1(Z) } \EndPeriod
            \NR
        \stopalign
    \stopformula

    \placealgorithm[top][alg:abstraction-analysis-solver]{
        Solver for the product game $\ProductGame$ with one-pair Streett acceptance condition $\Condition = \Tuple{E}{F}$ in either an adversarial (${\mathrm set} = \Adversarial$) or cooperative (${\mathrm set} = \Cooperative$) setting.
        The required $\Pre$-operators are defined in section \in[sec:abstraction-analysis-solution].
        The procedure is based on a fixed-point iteration solver for parity-3 games \cite[authoryears][Svorenova2017].
    }{
        % https://mailman.ntg.nl/pipermail/ntg-context/2016/087390.html
        \startframedtext[width=\textwidth,frame=off]
            \getbuffer[buf:abstraction-analysis-solution-algorithm]
        \stopframedtext
    }

    Substituting either set of these operators into Algorithm \in[alg:abstraction-analysis-solver] for $\Pre_1$, $\Pre_2$ and $\Pre_3$ results in procedures to compute sets $\Almost{\ProductGame}$ and $\AlmostCoop{\ProductGame}$.
    Based on these solutions to the game, the sets

    \startformula
        \startalign[n=2,align={right,left}]
            \NC P_\Yes =
            \NC P_1 \cap \Almost{\ProductGame} \EndComma
            \NR
            \NC P_\No =
            \NC P_1 \setminus \AlmostCoop{\ProductGame} \EndAnd
            \NR
            \NC P_\Maybe =
            \NC P_1 \setminus ( P_\Yes \cup P_\No )
            \NR
        \stopalign
    \stopformula

    are defined.
    For any play starting in a state from $P_\Yes$ player 1 has an almost-sure winning, finite-memory strategy even if player 2 plays adversarily.
    No such strategy exists when a play is initiated from a state in $P_\No$, even if player 2 plays cooperatively.
    For states in $P_\Maybe$ one cannot determine if an almost-sure winning strategy exists due to the abstraction being too coarse.

    Let

    \startformula
        \startalign[n=2,align={right,left}]
            \NC \YesStates{q} =
            \NC \Set{ \State{i} \mid \Tuple{\State{i}}{q} \in P_\Yes } \EndComma
            \NR
            \NC \NoStates{q} =
            \NC \Set{ \State{i} \mid \Tuple{\State{i}}{q} \in P_\No } \EndAnd
            \NR
            \NC \MaybeStates{q} =
            \NC \Set{ \State{i} \mid \Tuple{\State{i}}{q} \in P_\Maybe }
            \NR
        \stopalign
    \stopformula

    for all $q \in Q$.
    Their notation is overloaded such that they denote the union of their member polytopes in geometric contexts, analogous to the use of sets of state space partition elements as arguments of the dynamics operators.

\stopsubsection


\startsubsection[title={Correctness and Termination}]

    Results due to \cite[Svorenova2017].
    Partial solution in every iteration: sequence of yes and no sets fulfils subset relation.
    Soundness: $\YesStates{q_0}$ is always subset of $\InitialStates$ and $\NoStates{q_0}$ is always subset of $\StateSpace \setminus \InitialStates$.
    Partial correctness: If the algorithm terminates (set of maybe-states is empty), then solution is found by last iteration.

    Two examples for non-termination given.
    First, consider LSS

    \startformula
        \VecState_{t+1} = \VecState_t + \VecControl_t + \VecRandom_t
    \stopformula

    where $\VecState_t \in \ClosedInterval{0}{3}$, $\VecControl_t \in \ClosedInterval{-1.5}{1.5}$ and $\VecRandom_t \in \ClosedInterval{-0.5}{0.5}$ for all times $t$.
    A reachability objective with target region $\ClosedInterval{1}{2}$ can be fulfilled by every $\VecState \in \ClosedInterval{0}{3}$ with control input $\VecControl = 1.5 - \VecState$.
    However, this control input is the only control input that leads to satisfaction almost-surely and it is different for every state of the state space.
    Therefore, a solution cannot be found as a finite partition of the state space.

    But even if finite state space partition does exist, the algorithm may still not terminate in practice.
    To see this, consider the LSS

    \startformula
        \VecState_{t+1} = 1.5 \VecState_t + \VecControl_t + \VecRandom_t
    \stopformula

    where $\VecState_t \in \ClosedInterval{-2}{2}$, $\VecControl_t \in \ClosedInterval{-2}{2}$ and $\VecRandom_t \in \ClosedInterval{-1}{1}$ for all times $t$.
    Objective: general safety, don't leave the state space at any time.
    Propose a partitioning into polytopes $\State{1} = \ClosedInterval{-2}{-1}$, $\State{2} = \ClosedInterval{-1}{0}$, $\State{3} = \ClosedInterval{0}{1}$ and $\State{4} = \ClosedInterval{1}{2}$.
    Interval arithmetic shows that choosing control inputs $2$ for $\State{1}$, $1$ for $\State{2}$, $-1$ for $\State{3}$ and $-2$ for $\State{4}$ keeps traces starting from any state in the state space safe:

    \startformula
        \startalign[n=4,align={right,right,left,left}]
            \NC \State{1}:
            \NC 1.5 \cdot \ClosedInterval{-2}{1} + 2 + \ClosedInterval{-1}{1}
            \NC = \ClosedInterval{-2}{1.5}
            \NC \subseteq \StateSpace
            \NR
            \NC \State{2}:
            \NC 1.5 \cdot \ClosedInterval{-1}{0} + 1 + \ClosedInterval{-1}{1}
            \NC = \ClosedInterval{-1.5}{2}
            \NC \subseteq \StateSpace
            \NR
            \NC \State{3}:
            \NC 1.5 \cdot \ClosedInterval{0}{1} - 1 + \ClosedInterval{-1}{1}
            \NC = \ClosedInterval{-2}{1.5}
            \NC \subseteq \StateSpace
            \NR
            \NC \State{4}:
            \NC 1.5 \cdot \ClosedInterval{1}{2} - 2 + \ClosedInterval{-1}{1}
            \NC = \ClosedInterval{-1.5}{2}
            \NC \subseteq \StateSpace \EndPeriod
            \NR
        \stopalign
    \stopformula

    However, it was assumed in section \in[sec:TODO], that any non-empty polytope must be full-dimensional.
    The concrete action operator from which the player 1 actions in the abstraction are derived returns a polytopic regions which means it cannot work with single-member sets.
    For a small $\delta \ge 0$, consider a trace in state $\VecState_t = -2 + \frac{2}{3} \delta$.
    Setting up the condition for safe continuation of the trace, one obtains

    \startformula
        \startalign[n=3,align={middle,right,left}]
            \NC \empty
            \NC 1.5 \Big({-2} + \frac{2}{3} \delta\Big) + \VecControl_t + \ClosedInterval{-1}{1}
            \NC \subseteq \ClosedInterval{-2}{2}
            \NR
            \NC \Leftrightarrow \quad
            \NC \ClosedInterval{-4 + \delta + \VecControl_t}{-2 + \delta + \VecControl_t}
            \NC \subseteq \ClosedInterval{-2}{2}
            \NR
            \NC \Rightarrow \quad
            \NC \VecControl_t
            \NC \ge 2 - \delta
            \NR
        \stopalign
    \stopformula

    from the lower interval bound.
    Because any control region selectable by player 1 in the abstraction must contain an interval of diameter $\epsilon > 0$ or else it is considered to be empty, the system can never be fully decided in the abstraction.
    Any $\VecState = -2 + \frac{2}{3} \delta$ requires a control input region with a diameter of $\epsilon > \delta$, meaning all any state $\VecState \lt{} -2 + \frac{2}{3} \epsilon$ cannot be decided in the restrictions of the abstraction.

\stopsubsection


\startsubsection[title={Product Game Simplification}]

    Reminder of how to include co-safe switch into game creation.

    Now: If partial results are already available stop construction once decided state is reached.
    Possible because of guarantee that any state that can be decided by the analysis is correctly analysed (partial solution) and will never change, even if other parts of the state space partition are refined.
    Because game construction and analysis is expensive, use of partial solutions to simplify the game can reduce run time of the procedure substantially.

    Discuss problems with product game simplification and the available compromise.
    Because already decided states are immediately redirected into the $\SatEnd$ loop, some of their successors are constructed in the product game.
    While results from decided states can be transfered to such states from the previous analysis, for previously undecided states that are not constructed anymore it cannot generally be decided if they should remain undecided or are actually unreachable now.
    A subset of the full product game is omitted when the simplification is applied, which does not affect the validity of the analysis especially because the initial states, which are of most interest, are always constructed.
    However, as seen in the next section this might restrict the controller synthesis process, which relies on analysis results of all states, not just the initial ones.

\stopsubsection

