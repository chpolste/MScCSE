(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.PreRLayeredTransitionController=exports.RoundRobinController=exports.RandomController=exports.Controller=exports.Trace=void 0;var _geometry=require("./geometry.js");var _tools=require("./tools.js");class Trace{constructor(system,objective){this.steps=[];this.system=system;this.objective=objective}serialize(){return this.steps.map(_=>({xOrigin:[_.xOrigin[0],_.xOrigin[1].label,_.xOrigin[2].label],xTarget:[_.xTarget[0],_.xTarget[1].label,_.xTarget[2].label],u:_.u,w:_.w}))}step(controller,origin,x,q){if(x==null){x=this.system.stateOf(origin);if(x==null)return null}else if(!x.polytope.contains(origin)){throw new Error("The origin ["+origin.join(", ")+"] is not consistent with the given state "+x.label)}if(x.isOuter)return null;if(q==null)q=this.objective.automaton.initialState;if(this.objective.isCoSafeFinal(q.label))return null;const qNext=q.successor(this.objective.valuationFor(x.predicates));if(qNext==null)return null;const u=controller.control(origin,x,q);const w=this.system.lss.ww.sample();const target=this.system.lss.eval(origin,u,w);const xNext=(0,_tools.just)(this.system.stateOf(target),"Non-outer state "+x.label+" has successor outside of system");const step={xOrigin:[origin,x,q],xTarget:[target,xNext,qNext],u:u,w:w};this.steps.push(step);return step}stepFor(n,controller,origin,x,q){let xOrigin=[origin,x,q];for(let i=0;i<n;i++){const step=this.step(controller,...xOrigin);if(step==null)return;xOrigin=step.xTarget}}}exports.Trace=Trace;class Controller{constructor(system,objective,results){this.system=system;this.objective=objective;this.results=results;this.reset()}reset(){}control(origin,x,q){throw new _tools.NotImplementedError("control method of Controller must be overwritten in subclass")}}exports.Controller=Controller;class RandomController extends Controller{control(origin,x,q){return this.system.lss.uu.sample()}}exports.RandomController=RandomController;class RoundRobinController extends Controller{reset(){this._lastActions=new Map}_getActionID(x,q){const qMap=this._lastActions.get(x);if(qMap==null)return-1;const i=qMap.get(q);return i==null?-1:i}_setActionID(x,q,i){const qMap=this._lastActions.get(x);if(qMap==null){this._lastActions.set(x,new Map([[q,i]]))}else{qMap.set(q,i)}}_isYes(x,q){const results=this.results;if(results==null)return false;const result=results.get(x.label);return result!=null&&result.yes.has(q.label)}control(origin,x,q){const actions=x.actions;const n=actions.length;if(n===0)throw new Error("Cannot compute control for state "+x.label+" without actions");const qNext=(0,_tools.just)(q.successor(this.objective.valuationFor(x.predicates)),"Cannot compute control for state ("+x.label+", "+q.label+") without a transition");const last=this._getActionID(x,q);for(let i=1;i<=n;i++){const next=(last+i)%n;const action=actions[next];const allYes=_tools.iter.every(_tools.iter.map(target=>this._isYes(target,qNext),action.targets));if(allYes){this._setActionID(x,q,next);return action.controls.sample()}}const next=(last+1)%n;this._setActionID(x,q,next);return actions[next].controls.sample()}}exports.RoundRobinController=RoundRobinController;class PreRLayeredTransitionController extends Controller{constructor(system,objective,results,transitions){super(system,objective,results);const lss=system.lss;const onions=new Map;for(let[qOrigin,qTarget]of transitions){const reach=this._getTransitionRegion(qOrigin,qTarget);const avoid=this._getUnsafeRegion(qOrigin);const onion=[reach.remove(avoid)];while(true){const previous=onion[onion.length-1];const preR=lss.preR(lss.xx,lss.uu,previous).remove(avoid);if(previous.covers(preR)){break}else{onion.push(preR)}}onions.set(qOrigin,onion)}this._onions=onions;this._controls=new Map}_getUnsafeRegion(q){const results=(0,_tools.just)(this.results,"PreRLayeredTransitionController requires analysed system");return _geometry.Union.from(Array.from(_tools.iter.filter(x=>!x.isOuter&&(0,_tools.just)(results.get(x.label)).no.has(q),this.system.states.values()),x=>x.polytope),this.system.lss.dim)}_getTransitionRegion(qOrigin,qTarget){const qNext=x=>this.objective.nextState(x.predicates,qOrigin);return _geometry.Union.from(Array.from(_tools.iter.filter(x=>!x.isOuter&&qNext(x)===qTarget,this.system.states.values()),x=>x.polytope),this.system.lss.dim)}control(origin,x,q){let controls=this._controls.get(x);if(controls!=null){const control=controls.get(q.label);if(control!=null){return control.sample()}}else{controls=new Map;this._controls.set(x,controls)}const onion=(0,_tools.just)(this._onions.get(q.label),"No layers are specified for "+q.label);const act=_tools.iter.argmax(action=>{let cost=0;let post=this.system.lss.post(x.polytope,action.controls);const totalVolume=post.volume;let i=0;for(let layer of onion){cost=cost+post.intersect(layer).volume*i;post=post.remove(layer);i++}cost=cost+post.volume*9999;return-cost/totalVolume},x.actions);const u=(0,_tools.just)(act,"No action found for state ("+x.label+", "+q.label+")").controls.polytopes[0];controls.set(q.label,u);return u.sample()}}exports.PreRLayeredTransitionController=PreRLayeredTransitionController;

},{"./geometry.js":3,"./tools.js":11}],2:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.TwoPlayerProbabilisticGame=exports.AnalysisResults=exports.ValidationError=exports.MappedJSONGameGraph=void 0;var _logic=require("./logic.js");var _tools=require("./tools.js");class MappedJSONGameGraph{constructor(json){this._states=json;this.stateLabels=new Set;for(let label in this._states){this.stateLabels.add(label)}}predicateLabelsOf(label){return new Set(this._states[label].predicates)}actionCountOf(label){return this._states[label].actions.length}supportCountOf(label,actionId){return this._states[label].actions[actionId].length}targetLabelsOf(label,actionId,supportId){return new Set(this._states[label].actions[actionId][supportId])}}exports.MappedJSONGameGraph=MappedJSONGameGraph;const DEFAULT_PRIORITY=2;class ValidationError extends Error{}exports.ValidationError=ValidationError;class AnalysisResults extends Map{static deserialize(json){const results=new AnalysisResults;for(let label in json){const result=json[label];results.set(label,{yes:new Set(result.yes),no:new Set(result.no),maybe:new Set(result.maybe)})}return results}serialize(){const json={};for(let[label,result]of this){json[label]={yes:Array.from(result.yes),no:Array.from(result.no),maybe:Array.from(result.maybe)}}return json}transferFromPrevious(results){for(let[state,oldResult]of results){const newResult=this.get(state);if(newResult==null)continue;for(let q of oldResult.yes){if(newResult.no.has(q)||newResult.maybe.has(q))throw new Error("State ("+state+", "+q+") changed its analysis result illegally (was satisfying)");newResult.yes.add(q)}for(let q of oldResult.no){if(newResult.yes.has(q)||newResult.maybe.has(q))throw new Error("State ("+state+", "+q+") changed its analysis result illegally (was non-satisfying)");newResult.no.add(q)}}}updated(results){const updated=new Set;if(results==null){for(let state of this.keys())updated.add(state)}else{for(let[state,newResult]of this){const oldResult=results.get(state);if(oldResult==null||!_tools.sets.areEqual(oldResult.yes,newResult.yes)||!_tools.sets.areEqual(oldResult.no,newResult.no)||!_tools.sets.areEqual(oldResult.maybe,newResult.maybe)){updated.add(state)}}}return updated}remap(refinementMap){for(let[xOld,xNews]of refinementMap){const result=(0,_tools.just)(this.get(xOld.label),"Remapping analysis results failed: state '"+xOld.label+"' does not exists");this.delete(xOld.label);for(let xNew of xNews){this.set(xNew.label,result)}}}}exports.AnalysisResults=AnalysisResults;class TwoPlayerProbabilisticGame{constructor(coSafeInterpretation){this.p1States=new _tools.UniqueCollection(P1State.hash,P1State.areEqual);this.p2States=new _tools.UniqueCollection(P2State.hash,P2State.areEqual);this.initialStates=new Set;this.priorityStates=[new Set,new Set,new Set];this.coSafeInterpretation=coSafeInterpretation!=null&&coSafeInterpretation}get states(){return _tools.iter.chain(this.p1States,this.p2States)}takeP1State(systemState,automatonState){return this.p1States.take(new P1State(systemState,automatonState))}takeP2State(systemState,systemAction,automatonState){return this.p2States.take(new P2State(systemState,systemAction,automatonState))}setPriority(state,priority){this.priorityStates[0].delete(state);this.priorityStates[1].delete(state);this.priorityStates[2].delete(state);this.priorityStates[priority].add(state)}validate(){const[p0,p1,p2]=this.priorityStates;if(_tools.sets.doIntersect(p0,p1))throw new ValidationError("At least one state has two priorities assigned (0 and 1)");if(_tools.sets.doIntersect(p0,p2))throw new ValidationError("At least one state has two priorities assigned (0 and 2)");if(_tools.sets.doIntersect(p1,p2))throw new ValidationError("At least one state has two priorities assigned (1 and 2)");if(p0.size+p1.size+p2.size!==_tools.iter.count(this.states))throw new ValidationError("At least one states does not have a priority assigned");for(let state of this.states){if(state instanceof P1State&&state.actions.length===0)throw new ValidationError("Player 1 state ("+state.systemState+", "+state.automatonState+") has no actions");if(state instanceof P2State&&state.actions.length===0)throw new ValidationError("Player 2 state (("+state.systemState+", "+state.systemAction+"), "+state.automatonState+") has no actions")}for(let state of this.initialStates){if(state instanceof P2State)throw new ValidationError("Player 2 intitial state (("+state.systemState+", "+state.systemAction+"), "+state.automatonState+") is not not allowed");if(!this.p1States.has(state))throw new ValidationError("State ("+state.systemState+", "+state.automatonState+") is an initial state but not part of the game")}}solve(){return this._solve(pre1,pre2,pre3)}solveCoop(){return this._solve(pre1Coop,pre2Coop,pre3Coop)}_solve(pre1,pre2,pre3){let oldX,oldY,oldZ;let newX=new Set(this.states);let newY=new Set;let newZ=new Set(this.states);do{oldX=new Set(newX);do{oldY=new Set(newY);do{oldZ=new Set(newZ);newZ=_tools.sets.union(pre1(this.priorityStates[0],oldX),pre2(this.priorityStates[1],oldX,oldY),pre3(this.priorityStates[2],oldZ,oldX,oldY))}while(!_tools.sets.areEqual(oldZ,newZ));newY=new Set(oldZ);newZ=new Set(this.states)}while(!_tools.sets.areEqual(oldY,newY));newX=new Set(oldY);newY=new Set}while(!_tools.sets.areEqual(oldX,newX));return oldX}analyse(){const win=this.solve();const winCoop=this.solveCoop();if(!_tools.sets.isSubset(win,winCoop))throw new Error("states "+Array.from(_tools.sets.difference(win,winCoop)).join(", ")+" have a winning stategy but cannot be won cooperatively (contradiction)");const qSat=new Set;if(this.coSafeInterpretation){for(let state of this.priorityStates[0]){if(state.automatonState!=="__SAT__")qSat.add(state.automatonState)}}const results=new AnalysisResults;for(let state of this.initialStates){results.set(state.systemState,{yes:new Set(qSat),no:new Set,maybe:new Set})}for(let state of this.p1States){if(state.systemState==="")continue;const result=(0,_tools.just)(results.get(state.systemState),"result mismatch for state ("+state.systemState+", "+state.automatonState+")");let category=result.no;if(winCoop.has(state))category=result.maybe;if(win.has(state))category=result.yes;category.add(state.automatonState)}return results}static fromProduct(sys,objective,analysis){const priority1=new Set(_tools.iter.map(s=>s.label,objective.automaton.acceptanceSetE));const priority0=new Set(_tools.iter.map(s=>s.label,objective.automaton.acceptanceSetF));const game=new TwoPlayerProbabilisticGame(objective.coSafeInterpretation);const queue=[];const enqueued=new Set;const q0=objective.automaton.initialState;for(let label of sys.stateLabels){const state=game.takeP1State(label,q0.label);queue.push(state);enqueued.add(state);game.initialStates.add(state)}const deadEndP1=game.takeP1State("","__END__");const deadEndP2=game.takeP2State("",0,"__END__");deadEndP1.actions.push(new Set([deadEndP2]));deadEndP2.actions.push(new Set([deadEndP1]));const satEndP1=game.takeP1State("","__SAT__");const satEndP2=game.takeP2State("",0,"__SAT__");satEndP1.actions.push(new Set([satEndP2]));satEndP2.actions.push(new Set([satEndP1]));if(game.coSafeInterpretation){for(let xi of sys.stateLabels){for(let qi of priority0){const state=game.takeP1State(xi,qi);state.actions.push(new Set([satEndP2]))}}}while(queue.length>0){const state=queue.shift();const xi=state.systemState;const qi=state.automatonState;if(state instanceof P1State){const pis=sys.predicateLabelsOf(xi);const qiNext=objective.nextState(pis,qi);const result=analysis==null?null:analysis.get(xi);if(qiNext==null){}else if(game.coSafeInterpretation&&priority0.has(qiNext)){state.actions.push(new Set([satEndP2]))}else if(result!=null&&result.yes.has(qi)){state.actions.push(new Set([satEndP2]))}else if(result!=null&&result.no.has(qi)){state.actions.push(new Set([deadEndP2]))}else{for(let ui=0;ui<sys.actionCountOf(xi);ui++){const action=game.takeP2State(xi,ui,qiNext);state.actions.push(new Set([action]));queue.push(action)}}if(state.actions.length===0){state.actions.push(new Set([deadEndP2]))}}else{const ui=state.systemAction;for(let si=0;si<sys.supportCountOf(xi,ui);si++){const xjs=sys.targetLabelsOf(xi,ui,si);const targets=new Set;for(let xj of xjs){const target=game.takeP1State(xj,qi);if(!enqueued.has(target)){enqueued.add(target);queue.push(target)}targets.add(target)}state.actions.push(targets)}}}for(let state of game.states){game.setPriority(state,2);if(priority1.has(state.automatonState)||state===deadEndP1||state===deadEndP2){game.setPriority(state,1)}if(priority0.has(state.automatonState)||state===satEndP1||state===satEndP2){game.setPriority(state,0)}}game.validate();return game}}exports.TwoPlayerProbabilisticGame=TwoPlayerProbabilisticGame;class P1State{constructor(systemState,automatonState){this.systemState=systemState;this.automatonState=automatonState;this.actions=[]}static hash(x){let hash=7;hash=37*hash+(0,_tools.hashString)(x.systemState)|0;hash=37*hash+(0,_tools.hashString)(x.automatonState)|0;return hash}static areEqual(x,y){return x.systemState===y.systemState&&x.automatonState===y.automatonState}}class P2State{constructor(systemState,systemAction,automatonState){this.systemState=systemState;this.systemAction=systemAction;this.automatonState=automatonState;this.actions=[]}static hash(x){let hash=17;hash=31*hash+(0,_tools.hashString)(x.systemState)|0;hash=31*hash+x.systemAction|0;hash=31*hash+(0,_tools.hashString)(x.automatonState)|0;return hash}static areEqual(x,y){return x.systemState===y.systemState&&x.systemAction===y.systemAction&&x.automatonState===y.automatonState}}function cond1(successors,X){return _tools.sets.isSubset(successors,X)}function cond2(successors,X,Y){return _tools.sets.isSubset(successors,X)&&_tools.sets.doIntersect(successors,Y)}function cond3(successors,Z,X,Y){return cond1(successors,Z)||cond2(successors,X,Y)}function _preTest(cond){return function(state){return state instanceof P1State?_tools.iter.some(state.actions.map(cond)):_tools.iter.every(state.actions.map(cond))}}function pre1(S,X){return new Set(_tools.iter.filter(_preTest(s=>cond1(s,X)),S))}function pre2(S,X,Y){return new Set(_tools.iter.filter(_preTest(s=>cond2(s,X,Y)),S))}function pre3(S,Z,X,Y){return new Set(_tools.iter.filter(_preTest(s=>cond3(s,Z,X,Y)),S))}function _preTestCoop(cond){return function(state){return _tools.iter.some(state.actions.map(cond))}}function pre1Coop(S,X){return new Set(_tools.iter.filter(_preTestCoop(s=>cond1(s,X)),S))}function pre2Coop(S,X,Y){return new Set(_tools.iter.filter(_preTestCoop(s=>cond2(s,X,Y)),S))}function pre3Coop(S,Z,X,Y){return new Set(_tools.iter.filter(_preTestCoop(s=>cond3(s,Z,X,Y)),S))}

},{"./logic.js":6,"./tools.js":11}],3:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.Union=exports.Polygon=exports.Interval=exports.Polytope=exports.Halfspace=exports.TOL=void 0;var linalg=_interopRequireWildcard(require("./linalg.js"));var _tools=require("./tools.js");var _parser=require("./parser.js");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}}newObj.default=obj;return newObj}}const TOL=linalg.TOL;exports.TOL=TOL;function cartesian(...tuples){let cart=[[]];for(let tuple of tuples){cart=[].concat(...cart.map(xs=>tuple.map(y=>xs.concat([y]))))}return cart}function angleOrder(v){const angle=Math.atan2(v[1],v[0]);return angle===Math.PI?angle-2*Math.PI:angle}function angleCCW(g,h){const det=g[0]*h[1]-g[1]*h[0];const dot=g[0]*h[0]+g[1]*h[1];let angle=Math.atan2(det,dot);if(angle<0){angle=angle+2*Math.PI}return angle===2*Math.PI?0:angle}function isCCWTurn(p,q,r,zero){return(p[0]-r[0])*(q[1]-r[1])-(p[1]-r[1])*(q[0]-r[0])>zero}function reduceHullPart(hull,p,zero){while(hull.length>1&&!isCCWTurn(hull[hull.length-2],hull[hull.length-1],p,zero)){hull.pop()}}function halfplaneIntersection(g,h){const[g0,g1]=g.normal;const[h0,h1]=h.normal;const det=g0*h1-g1*h0;if(Math.abs(det)<TOL){return null}else{return[(h1*g.offset-g1*h.offset)/det,(g0*h.offset-h0*g.offset)/det]}}const hsieParse=(0,_parser.ASTParser)(/\+|-|([0-9\.]+\s*\*?\s*[a-z]?)|[0-9\.]+|[a-z]/,[{op:"+",precedence:20,associativity:-1},{op:"-",precedence:20,associativity:-1},{op:"+",precedence:50,associativity:0},{op:"-",precedence:50,associativity:0}]);function hsieSplit(text){const parts=text.split(/\s*([<>]=?)\s*/);if(parts.length!=3)throw new _parser.ParseError("not a valid inequality (requires exactly one of <=, <, >, >=)");return[hsieParse(parts[0]),parts[1][0],hsieParse(parts[2])]}const hsieNumVarPattern=/^((?:\d+(?:\.\d+)?)|(?:\.\d+))?\s*\*?\s*([a-z])?$/;function hsieTerms(node,flip){if(typeof node==="string"){const match=node.match(hsieNumVarPattern);if(match==null)throw new _parser.ParseError("unrecognized term "+node);return[{coefficient:(flip?-1:1)*(match[1]==null?1:parseFloat(match[1])),variable:match[2]==null?"":match[2]}]}else if(node.op==="-"||node.op==="+"){const isMinus=node.op==="-";const isUnary=node.args.length===1;const out=hsieTerms(node.args[0],isUnary&&isMinus?!flip:flip);if(!isUnary)out.push(...hsieTerms(node.args[1],isMinus?!flip:flip));return out}else{throw new _parser.ParseError("unexpected operator "+node.op)}}class Halfspace{constructor(normal,offset){this.normal=normal;this.offset=offset;this.dim=normal.length}static deserialize(json){return new Halfspace(json.normal,json.offset)}static normalized(normal,offset){let norm=linalg.norm2(normal);if(norm<TOL){offset=offset===0?Infinity:Math.sign(offset)*Infinity;norm=1}return new Halfspace(normal.map(x=>x/norm),offset/norm)}static parse(text,variables){const[lhs,comp,rhs]=hsieSplit(text);const terms=hsieTerms(lhs,comp===">").concat(hsieTerms(rhs,comp==="<"));let offset=0;let normal=new Array(variables.length);normal.fill(0);for(let term of terms){if(term.variable===""){offset-=term.coefficient}else{const idx=variables.indexOf(term.variable);if(idx<0)throw new _parser.ParseError("unexpected variable '"+term.variable+"'");normal[idx]+=term.coefficient}}return Halfspace.normalized(normal,offset)}get isInfeasible(){return this.offset===-Infinity}get isTrivial(){return this.offset===Infinity}applyRight(m){return Halfspace.normalized(linalg.applyRight(m,this.normal),this.offset)}contains(point){linalg.assertEqualDims(this.dim,point.length);return linalg.dot(this.normal,point)-this.offset<TOL}flip(){return new Halfspace(this.normal.map(x=>-x),-this.offset)}isSameAs(other){return linalg.areClose(this.normal,other.normal)&&Math.abs(this.offset-other.offset)<TOL}translate(v){return Halfspace.normalized(this.normal,this.offset+linalg.dot(this.normal,v))}serialize(){return{normal:this.normal,offset:this.offset}}}exports.Halfspace=Halfspace;class Polytope{constructor(vertices,halfspaces){if(this.constructor.name==="Polytope"){throw new TypeError("must not instanciate Polytope")}this._vertices=vertices;this._halfspaces=halfspaces;this._isEmpty=null}static deserialize(json){if(json.dim===1)return new Interval(json.vertices,null);if(json.dim===2)return new Polygon(json.vertices,null);throw new _tools.NotImplementedError}static empty(){throw new _tools.NotImplementedError}static hull(ps){throw new _tools.NotImplementedError}static intersection(hs){throw new _tools.NotImplementedError}static noredund(hs){throw new _tools.NotImplementedError}static ofDim(dim){if(dim===1)return Interval;if(dim===2)return Polygon;throw new _tools.NotImplementedError}get boundingBox(){if(this.isEmpty)return this;let bbox=cartesian(...this.extent);return this.constructor.hull(bbox)}get centroid(){throw new _tools.NotImplementedError}get extent(){let mins=new Array(this.dim);mins.fill(Infinity);let maxs=new Array(this.dim);maxs.fill(-Infinity);for(let vertex of this.vertices){vertex.map((x,i)=>{if(x<mins[i]){mins[i]=x}if(x>maxs[i]){maxs[i]=x}})}return _tools.arr.zip2(mins,maxs)}get halfspaces(){if(this._halfspaces!=null)return this._halfspaces;this._VtoH();return this.halfspaces}get isDisjunct(){return true}get isEmpty(){if(this._isEmpty!=null)return this._isEmpty;this._isEmpty=this._vertices!=null&&this._vertices.length<=this.dim||this._halfspaces!=null&&this._halfspaces.length<=this.dim||this.volume<TOL;return this._isEmpty}get polytopes(){return this.isEmpty?[]:[this]}get vertices(){if(this._vertices!=null)return this._vertices;this._HtoV();return this.vertices}get volume(){throw new _tools.NotImplementedError}apply(m){linalg.assertEqualDims(m[0].length,this.dim);return Polytope.ofDim(m.length).hull(this.vertices.map(v=>linalg.apply(m,v)))}applyRight(m){linalg.assertEqualDims(m.length,this.dim);return Polytope.ofDim(m[0].length).intersection(this.halfspaces.map(h=>h.applyRight(m)))}contains(p){linalg.assertEqualDims(this.dim,p.length);return _tools.iter.every(this.halfspaces.map(h=>h.contains(p)))}covers(other){if(this.isEmpty)return other.isEmpty;return other.remove(this).isEmpty}disjunctify(){return this}fulfils(predicate){linalg.assertEqualDims(this.dim,predicate.dim);return _tools.iter.every(this.vertices.map(v=>predicate.contains(v)))}hull(){return this}intersect(other){linalg.assertEqualDims(this.dim,other.dim);if(other instanceof Union){return other.intersect(this)}else{if(other.isEmpty||this.isEmpty)return other.constructor.empty();return this._intersectPolytope(other)}}intersects(other){for(let p of other.polytopes){if(!this.intersect(p).isEmpty)return true}return false}invert(){return this.constructor.hull(this.vertices.map(v=>v.map(x=>-x)))}isSameAs(other){if(other instanceof Union){return other.isSameAs(this)}else{const vs=this.vertices;const ws=other.vertices;if(this.dim!==other.dim||vs.length!==ws.length){return false}let idxoff=0;while(idxoff<vs.length){if(linalg.areClose(vs[idxoff],ws[0])){break}idxoff++}for(let i=0;i<vs.length;i++){if(!linalg.areClose(vs[(idxoff+i)%vs.length],ws[i])){return false}}return idxoff<vs.length}}minkowski(other){linalg.assertEqualDims(this.dim,other.dim);let points=[];for(let v of this.vertices){for(let w of other.vertices){points.push(linalg.add(v,w))}}return this.constructor.hull(points)}pontryagin(other){linalg.assertEqualDims(this.dim,other.dim);const ws=other.invert().vertices;const halfspaces=[];for(let h of this.halfspaces){for(let w of ws){halfspaces.push(h.translate(w))}}return this.constructor.noredund(halfspaces)}remove(other){const polytopes=other.polytopes;if(polytopes.length===0)return this;let k=0;let halfspaces=null;while(halfspaces==null&&k<polytopes.length){const intersection=this.intersect(polytopes[k]);if(intersection.isEmpty){k++}else{halfspaces=intersection.halfspaces}}if(halfspaces==null)return this;const out=[];let poly=this;for(let halfspace of halfspaces){const[_poly,polyCandidate]=poly.split(halfspace);if(!polyCandidate.isEmpty){if(k<polytopes.length-1){const toRemove=new Union(this.dim,polytopes.slice(k+1),null);out.push(...polyCandidate.remove(toRemove).polytopes)}else{out.push(polyCandidate)}}poly=_poly}return out.length===1?out[0]:new Union(this.dim,out,true)}sample(){const extent=this.extent;for(let i=0;i<10*this.dim;i++){const point=this.extent.map(([l,u])=>l+(u-l)*Math.random());if(this.contains(point))return point}return this.centroid}scale(factor){const c=this.centroid;return this.constructor.hull(this.vertices.map(v=>_tools.arr.zip2map((a,b)=>a+factor*(b-a),c,v)))}serialize(){return{dim:this.dim,vertices:this.vertices}}simplify(){return this}shatter(){throw new _tools.NotImplementedError}split(h){const intersection=this.constructor.intersection;return[intersection([...this.halfspaces,h]),intersection([...this.halfspaces,h.flip()])]}toUnion(){return new Union(this.dim,[this],true)}translate(v){linalg.assertEqualDims(v.length,this.dim);return this.constructor.hull(this.vertices.map(x=>linalg.add(x,v)))}union(other){return Union.from([this,...other.polytopes])}_intersectPolytope(other){return other.constructor.intersection([...this.halfspaces,...other.halfspaces])}_VtoH(){throw new _tools.NotImplementedError}_HtoV(){throw new _tools.NotImplementedError}}exports.Polytope=Polytope;class Interval extends Polytope{constructor(vertices,halfspaces){super(vertices,halfspaces);this.dim=1}static empty(){return new Interval([],[])}static hull(ps){ps.forEach(p=>linalg.assertEqualDims(p.length,1));let leftIdx=0;let rightIdx=0;for(let idx=1;idx<ps.length;idx++){if(ps[idx][0]<ps[leftIdx][0]){leftIdx=idx}if(ps[idx][0]>ps[rightIdx][0]){rightIdx=idx}}if(ps.length<2||linalg.areClose(ps[leftIdx],ps[rightIdx])){return Interval.empty()}else{return new Interval([ps[leftIdx],ps[rightIdx]],null)}}static intersection(halfspaces){return Interval.noredund(halfspaces)}static noredund(halfspaces){const hs=[];for(let h of halfspaces){linalg.assertEqualDims(h.dim,1);if(h.isInfeasible){return Interval.empty()}else if(!h.isTrivial){hs.push(h)}}let leftIdx=-1;let rightIdx=-1;for(let idx=0;idx<hs.length;idx++){if(hs[idx].normal[0]<0&&(leftIdx<0||hs[idx].offset<hs[leftIdx].offset)){leftIdx=idx}if(hs[idx].normal[0]>0&&(rightIdx<0||hs[idx].offset<hs[rightIdx].offset)){rightIdx=idx}}if(leftIdx<0||rightIdx<0||hs[rightIdx].offset+hs[leftIdx].offset<TOL){return Interval.empty()}else{return new Interval(null,[hs[leftIdx],hs[rightIdx]])}}get boundingBox(){return this}get centroid(){const[l,r]=this.vertices;return[(l[0]+r[0])/2]}get volume(){const vs=this.vertices;if(vs.length===0)return 0;return vs[1][0]-vs[0][0]}shatter(){const vertices=this.vertices;const centroid=this.centroid;return new Union(this.dim,[Interval.hull([centroid,vertices[0]]),Interval.hull([centroid,vertices[1]])],true)}_HtoV(){if(this._halfspaces==null){throw new _tools.ValueError}this._vertices=[[-this._halfspaces[0].offset],[this._halfspaces[1].offset]]}_VtoH(){if(this._vertices==null){throw new _tools.ValueError}const[left,right]=this._vertices;this._halfspaces=[new Halfspace([-1],-left[0]),new Halfspace([1],right[0])]}}exports.Interval=Interval;class Polygon extends Polytope{constructor(vertices,halfspaces){super(vertices,halfspaces);this.dim=2}static empty(){return new Polygon([],[])}static hull(ps){ps.forEach(p=>linalg.assertEqualDims(p.length,2));const points=ps.slice().sort((p,q)=>p[0]==q[0]?q[1]-p[1]:p[0]-q[0]);const ls=[];for(let i=0;i<points.length;i++){reduceHullPart(ls,points[i],0);ls.push(points[i])}const us=[];for(let i=points.length-1;i>=0;i--){reduceHullPart(us,points[i],0);us.push(points[i])}if(ls.length+us.length<5){return Polygon.empty()}const vs=[];for(let i=0;i<ls.length-1;i++){reduceHullPart(vs,ls[i],TOL);vs.push(ls[i])}for(let i=0;i<us.length-1;i++){reduceHullPart(vs,us[i],TOL);vs.push(us[i])}reduceHullPart(vs,vs[0],TOL);while(vs.length>1&&!isCCWTurn(vs[vs.length-1],vs[0],vs[1],TOL)){vs.shift()}return vs.length<3?Polygon.empty():new Polygon(vs,null)}static intersection(halfspaces){const hs=[];for(let h of halfspaces){linalg.assertEqualDims(h.dim,2);if(h.isInfeasible){return Polygon.empty()}hs.push(h)}return Polygon.noredund(hs.sort((g,h)=>{const gOrder=angleOrder(g.normal);const hOrder=angleOrder(h.normal);return gOrder==hOrder?angleCCW(g.normal,h.normal)-Math.PI:gOrder-hOrder}))}static noredund(halfplanes){const loop=[];const cuts=[];let idx=0;while(idx<halfplanes.length){const next=halfplanes[idx];if(next.isTrivial){idx++;continue}if(loop.length==0){loop.push(next);idx++;continue}const last=loop[loop.length-1];const angle=angleCCW(last.normal,next.normal);if(angle>Math.PI-TOL){return Polygon.empty()}const nextCut=halfplaneIntersection(last,next);if(nextCut==null){if(last.offset>next.offset){cuts.pop();loop.pop()}else{idx++}continue}if(cuts.length>0&&(!next.contains(cuts[cuts.length-1])||linalg.areClose(nextCut,cuts[cuts.length-1]))){cuts.pop();loop.pop();continue}cuts.push(nextCut);loop.push(next);idx++}let lidx=0;let ridx=loop.length;while(ridx-lidx>=3){const angle=angleCCW(loop[ridx-1].normal,loop[lidx].normal);if(angle>Math.PI-TOL){return Polygon.empty()}const endCut=halfplaneIntersection(loop[lidx],loop[ridx-1]);if(endCut==null){if(loop[lidx].offset>loop[ridx-1].offset){lidx++}else{ridx--}}else if(!loop[ridx-2].contains(endCut)||linalg.areClose(cuts[ridx-2],endCut)){ridx--}else if(!loop[lidx+1].contains(endCut)||linalg.areClose(cuts[lidx],endCut)){lidx++}else{break}}const out=ridx-lidx<3||angleCCW(loop[ridx-1].normal,loop[lidx].normal)>Math.PI-TOL?[]:loop.slice(lidx,ridx);return new Polygon(null,out)}get centroid(){const vol=this.volume;const x=_tools.iter.sum(_tools.arr.cyc2map((a,b)=>(a[0]+b[0])*(a[0]*b[1]-b[0]*a[1]),this.vertices));const y=_tools.iter.sum(_tools.arr.cyc2map((a,b)=>(a[1]+b[1])*(a[0]*b[1]-b[0]*a[1]),this.vertices));return[x/6/vol,y/6/vol]}get volume(){return 0.5*_tools.iter.sum(_tools.arr.cyc2map((a,b)=>a[0]*b[1]-b[0]*a[1],this.vertices))}shatter(){const c=this.centroid;const vs=this.vertices;const l=vs.length;const polys=[[c,vs[0],linalg.midpoint(vs[l-1],vs[0]),linalg.midpoint(vs[0],vs[1])],[c,vs[l-1],linalg.midpoint(vs[l-2],vs[l-1]),linalg.midpoint(vs[l-1],vs[0])]];for(let i=1;i<l-1;i++){polys.push([c,vs[i],linalg.midpoint(vs[i-1],vs[i]),linalg.midpoint(vs[i],vs[i+1])])}return new Union(this.dim,polys.map(Polygon.hull),true)}_HtoV(){if(this._halfspaces==null){throw new _tools.ValueError}else{this._vertices=_tools.arr.cyc2map(function(v,w){const cut=halfplaneIntersection(v,w);if(cut==null){throw{}}else{return cut}},this._halfspaces)}}_VtoH(){if(this._vertices==null){throw new _tools.ValueError}else{this._halfspaces=_tools.arr.cyc2map(function(v,w){return Halfspace.normalized([w[1]-v[1],v[0]-w[0]],v[0]*w[1]-w[0]*v[1])},this._vertices)}}}exports.Polygon=Polygon;class Union{constructor(dim,polytopes,isDisjunct){this.dim=dim;this.polytopes=polytopes.filter(_=>!_.isEmpty);this.isEmpty=this.polytopes.length===0;this._isDisjunct=this.polytopes.length<2||isDisjunct}static deserialize(json){return new Union(json.dim,json.polytopes.map(Polytope.deserialize),null)}static empty(dim){return new Union(dim,[],true)}static from(polytopes,fallbackDim){const dim=polytopes.length>0?polytopes[0].dim:fallbackDim;if(dim==null)throw new _tools.ValueError("Unable to determine dimension from empty set of polytopes (no fallback provided)");polytopes.forEach(_=>linalg.assertEqualDims(_.dim,dim));return new Union(dim,polytopes,null)}get boundingBox(){const Poly=Polytope.ofDim(this.dim);return this.isEmpty?Poly.empty():Poly.hull(cartesian(...this.extent))}get extent(){const init=new Array(this.dim);init.fill([Infinity,-Infinity]);return this.polytopes.map(_=>_.extent).reduce((ext,cur)=>{return _tools.arr.zip2map((a,b)=>[a[0]<b[0]?a[0]:b[0],a[1]<b[1]?b[1]:a[1]],ext,cur)},init)}get isDisjunct(){return this._isDisjunct!=null&&this._isDisjunct}get volume(){const polytopes=this.isDisjunct?this.polytopes:this.simplify().polytopes;return _tools.iter.sum(polytopes.map(_=>_.volume))}apply(m){return new Union(this.dim,this.polytopes.map(_=>_.apply(m)),this._isDisjunct)}applyRight(m){linalg.assertEqualDims(m.length,this.dim);return new Union(m[0].length,this.polytopes.map(_=>_.applyRight(m)),this._isDisjunct)}contains(v){for(let p of this.polytopes){if(p.contains(v))return true}return false}covers(other){if(this.isEmpty)return other.isEmpty;return other.remove(this).isEmpty}disjunctify(){const ps=this.polytopes.slice().sort((x,y)=>x.volume-y.volume);const out=[];while(ps.length>0){const p=ps.pop();out.push(...p.remove(new Union(this.dim,out,true)).polytopes)}return new Union(this.dim,out,true)}fulfils(h){return _tools.iter.every(this.polytopes.map(_=>_.fulfils(h)))}hull(){const vertices=[];for(let polytope of this.polytopes){vertices.push(...polytope.vertices)}return Polytope.ofDim(this.dim).hull(vertices)}intersect(other){const out=[];for(let x of this.polytopes){for(let y of other.polytopes){const intersection=x.intersect(y);if(!intersection.isEmpty){out.push(intersection)}}}return out.length===1?out[0]:new Union(this.dim,out,this._isDisjunct?true:null)}intersects(other){for(let p of this.polytopes){if(p.intersects(other))return true}return false}invert(){return new Union(this.dim,this.polytopes.map(_=>_.invert()),this._isDisjunct)}isSameAs(other){return this.covers(other)&&other.covers(this)}minkowski(other){return new Union(this.dim,this.polytopes.map(_=>_.minkowski(other)),null)}pontryagin(other){const bbox=this.boundingBox;const complement=bbox.remove(this);return bbox.pontryagin(other).remove(complement.minkowski(other.invert()))}remove(other){const out=[];for(let p of this.polytopes){out.push(...p.remove(other).polytopes)}return new Union(this.dim,out,this._isDisjunct?true:null)}sample(){if(this.polytopes.length>=1){return this.polytopes[0].sample()}throw new _tools.NotImplementedError}serialize(){return{dim:this.dim,polytopes:this.polytopes.map(_=>_.serialize())}}shatter(){const pieces=[];for(let x of this.polytopes){pieces.push(...x.shatter().polytopes)}return new Union(this.dim,pieces,this._isDisjunct)}simplify(){if(this.isEmpty)return this;if(this.polytopes.length===1)return this.polytopes[0];const hull=this.hull();const rest=hull.remove(this);if(rest.isEmpty){return hull}else{return hull.remove(rest)}}toUnion(){return this}translate(v){return new Union(this.dim,this.polytopes.map(_=>_.translate(v)),this._isDisjunct)}union(other){linalg.assertEqualDims(this.dim,other.dim);return new Union(this.dim,[...this.polytopes,...other.polytopes],null)}}exports.Union=Union;

},{"./linalg.js":5,"./parser.js":7,"./tools.js":11}],4:[function(require,module,exports){
"use strict";var _controller=require("./controller.js");var _game=require("./game.js");var _geometry=require("./geometry.js");var _logic=require("./logic.js");var _refinement=require("./refinement.js");var _snapshot=require("./snapshot.js");var _system=require("./system.js");var _tools=require("./tools.js");var _worker=require("./worker.js");class SystemManager{constructor(){this._snapshots=new _snapshot.SnapshotTree;this._system=null;this._analysis=null;this._objective=null}initialize(system,objective,analyse){this._system=system;this._objective=objective;if(analyse)this.analyse();this.takeSnapshot("Initial Problem")}get objective(){return(0,_tools.just)(this._objective,"system worker is not initialized yet (objective is not set)")}get system(){return(0,_tools.just)(this._system,"system worker is not initialized yet (system is not set)")}get lss(){return this.system.lss}get analysis(){return this._analysis}get snapshotTree(){return this._treeify(this._snapshots.root)}_treeify(id){return{id:id,name:this._snapshots.getName(id),states:this._snapshots.getNumberOfStates(id),children:_tools.sets.map(_=>this._treeify(_),this._snapshots.getChildren(id)),isCurrent:id===this._snapshots.current}}takeSnapshot(name){this._snapshots.take(name,this.system,this.analysis,true)}loadSnapshot(id){this._snapshots.select(id);this._system=this._snapshots.getSystem();this._analysis=this._snapshots.getAnalysis();return this._snapshots.getSnapshot()}nameSnapshot(id,name){this._snapshots.rename(id,name)}analyse(){const t0=performance.now();const game=_game.TwoPlayerProbabilisticGame.fromProduct(this.system,this.objective,this.analysis);const t1=performance.now();const results=game.analyse();const t2=performance.now();if(this._analysis!=null)results.transferFromPrevious(this._analysis);const updated=results.updated(this._analysis);this._analysis=results;return{states:[game.p1States.size,game.p2States.size],actions:[_tools.iter.sum(_tools.iter.map(_=>_.actions.length,game.p1States)),_tools.iter.sum(_tools.iter.map(_=>_.actions.length,game.p2States))],updated:Array.from(updated),tGame:t1-t0,tAnalysis:t2-t1}}resetAnalysis(){this._analysis=null}refine(refinery){const partition=refinery.partitionAll(this.system.states.values());const refinementMap=this.system.refine(partition);const analysis=this.analysis;if(analysis!=null){analysis.remap(refinementMap)}return refinementMap}getAnalysis(state){if(this._analysis==null)return null;const result=this._analysis.get(state.label);return result}getCountStats(q){return this._stats(q,_=>1)}getVolumeStats(q){return this._stats(q,_=>_.polytope.volume)}_stats(q,f){let sYes=0;let sMaybe=0;let sNo=0;let sUnreach=0;for(let state of this.system.states.values()){const result=this.getAnalysis(state);if(state.isOuter){continue}else if(result==null||result.maybe.has(q)){sMaybe+=f(state)}else if(result.yes.has(q)){sYes+=f(state)}else if(result.no.has(q)){sNo+=f(state)}else{sUnreach+=f(state)}}return{yes:sYes,no:sNo,maybe:sMaybe,unreachable:sUnreach}}exportSession(includeGraph){return{objective:this.objective.serialize(),snapshots:this._snapshots.serialize(includeGraph)}}importSession(session){this._snapshots=_snapshot.SnapshotTree.deserialize(session.snapshots);this._objective=_logic.Objective.deserialize(session.objective);this._system=this._snapshots.getSystem();this._analysis=this._snapshots.getAnalysis()}}const $=new SystemManager;const inspector=new _worker.Communicator("2W");inspector.onRequest("update-states",function(data){const out=new Map;for(let[label,state]of $.system.states){out.set(label,stateDataOf(state))}return out});function stateDataOf(state){return{label:state.label,isOuter:state.isOuter,predicates:state.predicates,analysis:$.getAnalysis(state),polytope:state.polytope.serialize(),centroid:state.polytope.centroid}}inspector.onRequest("get-actions",function(data){return $.system.getState(data).actions.map((action,id)=>({origin:action.origin.label,id:id,controls:action.controls.toUnion().serialize(),targets:Array.from(action.targets,_=>_.label)}))});inspector.onRequest("get-supports",function(data){const[stateLabel,actionId]=data;const state=$.system.getState(stateLabel);return state.actions[actionId].supports.map((support,id)=>({origin:stateDataOf(state),id:id,origins:support.origins.toUnion().serialize(),targets:Array.from(support.targets,stateDataOf)}))});const Controllers={"random":_controller.RandomController,"round-robin":_controller.RoundRobinController};inspector.onRequest("get-trace",function(data){const Cls=(0,_tools.just)(Controllers[data.controller],"Controller '"+data.controller+"' not found in built-in controllers");const controller=new Cls($.system,$.objective,$.analysis);const[xLabel,qLabel]=data.origin;const qInit=$.objective.getState(qLabel);const xInit=xLabel==null?$.system.lss.xx.sample():$.system.getState(xLabel).polytope.sample();const trace=new _controller.Trace($.system,$.objective);trace.stepFor(data.steps,controller,xInit,null,qInit);return trace.serialize()});inspector.onRequest("analyse",function(data){return $.analyse()});inspector.onRequest("reset-analysis",function(data){$.resetAnalysis();return null});inspector.onRequest("get-system-summary",function(data){return new Map(_tools.iter.map(q=>[q,{count:$.getCountStats(q),volume:$.getVolumeStats(q)}],$.objective.allStates))});function refineData(elapsed,refinementMap){const removed=[];const created=[];for(let[r,cs]of refinementMap){removed.push(r.label);for(let c of cs)created.push(c.label)}return{elapsed:elapsed,removed:removed,created:created}}inspector.onRequest("refine-transition",function(data){const analysis=(0,_tools.just)($.analysis,"Refinement requires an analysed system");const t0=performance.now();const refinery=new _refinement.TransitionRefinery($.system,$.objective,analysis,data.origin,data.target,data.layers,data.settings);refinery.iterate(data.steps);const refinementMap=$.refine(refinery);const t1=performance.now();return refineData(t1-t0,refinementMap)});inspector.onRequest("refine-holistic",function(data){const analysis=(0,_tools.just)($.analysis,"Refinement requires an analysed system");const t0=performance.now();let refinery;if(data.method==="positive-robust"){refinery=new _refinement.PositiveRobustRefinery($.system,$.objective,analysis,data.operator)}else if(data.method==="negative-attractor"){refinery=new _refinement.NegativeAttrRefinery($.system,$.objective,analysis)}else if(data.method==="safety"){refinery=new _refinement.SafetyRefinery($.system,$.objective,analysis)}else if(data.method==="self-loop"){refinery=new _refinement.SelfLoopRefinery($.system,$.objective,analysis,data.optimistic,data.onlySafe)}else throw new Error("Unknown holistic refinement method '"+data.method+"'");const refinementMap=$.refine(refinery);const t1=performance.now();return refineData(t1-t0,refinementMap)});inspector.onRequest("get-snapshots",function(data){return $.snapshotTree});inspector.onRequest("take-snapshot",function(data){$.takeSnapshot(data);return null});inspector.onRequest("load-snapshot",function(data){const snap=$.loadSnapshot(data);return{name:snap.name,states:snap.system.states.filter(_=>!_.isOuter).length}});inspector.onRequest("name-snapshot",function(data){$.nameSnapshot(...data);return null});inspector.onRequest("export-session",function(data){return $.exportSession(false)});inspector.host=self;inspector.request("init",null).then(function(data){const[system,objective,analyse,session]=data;$.initialize(_system.AbstractedLSS.deserialize(system),_logic.Objective.deserialize(objective),analyse);if(session!=null){$.importSession(session)}inspector.request("ready",null)});

},{"./controller.js":1,"./game.js":2,"./geometry.js":3,"./logic.js":6,"./refinement.js":8,"./snapshot.js":9,"./system.js":10,"./tools.js":11,"./worker.js":12}],5:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.assertEqualDims=assertEqualDims;exports.norm2=norm2;exports.dot=dot;exports.add=add;exports.sub=sub;exports.midpoint=midpoint;exports.areClose=areClose;exports.apply=apply;exports.applyRight=applyRight;exports.eye=eye;exports.det=det;exports.inv=inv;exports.transpose=transpose;exports.matmul=matmul;exports.minkowski=exports.TOL=exports.MathError=exports.DimensionMismatch=void 0;var _tools=require("./tools.js");class DimensionMismatch extends Error{}exports.DimensionMismatch=DimensionMismatch;class MathError extends Error{}exports.MathError=MathError;const TOL=1e-8;exports.TOL=TOL;function assertEqualDims(n,m){if(n!=m){throw new DimensionMismatch(String(n)+" != "+String(m))}}function norm2(v){let squares=0;for(let x of v){squares+=x*x}return Math.sqrt(squares)}function dot(v,w){assertEqualDims(v.length,w.length);let sum=0;for(let i=0;i<v.length;i++){sum+=v[i]*w[i]}return sum}function add(v,w){assertEqualDims(v.length,w.length);return _tools.arr.zip2map((a,b)=>a+b,v,w)}function sub(v,w){assertEqualDims(v.length,w.length);return _tools.arr.zip2map((a,b)=>a-b,v,w)}function midpoint(v,w){assertEqualDims(v.length,w.length);return _tools.arr.zip2map((a,b)=>a+0.5*(b-a),v,w)}function areClose(v,w){assertEqualDims(v.length,w.length);return norm2(sub(v,w))<TOL}function apply(m,v){assertEqualDims(m[0].length,v.length);return m.map(row=>dot(row,v))}function applyRight(m,v){return matmul([v],m)[0]}function eye(size){const m=[];for(let i=0;i<size;i++){const row=new Array(size);row.fill(0);row[i]=1;m.push(row)}return m}function det(m){assertEqualDims(m.length,m[0].length);switch(m.length){case 1:return m[0][0];case 2:return m[0][0]*m[1][1]-m[0][1]*m[1][0];default:throw new _tools.NotImplementedError;}}function inv(m){assertEqualDims(m.length,m[0].length);const d=det(m);if(Math.abs(d)<TOL){throw new MathError("matrix not invertible")}else{switch(m.length){case 1:return[[1/d]];case 2:return[[m[1][1]/d,-m[0][1]/d],[-m[1][0]/d,m[0][0]/d]];default:throw new _tools.NotImplementedError;}}}function transpose(m){const result=[];for(let j=0;j<m[0].length;j++){const row=[];for(let i=0;i<m.length;i++){row.push(m[i][j])}result.push(row)}return result}function matmul(m,n){assertEqualDims(m[0].length,n.length);const result=[];for(let i=0;i<m.length;i++){const row=[];for(let j=0;j<n[0].length;j++){let akkumulator=0;for(let k=0;k<n.length;k++){akkumulator+=m[i][k]*n[k][j]}row.push(akkumulator)}result.push(row)}return result}const minkowski={xmy(xs,ys){const out=[];for(let x of xs){for(let y of ys){out.push(sub(x,y))}}return out},axpy(A,xs,ys){const out=[];for(let x of xs){const Ax=apply(A,x);for(let y of ys){out.push(add(Ax,y))}}return out}};exports.minkowski=minkowski;

},{"./tools.js":11}],6:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.parseProposition=parseProposition;exports.texifyProposition=texifyProposition;exports.traverseProposition=traverseProposition;exports.unicodeifyTransitionLabel=unicodeifyTransitionLabel;exports.AutomatonState=exports.OnePairStreettAutomaton=exports.Implication=exports.Disjunction=exports.Conjunction=exports.Negation=exports.Top=exports.AtomicProposition=exports.Objective=void 0;var _parser=require("./parser.js");var _tools=require("./tools.js");class Objective{constructor(kind,terms,coSafeInterpretation){this.kind=kind;if(terms.length!==kind.variables.length)throw new Error("Number of terms ("+terms.length+") does not match number of variables ("+kind.variables.length+")");this.propositions=new Map(_tools.arr.zip2(kind.variables,terms));this.automaton=OnePairStreettAutomaton.parse(kind.automaton);this.allStates=_tools.sets.map(_=>_.label,this.automaton.states.values());this.coSafeInterpretation=coSafeInterpretation!=null&&coSafeInterpretation;if(this.coSafeInterpretation&&!this.automaton.isCoSafeCompatible)throw new Error("Co-safe interpretation chosen, but automaton is not co-safe compatible")}static deserialize(json){return new Objective(json.kind,json.terms.map(parseProposition),json.coSafeInterpretation)}getState(label){return(0,_tools.just)(this.automaton.states.get(label),"automaton state "+label+" does not exist")}getProposition(symbol){return(0,_tools.just)(this.propositions.get(symbol),"no formula for symbol "+symbol+" exists")}valuationFor(predicates){return atom=>{const formula=this.getProposition(atom.symbol);return formula.evalWith(_=>predicates.has(_.symbol))}}nextState(predicates,label){const state=this.getState(label);const next=state.successor(this.valuationFor(predicates));return next==null?null:next.label}isCoSafeFinal(label){const state=this.getState(label);return this.coSafeInterpretation&&state.isFinal&&this.automaton.acceptanceSetF.has(state)}toShapes(){const shapes=this.automaton.toShapes(this.kind.automatonPlacement);let xmin=Infinity;let xmax=-Infinity;let ymin=Infinity;let ymax=-Infinity;for(let[x,y,_]of _tools.obj.values(this.kind.automatonPlacement)){if(x<xmin)xmin=x;if(x>xmax)xmax=x;if(y<ymin)ymin=y;if(y>ymax)ymax=y}shapes.extent=[[xmin-120,xmax+120],[ymin-80,ymax+80]];return shapes}serialize(){return{kind:this.kind,terms:this.kind.variables.map(_=>this.getProposition(_).stringify()),coSafeInterpretation:this.coSafeInterpretation}}}exports.Objective=Objective;class AtomicProposition{constructor(symbol){this.symbol=symbol}evalWith(valuate){return valuate(this)}stringify(){return this.symbol}}exports.AtomicProposition=AtomicProposition;class Top{evalWith(valuate){return true}stringify(){return"TRUE"}}exports.Top=Top;class Negation{constructor(arg){this.args=[arg]}evalWith(valuate){return!this.args[0].evalWith(valuate)}stringify(){return"(!"+this.args[0].stringify()+")"}}exports.Negation=Negation;class Conjunction{constructor(larg,rarg){this.args=[larg,rarg]}evalWith(valuate){return this.args[0].evalWith(valuate)&&this.args[1].evalWith(valuate)}stringify(){return"("+this.args[0].stringify()+" & "+this.args[1].stringify()+")"}}exports.Conjunction=Conjunction;class Disjunction{constructor(larg,rarg){this.args=[larg,rarg]}evalWith(valuate){return this.args[0].evalWith(valuate)||this.args[1].evalWith(valuate)}stringify(){return"("+this.args[0].stringify()+" | "+this.args[1].stringify()+")"}}exports.Disjunction=Disjunction;class Implication{constructor(larg,rarg){this.args=[larg,rarg]}evalWith(valuate){return!this.args[0].evalWith(valuate)||this.args[1].evalWith(valuate)}stringify(){return"("+this.args[0].stringify()+" -> "+this.args[1].stringify()+")"}}exports.Implication=Implication;const PROP_OPS=[{op:"->",precedence:20,associativity:1,cls:Implication,tex:"\\rightarrow"},{op:"|",precedence:30,associativity:-1,cls:Disjunction,tex:"\\vee"},{op:"&",precedence:40,associativity:-1,cls:Conjunction,tex:"\\wedge"},{op:"!",precedence:50,associativity:0,cls:Negation,tex:"\\neg"}];function getOpOf(prop){for(let op of PROP_OPS){if(prop instanceof op.cls){return op}}throw new Error("unknown operator")}const parsePropositionAST=(0,_parser.ASTParser)(/[()!&|]|->|(?:[a-z\\][a-z0-9]*)/,PROP_OPS);function asProposition(node){if(typeof node==="string"){return new AtomicProposition(node)}else{for(let op of PROP_OPS){if(node.op===op.op){return new op.cls(...node.args.map(asProposition))}}throw new _parser.ParseError("unknown operator '"+node.op+"'")}}function parseProposition(text){return asProposition(parsePropositionAST(text))}function texifyProposition(prop,symbolTransform,parentOp,rightArg){if(symbolTransform==null){symbolTransform=_=>_}if(prop instanceof AtomicProposition){return symbolTransform(prop.symbol)}if(prop instanceof Top){return symbolTransform("__TRUE__")}const op=getOpOf(prop);let out="";let needsParentheses=false;if(op.associativity===0){const arg=prop.args[0];if(arg instanceof AtomicProposition){out=op.tex+" "+symbolTransform(arg.symbol)}else{out=op.tex+" ("+texifyProposition(arg,symbolTransform)+")"}}else{const left=texifyProposition(prop.args[0],symbolTransform,op,false);const right=texifyProposition(prop.args[1],symbolTransform,op,true);out=left+" "+op.tex+" "+right;needsParentheses=parentOp!=null&&(parentOp.precedence>op.precedence||parentOp.precedence===op.precedence&&(rightArg&&op.associativity<0||!rightArg&&op.associativity>0))}return needsParentheses?"("+out+")":out}function traverseProposition(fun,prop){fun(prop);if(prop instanceof AtomicProposition){}else if(prop instanceof Top){}else{for(let arg of prop.args){traverseProposition(fun,arg)}}}function unicodeifyTransitionLabel(text){_tools.obj.forEach((k,v)=>{text=(0,_tools.replaceAll)(text,k,v)},{"\\varphi":"\u03C6","\\theta":"\u03B8","\\mu":"\u03BC","\\pi":"\u03C0","\\rho":"\u03C1","\\vee":"\u2228","\\wedge":"\u2227","\\neg":"\xAC","\\rightarrow":"\u2192"," ":""});return text}class OnePairStreettAutomaton{constructor(){this.states=new Map;this.acceptanceSetE=new Set;this.acceptanceSetF=new Set}get isCoSafeCompatible(){const E=this.acceptanceSetE;const F=this.acceptanceSetF;return F.size>0&&!_tools.sets.doIntersect(E,F)&&_tools.sets.difference(this.states.values(),_tools.sets.union(E,F)).size===0&&_tools.iter.every(_tools.iter.map(_=>_.isFinal,F))}takeState(label){let state=this.states.get(label);if(state==null){state=new AutomatonState(label);this.states.set(label,state)}return state}toShapes(placement,propositions){const ss=new Map;const tss=new Map;for(let origin of this.states.values()){const[x,y,loopAngle]=placement[origin.label];const member=(this.acceptanceSetE.has(origin)?"E":"")+(this.acceptanceSetF.has(origin)?"F":"");ss.set(origin.label,[{kind:"state",coords:[x,y],member:member},{kind:"label",coords:[x,y],text:origin.label}]);const ts=new Map;for(let[target,proposition]of origin.transitions){const text=unicodeifyTransitionLabel(texifyProposition(proposition));if(origin.label===target.label){ts.set(origin.label,[{kind:"loop",coords:[x,y],angle:loopAngle},{kind:"loopLabel",text:text,coords:[x,y],angle:loopAngle}])}else{const[xx,yy,_]=placement[target.label];ts.set(target.label,[{kind:"transition",origin:[x,y],target:[xx,yy]},{kind:"transitionLabel",text:text,origin:[x,y],target:[xx,yy]}])}}if(origin.defaultTarget!=null){if(origin.label===origin.defaultTarget.label){ts.set(origin.label,[{kind:"loop",coords:[x,y],angle:loopAngle},{kind:"loopLabel",text:"\u2217",coords:[x,y],angle:loopAngle}])}else{const[xx,yy,_]=placement[origin.defaultTarget.label];ts.set(origin.defaultTarget.label,[{kind:"transition",origin:[x,y],target:[xx,yy]},{kind:"transitionLabel",text:"\u2217",origin:[x,y],target:[xx,yy]}])}}tss.set(origin.label,ts)}return{states:ss,transitions:tss}}stringify(){const transitions=[];const acceptE=[];const acceptF=[];for(let state of this.states.values()){for(let[target,formula]of state.transitions){transitions.push(state.label+">"+formula.stringify()+">"+target.label)}if(state.defaultTarget!=null){transitions.push(state.label+">>"+state.defaultTarget.label)}if(this.acceptanceSetE.has(state)){acceptE.push(state.label)}if(this.acceptanceSetF.has(state)){acceptF.push(state.label)}}return[transitions.join(","),this.initialState.label,acceptE.join(","),acceptF.join(",")].join(" ; ")}static parse(s){const automaton=new OnePairStreettAutomaton;const[transitions,initialState,acceptanceSetE,acceptanceSetF]=s.split(";");for(let transition of transitions.split(",").map(x=>x.trim()).filter(x=>x.length>0)){const opIdx=transition.indexOf(">");const ptIdx=transition.lastIndexOf(">");if(opIdx<0||ptIdx<0||opIdx==ptIdx)throw new Error("Invalid transition '"+transition+"'");const o=transition.substring(0,opIdx).trim();const origin=automaton.takeState(o);const t=transition.substring(ptIdx+1).trim();const target=automaton.takeState(t);const p=transition.substring(opIdx+1,ptIdx).trim();if(p===""){if(origin.defaultTarget!=null)throw new Error("Default target set twice for state '"+o+"'");if(origin.transitions.has(target))throw new Error("Two transitions to target '"+t+"' set for state '"+o+"'");origin.defaultTarget=target}else{const formula=parseProposition(p);if(origin.transitions.has(target)||origin.defaultTarget===target)throw new Error("Two transitions to target '"+t+"' set for state '"+o+"'");origin.transitions.set(target,formula)}}for(let label of acceptanceSetE.split(",").map(x=>x.trim()).filter(x=>x.length>0)){automaton.acceptanceSetE.add(automaton.takeState(label))}for(let label of acceptanceSetF.split(",").map(x=>x.trim()).filter(x=>x.length>0)){automaton.acceptanceSetF.add(automaton.takeState(label))}automaton.initialState=automaton.takeState(initialState.trim());return automaton}}exports.OnePairStreettAutomaton=OnePairStreettAutomaton;class AutomatonState{constructor(label){if(label.startsWith("__"))throw new Error("automaton state labels starting with '__' are reserved");this.label=label;this.transitions=new Map;this.defaultTarget=null}get isFinal(){return this.transitions.size===0&&this.defaultTarget===this}successor(valuation){for(let[target,formula]of this.transitions){if(formula.evalWith(valuation))return target}return this.defaultTarget}proposition(successor){let prop=null;const prevProps=[];for(let[target,formula]of this.transitions){if(target===successor){prop=formula;break}else{prevProps.push(formula)}}const preCond=prevProps.length>0?new Negation(prevProps.reduce((l,r)=>new Disjunction(l,r))):new Top;if(prop!=null){return new Conjunction(preCond,prop)}else if(this.defaultTarget===successor){return preCond}else{return null}}}exports.AutomatonState=AutomatonState;

},{"./parser.js":7,"./tools.js":11}],7:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.ASTParser=ASTParser;exports.printAST=printAST;exports.ParseError=void 0;class ParseError extends Error{}exports.ParseError=ParseError;function ASTParser(tokenPattern,operators){const pcparser=new PCParser(operators);return function(text){const tokenStream=new TokenStream(text,tokenPattern);return pcparser.parse(tokenStream)}}function printAST(node){return typeof node==="string"?node:node.op+"("+node.args.map(printAST).join(", ")+")"}class TokenStream{constructor(text,pattern){this.text=text;this.pattern=RegExp("\\s*("+pattern.source+")\\s*","gy");this.advance()}advance(){if(this.pattern.lastIndex==this.text.length){this.current=null}else{const lastIndex=this.pattern.lastIndex;const match=this.pattern.exec(this.text);if(match==null)throw new ParseError("unable to tokenize '"+this.text.slice(lastIndex)+"'");this.current=match[1]}}list(){const tokens=[];while(this.current!=null){tokens.push(this.current);this.advance()}return tokens}}class PCParser{constructor(operators){this.uProp={};this.bProp={};for(let operator of operators){if(operator.associativity===0){this.uProp[operator.op]=operator.precedence}else{this.bProp[operator.op]=[operator.precedence,operator.associativity<0]}}}parse(tokens){const ast=this.computeExpr(tokens,0);if(tokens.current!=null)throw new ParseError("expected end token but found token "+tokens.current);return ast}computeExpr(tokens,minPrec){let left=this.computeAtom(tokens);while(true){const token=tokens.current;if(token==null||!this.bProp.hasOwnProperty(token)){break}const[prec,lAssoc]=this.bProp[token];if(prec<minPrec){break}tokens.advance();const right=this.computeExpr(tokens,lAssoc?prec+1:prec);left={op:token,args:[left,right]}}return left}computeAtom(tokens){const token=tokens.current;if(token==null)throw new ParseError("unexpected end of token stream");tokens.advance();if(this.uProp.hasOwnProperty(token)){const arg=this.computeExpr(tokens,this.uProp[token]);return{op:token,args:[arg]}}else if(token==="("){const inner=this.computeExpr(tokens,0);if(tokens.current!==")")throw new ParseError("unexpected token "+String(tokens.current)+", expected closing parenthesis");tokens.advance();return inner}else{return token}}}

},{}],8:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.TransitionRefinery=exports.SelfLoopRefinery=exports.SafetyRefinery=exports.NegativeAttrRefinery=exports.PositiveRobustRefinery=exports.Refinery=void 0;var _geometry=require("./geometry.js");var linalg=_interopRequireWildcard(require("./linalg.js"));var _system=require("./system.js");var _tools=require("./tools.js");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}}newObj.default=obj;return newObj}}function refineAttrR(lss,origin,target){if(!lss.actR(origin,target).isEmpty){return[origin,_geometry.Polytope.ofDim(lss.dim).empty()]}const u=sampleControl(lss,origin,target);const attrR=u==null?null:lss.attrR(origin,u,target).simplify();if(attrR!=null&&!attrR.isEmpty){return[attrR,origin.remove(attrR)]}else{return[_geometry.Polytope.ofDim(lss.dim).empty(),origin]}}function sampleControl(lss,origin,target){const preR=lss.preR(origin,lss.uu,target).hull();const xs=Array.from(preR.vertices);for(let i=0;i<3*lss.dim;i++){xs.push(preR.sample())}const actR=x=>{const Axpw=lss.ww.translate(linalg.apply(lss.A,x));return target.pontryagin(Axpw).applyRight(lss.B).intersect(lss.uu)};const u=_tools.iter.argmax(_=>_.items.length,(0,_system.itemizedOperatorPartition)(xs,actR).filter(_=>!_.region.isEmpty));return u==null?null:u.region.polytopes[0]}class Refinery{constructor(system,objective,results){this.system=system;this.objective=objective;this.results=results}partitionAll(states){return new Map(_tools.iter.map(_=>[_,this.partition(_)],states))}partition(x){throw new _tools.NotImplementedError("Refinery must override method 'partition'")}_isDecided(x,q){return!this._getResult(x).maybe.has(q)}_getStates(which,q){return _tools.iter.filter(state=>this._getResult(state)[which].has(q),this.system.states.values())}_getStateRegion(which,q){return this._asRegion(this._getStates(which,q))}_getResult(x){return(0,_tools.just)(this.results.get(x.label))}_getEmpty(){return _geometry.Polytope.ofDim(this.system.lss.dim).empty()}_asRegion(xs){const polys=[];for(let x of xs){polys.push(x.polytope)}return polys.length===0?this._getEmpty():_geometry.Union.from(polys).simplify()}_qNext(x,q){return this.objective.nextState(x.predicates,q)}}exports.Refinery=Refinery;class _HolisticGeometricRefinery extends Refinery{partition(x){let parts=x.polytope;for(let q of this.objective.allStates){const qNext=this._qNext(x,q);if(this._isDecided(x,q)||qNext==null){continue}let newParts=this._getEmpty();for(let part of parts.polytopes){newParts=newParts.union(this._partition(part,qNext))}parts=newParts}return parts}_partition(part,qNext){throw new Error("_HolisticGeometricRefinery subclass must implement method _partition")}}class PositiveRobustRefinery extends _HolisticGeometricRefinery{constructor(system,objective,results,operator){super(system,objective,results);this._op=operator;this._yes=_tools.obj.fromMap(q=>this._getStateRegion("yes",q),this.objective.allStates)}_partition(part,qNext){const lss=this.system.lss;if(this._op==="PreR"){const preR=lss.preR(part,lss.uu,this._yes[qNext]);return preR.union(part.remove(preR).simplify())}else if(this._op==="AttrR"){const[attr,other]=refineAttrR(lss,part,this._yes[qNext]);return attr.union(other)}else throw new Error("Unknown operator '"+this._op+"' for positive robust refinement")}}exports.PositiveRobustRefinery=PositiveRobustRefinery;class NegativeAttrRefinery extends _HolisticGeometricRefinery{constructor(system,objective,results){super(system,objective,results);const lss=system.lss;this._attr=_tools.obj.fromMap(q=>{const no=this._getStateRegion("no",q);return lss.attr(lss.xx,lss.uu,no).simplify()},objective.allStates)}_partition(part,qNext){const attr=part.intersect(this._attr[qNext]).simplify();if(attr.isEmpty){return part}else{return attr.union(part.remove(attr).simplify())}}}exports.NegativeAttrRefinery=NegativeAttrRefinery;class SafetyRefinery extends _HolisticGeometricRefinery{constructor(system,objective,results){super(system,objective,results);this._ok=_tools.obj.fromMap(q=>{return system.lss.xx.remove(this._getStateRegion("no",q)).simplify()},this.objective.allStates)}_partition(part,qNext){const[safe,other]=refineAttrR(this.system.lss,part,this._ok[qNext]);return safe.union(other)}}exports.SafetyRefinery=SafetyRefinery;class SelfLoopRefinery extends Refinery{constructor(system,objective,results,optimistic,onlySafe){super(system,objective,results);this.optimistic=optimistic;this.onlySafe=onlySafe;this._noStates=_tools.obj.fromMap(q=>new Set(this._getStates("no",q)),objective.allStates)}partition(x){if(x.post(this.system.lss.uu).intersect(x.polytope).isEmpty){return x.polytope}for(let q of this.objective.allStates){if(this._isDecided(x,q)||this._qNext(x,q)!==q){continue}let goodAction=null;let support=null;for(let action of x.actions){const targetsSelf=action.targets.has(x);if(!this.onlySafe||this._isSafe(action.targets,q)){if(!targetsSelf){goodAction=action}else{let selfLoopSupport=null;for(let support of action.supports){if(support.targets.size===1&&support.targets.has(x)){selfLoopSupport=support;break}}if(selfLoopSupport==null){goodAction=action}else{support=selfLoopSupport;break}}}}if(!(this.optimistic&&goodAction!=null)&&support!=null){const preP=support.origins.simplify();return preP.union(x.polytope.remove(preP).simplify())}}return x.polytope}_isSafe(targets,q){return!_tools.sets.doIntersect(targets,this._noStates[q])}}exports.SelfLoopRefinery=SelfLoopRefinery;class RobustReachabilityProblem{constructor(lss,parts,reach,avoid,settings){this.lss=lss;this.avoid=avoid;this.reach=reach;this._epsPolytope=lss.ww.scale(0.1);this.expandTarget=settings.expandTarget;this.dontRefineSmall=settings.dontRefineSmall;this.postProcessing={"none":null,"hull":_=>_.hull(),"largest":_=>{const largest=_tools.iter.argmax(poly=>poly.volume,_.polytopes);return largest==null?_:largest},"suppress":_=>_geometry.Union.from(_.polytopes.filter(poly=>!poly.pontryagin(lss.ww).isEmpty),_.dim)}[settings.postProcessing];this._parts=[];for(let[state,region]of parts){for(let poly of region.polytopes){this._parts.push({polytope:poly,state:state,done:false})}}this._target=reach.simplify()}get partitions(){const partitions=new Map;for(let part of this._parts){const region=partitions.get(part.state);partitions.set(part.state,region==null?part.polytope:region.union(part.polytope))}return partitions}get allDone(){return this._parts.every(_=>_.done)}iterate(n){for(let i=0;i<n;i++){this._update();if(this.allDone)break;this._refine()}}_refine(){const parts=[];for(let part of this._parts){if(part.done){parts.push(part);continue}else if(part.polytope.pontryagin(this._epsPolytope).isEmpty){part.done=true;parts.push(part);continue}else if(this.dontRefineSmall&&part.polytope.pontryagin(this.lss.ww).isEmpty&&!this.lss.act(part.polytope,this.avoid).isSameAs(this.lss.uu)){part.done=true;parts.push(part);continue}else{let[good,other]=refineAttrR(this.lss,part.polytope,this._target);if(this.postProcessing!=null){good=this.postProcessing(good);other=part.polytope.remove(good)}for(let poly of good.polytopes){parts.push({polytope:poly,state:part.state,done:true})}for(let poly of other.polytopes){parts.push({polytope:poly,state:part.state,done:false})}}}this._parts=parts}_update(){while(true){const hasChanged=this._updateStep();if(!hasChanged)break}}_updateStep(){const newTarget=Array.from(this.reach.polytopes);let hasChanged=false;for(let part of this._parts){if(part.done){newTarget.push(part.polytope);continue}const actR=this.lss.actR(part.polytope,this._target);if(!actR.isEmpty){part.done=true;newTarget.push(part.polytope);hasChanged=true}}if(this.expandTarget){this._target=_geometry.Union.from(newTarget,this.lss.dim).simplify()}return hasChanged}}class TransitionRefinery extends Refinery{constructor(system,objective,results,origin,target,layers,settings){super(system,objective,results);const lss=system.lss;const bad=[];const good=[];const todo=new Map;for(let x of system.states.values()){const qNext=this._qNext(x,origin);const result=this._getResult(x);if(x.isOuter||result.no.has(origin)){bad.push(x.polytope)}else if(result.yes.has(origin)){good.push(x.polytope)}else if(qNext===origin){todo.set(x,x.polytope);if(origin===target)good.push(x.polytope)}else if(qNext===target){good.push(x.polytope)}else{bad.push(x.polytope)}}this._problems=[];const avoid=_geometry.Union.from(bad,lss.dim).simplify();let reach=_geometry.Union.from(good,lss.dim).simplify();if(layers==null){this._problems.push(new RobustReachabilityProblem(lss,todo,reach,avoid,settings))}else{const uu=lss.uu.scale(layers.scaling);for(let i=1;i<=layers.range[1];i++){const layer=this._generateLayer(reach,uu,layers.generator);if(layers.range[0]<=i){const layerTodo=new Map;for(let[state,region]of todo){const intersection=region.intersect(layer).simplify();if(!intersection.isEmpty){layerTodo.set(state,intersection);todo.set(state,region.remove(intersection).simplify())}}if(layerTodo.size===0)break;this._problems.push(new RobustReachabilityProblem(lss,layerTodo,reach,avoid,settings))}reach=layer.remove(avoid).simplify()}}this._updatePartitionCache()}_generateLayer(target,control,generator){const lss=this.system.lss;let layer;if(generator==="PreR"){layer=lss.preR(lss.xx,control,target)}else if(generator==="Pre"){layer=lss.pre(lss.xx,control,target)}else throw new _tools.NotImplementedError("layer generator '"+generator+"' does not exist");return layer.union(target).simplify()}_updatePartitionCache(){const partitions=new Map;for(let problem of this._problems){for(let[state,region]of problem.partitions){const existing=partitions.get(state);partitions.set(state,existing==null?region:existing.union(region))}}this._partitions=new Map;for(let[state,region]of partitions){const rest=state.polytope.remove(region).simplify();this._partitions.set(state,region.union(rest))}}iterate(n){for(let problem of this._problems){problem.iterate(n==null?1:n)}this._updatePartitionCache();return this}partition(x){const partition=this._partitions.get(x);return partition==null?x.polytope:partition}}exports.TransitionRefinery=TransitionRefinery;

},{"./geometry.js":3,"./linalg.js":5,"./system.js":10,"./tools.js":11}],9:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.SnapshotTree=void 0;var _game=require("./game.js");var _system=require("./system.js");var _tools=require("./tools.js");class SnapshotTree{constructor(){this._id=0;this._snapshots=new Map;this._current=null;this._tree=new Map}static deserialize(json){const tree=new SnapshotTree;for(let id of json.ids){const[snapshot,children]=json.snapshots[id];tree._snapshots.set(id,_tools.obj.clone(snapshot));tree._tree.set(id,Array.from(children));if(tree._id<=id){tree._id=id+1}}if(json.root!=null){tree._tree.set(null,[json.root])}if(json.current!=null){tree.select(json.current)}return tree}get size(){return this._snapshots.size}get current(){return(0,_tools.just)(this._current,"Cannot obtain current snapshot ID from SnapshotTree: no snapshot has been taken yet")}get root(){const nullChildren=(0,_tools.just)(this._tree.get(null),"Cannot obtain root of SnapshotTree: no snapshot has been taken yet");if(nullChildren.length!==1)throw new Error("Illegal state of SnapshotTree: null node must not have multiple children");return nullChildren[0]}getSnapshot(id){if(id==null)id=this.current;return(0,_tools.just)(this._snapshots.get(id),"A snapshot with ID "+id+" does not exist")}getSystem(id){return _system.AbstractedLSS.deserialize(this.getSnapshot(id).system)}getAnalysis(id){const snapshot=this.getSnapshot(id);return snapshot.analysis==null?null:_game.AnalysisResults.deserialize(snapshot.analysis)}getName(id){return this.getSnapshot(id).name}getChildren(id){if(id==null)id=this.current;if(!this._snapshots.has(id))throw new Error("A snapshot with ID "+id+" does not exist");const children=this._tree.get(id);return children==null?[]:children}getNumberOfStates(id){return this.getSnapshot(id).system.states.filter(_=>!_.isOuter).length}take(name,system,analysis,includeGraph){const id=this._id++;this._snapshots.set(id,{name:name,system:system.serialize(includeGraph),analysis:analysis==null?null:analysis.serialize()});const parent=this._current;const children=this._tree.get(parent);if(children==null){this._tree.set(parent,[id])}else{if(parent==null&&children.length>0)throw new Error("Illegal state of SnapshotTree: null node must not have multiple children");children.push(id)}this.select(id);return id}select(id){if(!this._snapshots.has(id))throw new Error("A snapshot with ID "+id+" does not exist");this._current=id}rename(id,name){const snapshot=(0,_tools.just)(this._snapshots.get(id),"A snapshot with ID "+id+" does not exist");snapshot.name=name}serialize(includeGraph){const ids=Array.from(this._snapshots.keys());const snapshots=[];for(let id of ids){const snapshot=_tools.obj.clone(this.getSnapshot(id));if(includeGraph!==true){snapshot.system=_system.AbstractedLSS.deserialize(snapshot.system).serialize(false)}snapshots[id]=[snapshot,Array.from(this.getChildren(id))]}return{ids:ids,snapshots:snapshots,root:ids.length===0?null:this.root,current:this._current}}}exports.SnapshotTree=SnapshotTree;

},{"./game.js":2,"./system.js":10,"./tools.js":11}],10:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.itemizedOperatorPartition=itemizedOperatorPartition;exports.ActionSupport=exports.Action=exports.State=exports.AbstractedLSS=exports.LSS=void 0;var _geometry=require("./geometry.js");var linalg=_interopRequireWildcard(require("./linalg.js"));var _tools=require("./tools.js");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}}newObj.default=obj;return newObj}}function itemizedOperatorPartition(items,operator){const parts=[];for(let item of items){const newParts=[];let remaining=operator(item);for(let part of parts){if(remaining.isEmpty){break}const common=remaining.intersect(part.region);if(!common.isEmpty){const notCommon=part.region.remove(common);if(notCommon.isEmpty){part.items.push(item)}else{part.region=notCommon;newParts.push({region:common,items:part.items.concat([item])})}remaining=remaining.remove(common)}}if(!remaining.isEmpty){newParts.push({region:remaining,items:[item]})}parts.push(...newParts)}return parts}class LSS{constructor(A,B,stateSpace,randomSpace,controlSpace){this.A=A;this.B=B;this.xx=stateSpace;this.ww=randomSpace;this.uu=controlSpace;this.dim=stateSpace.dim;this.oneStepReachable=this.post(stateSpace,controlSpace);this.xxExt=stateSpace.union(this.oneStepReachable).simplify()}static deserialize(json){return new LSS(json.A,json.B,_geometry.Polytope.deserialize(json.stateSpace),_geometry.Polytope.deserialize(json.randomSpace),_geometry.Polytope.deserialize(json.controlSpace))}get extent(){return this.xxExt.extent}eval(x,u,w){return linalg.add(linalg.add(linalg.apply(this.A,x),linalg.apply(this.B,u)),w)}post(x,us){const xvs=x.vertices;const wvs=this.ww.vertices;const posts=[];for(let u of us.polytopes){const Bupws=linalg.minkowski.axpy(this.B,u.vertices,wvs);posts.push(_geometry.Polytope.ofDim(this.dim).hull(linalg.minkowski.axpy(this.A,xvs,Bupws)))}return _geometry.Union.from(posts,this.dim).simplify()}pre(x,us,ys){const pres=[];for(let u of us.polytopes){const Bupws=linalg.minkowski.axpy(this.B,u.vertices,this.ww.vertices);for(let y of ys.polytopes){const pre=_geometry.Polytope.ofDim(this.dim).hull(linalg.minkowski.xmy(y.vertices,Bupws));pres.push(x.intersect(pre.applyRight(this.A)))}}return _geometry.Union.from(pres,this.dim).simplify()}preR(x,us,ys){const pontrys=ys.pontryagin(this.ww);if(pontrys.isEmpty){return _geometry.Polytope.ofDim(x.dim).empty()}const prers=[];for(let u of us.polytopes){const Bus=u.vertices.map(uv=>linalg.apply(this.B,uv));for(let pontry of pontrys.polytopes){const poly=_geometry.Polytope.ofDim(this.dim).hull(linalg.minkowski.xmy(pontry.vertices,Bus));prers.push(x.intersect(poly.applyRight(this.A)))}}return _geometry.Union.from(prers,this.dim).simplify()}attr(x,us,ys){return x.remove(this.preR(x,us,this.xxExt.remove(ys)))}attrR(x,us,ys){return x.remove(this.pre(x,us,this.xxExt.remove(ys)))}act(x,y){const Axpw=_geometry.Polytope.ofDim(this.dim).hull(linalg.minkowski.axpy(this.A,x.vertices,this.ww.vertices));return y.minkowski(Axpw.invert()).applyRight(this.B).intersect(this.uu)}actR(x,y){const Axpw=_geometry.Polytope.ofDim(this.dim).hull(linalg.minkowski.axpy(this.A,x.vertices,this.ww.vertices));return y.pontryagin(Axpw).applyRight(this.B).intersect(this.uu)}zNonZero(xs){return xs.minkowski(this.ww.invert()).simplify()}zOne(xs){return xs.pontryagin(this.ww)}decompose(predicates,predicateLabels){const system=new AbstractedLSS(this);const outer=this.oneStepReachable.remove(this.xx);for(let polytope of outer.polytopes){system.newState(polytope,true)}predicateLabels=predicateLabels==null?predicates.map(_=>""):predicateLabels;for(let[label,predicate]of _tools.arr.zip2(predicateLabels,predicates)){if(label.length>0)system.predicates.set(label,predicate)}const partition=itemizedOperatorPartition(_tools.arr.zip2(predicateLabels,predicates),([label,predicate])=>this.xx.split(predicate)[0]);for(let part of partition){if(part.region.polytopes.length!==1)throw new Error("State space was not split properly by linear predicates");system.newState(part.region.polytopes[0],false,part.items.map(_=>_[0]).filter(_=>_.length>0))}let leftOverPoly=this.xx;for(let predicate of predicates){leftOverPoly=leftOverPoly.split(predicate)[1]}if(!leftOverPoly.isEmpty){system.newState(leftOverPoly,false,[])}return system}serialize(){return{A:this.A,B:this.B,stateSpace:this.xx.serialize(),randomSpace:this.ww.serialize(),controlSpace:this.uu.serialize()}}}exports.LSS=LSS;class AbstractedLSS{constructor(lss){this.lss=lss;this.states=new Map;this.predicates=new Map;this._epsPolytope=lss.ww.scale(0.1);this._labelNum=0}static deserialize(json){const system=new AbstractedLSS(LSS.deserialize(json.lss));system._labelNum=json._labelNum;for(let label in json.predicates){system.predicates.set(label,_geometry.Halfspace.deserialize(json.predicates[label]))}for(let jsonState of json.states){const state=State.deserialize(jsonState,system,false);system.states.set(state.label,state)}for(let jsonState of json.states){const state=system.getState(jsonState.label);state._restoreActions(jsonState.actions)}return system}get extent(){return this.lss.extent}newState(polytope,isOuter,predicates){const label=this.genLabel();const state=new State(this,label,polytope,isOuter,predicates);this.states.set(label,state);return state}genLabel(){this._labelNum++;const label="X"+this._labelNum.toString();return this.states.has(label)?this.genLabel():label}getState(label){return(0,_tools.just)(this.states.get(label),"A state with label '"+label+"' does not exist")}getPredicate(label){return(0,_tools.just)(this.predicates.get(label),"A predicate with label '"+label+"' does not exist")}stateOf(x){for(let state of this.states.values()){if(state.polytope.contains(x)){return state}}return null}refine(partitions){const refined=new Map;for(let[state,partition]of partitions){if(state._isEpsSmall)continue;if(!state.polytope.isSameAs(partition))throw new Error("Partition for state "+state.label+" does not cover the entire state");if(partition.polytopes.length===1)continue;const newStates=new Set;for(let poly of partition.polytopes){newStates.add(this.newState(poly,state.isOuter,state.predicates))}refined.set(state,newStates);this.states.delete(state.label)}this.resetActions(new Set(refined.keys()));return refined}resetActions(targets){for(let state of this.states.values()){state.resetActions(targets)}}post(x,us){return this.lss.post(x.polytope,us)}pre(x,us,ys){return this.lss.pre(x.polytope,us,_geometry.Union.from(Array.from(ys,y=>y.polytope),this.lss.dim))}preR(x,us,ys){return this.lss.preR(x.polytope,us,_geometry.Union.from(Array.from(ys,y=>y.polytope),this.lss.dim))}attr(x,us,ys){return this.lss.attr(x.polytope,us,_geometry.Union.from(Array.from(ys,y=>y.polytope),this.lss.dim))}attrR(x,us,ys){return this.lss.attrR(x.polytope,us,_geometry.Union.from(Array.from(ys,y=>y.polytope),this.lss.dim))}act(x,y){return this.lss.act(x.polytope,y.polytope)}actR(x,y){return this.lss.actR(x.polytope,y.polytope)}zNonZero(xs){return this.lss.zNonZero(_geometry.Union.from(Array.from(xs,x=>x.polytope),this.lss.dim))}zOne(xs){return this.lss.zOne(_geometry.Union.from(Array.from(xs,x=>x.polytope),this.lss.dim))}get stateLabels(){return new Set(this.states.keys())}predicateLabelsOf(stateLabel){return(0,_tools.just)(this.states.get(stateLabel),"State with label '"+stateLabel+"' not found.").predicates}actionCountOf(stateLabel){return(0,_tools.just)(this.states.get(stateLabel),"State with label '"+stateLabel+"' not found.").actions.length}supportCountOf(stateLabel,actionId){return(0,_tools.just)(this.states.get(stateLabel),"State with label '"+stateLabel+"' not found.").actions[actionId].supports.length}targetLabelsOf(stateLabel,actionId,supportId){const state=(0,_tools.just)(this.states.get(stateLabel),"State with label '"+stateLabel+"' not found.");return new Set(_tools.iter.map(s=>s.label,state.actions[actionId].supports[supportId].targets))}serializeGameGraph(analysis){const states={};for(let[label,state]of this.states){const result=analysis==null?null:analysis.get(label);let actions=[];if(result==null||result.maybe.size!==0){actions=state.actions.map(action=>action.supports.map(support=>Array.from(support.targets,target=>target.label)))}states[label]={predicates:Array.from(state.predicates),actions:actions}}return states}serialize(includeGraph){const predicates={};for(let[label,predicate]of this.predicates){predicates[label]=predicate.serialize()}return{lss:this.lss.serialize(),predicates:predicates,states:Array.from(_tools.iter.map(_=>_.serialize(includeGraph),this.states.values())),_labelNum:this._labelNum}}}exports.AbstractedLSS=AbstractedLSS;class State{constructor(system,label,polytope,isOuter,predicates){this.system=system;this.label=label;this.polytope=polytope;this.isOuter=isOuter;this.predicates=new Set(predicates==null?[]:predicates);this._actions=null;this.resetActions();this._isEpsSmall=polytope.pontryagin(system._epsPolytope).isEmpty}static deserialize(json,system,restoreActions){const polytope=_geometry.Polytope.deserialize(json.polytope);const state=new State(system,json.label,polytope,json.isOuter,json.predicates);if(restoreActions==null||restoreActions){state._restoreActions(json.actions)}return state}_restoreActions(json){if(json==null)return;this._actions=json.map(_=>Action.deserialize(_,this));const reachable=new Set;for(let action of this._actions){for(let target of action.targets){reachable.add(target)}}this._reachable=reachable}get actions(){if(this._actions!=null){return this._actions}else{const op=target=>this.act(target);this._reachable=this.oneStepReachable(this.system.lss.uu);this._actions=itemizedOperatorPartition(this._reachable,op).map(part=>new Action(this,part.items,part.region.simplify()));return this.actions}}post(us){return this.system.post(this,us)}pre(us,ys){return this.system.pre(this,us,ys)}preR(us,ys){return this.system.preR(this,us,ys)}attr(us,ys){return this.system.attr(this,us,ys)}attrR(us,ys){return this.system.attrR(this,us,ys)}oneStepReachable(us){const post=this.post(us);const out=new Set;for(let state of this.system.states.values()){if(!post.intersect(state.polytope).isEmpty)out.add(state)}return out}act(y){return this.system.act(this,y)}actR(y){return this.system.actR(this,y)}zNonZero(){return this.system.zNonZero([this])}zOne(){return this.system.zOne([this])}refine(partition){return this.system.refine(new Map([[this,partition]]))}resetActions(targets){if(this._actions==null||targets==null||_tools.sets.doIntersect(this._reachable,targets)){this._actions=this.isOuter?[]:null;this._reachable=new Set}}serialize(includeGraph){let actions=null;if(includeGraph!=null&&includeGraph&&this._actions!=null){actions=this._actions.map(_=>_.serialize(includeGraph))}return{label:this.label,polytope:this.polytope.serialize(),isOuter:this.isOuter,predicates:Array.from(this.predicates),actions:actions}}}exports.State=State;class Action{constructor(origin,targets,controls){this.origin=origin;this.targets=new Set(targets);this.controls=controls;this._supports=null}static deserialize(json,origin){const targets=json.targets.map(_=>origin.system.getState(_));const action=new Action(origin,targets,_geometry.Union.deserialize(json.controls));if(json.supports!=null){action._supports=json.supports.map(_=>ActionSupport.deserialize(_,action))}return action}get supports(){if(this._supports!=null){return this._supports}else{const lss=this.origin.system.lss;const zNonZeros=itemizedOperatorPartition(this.targets,_=>_.zNonZero());const zOnes=lss.zOne(_geometry.Union.from(Array.from(this.targets,_=>_.polytope)));this._supports=zNonZeros.map(part=>{const zs=part.region.intersect(zOnes).polytopes;const prePs=[];for(let u of this.controls.polytopes){const Bus=u.vertices.map(_=>linalg.apply(lss.B,_));for(let z of zs){const preP=_geometry.Polytope.ofDim(lss.dim).hull(linalg.minkowski.xmy(z.vertices,Bus));prePs.push(preP.applyRight(lss.A))}}const preP=prePs.length===0?_geometry.Polytope.ofDim(lss.dim).empty():_geometry.Union.from(prePs);return new ActionSupport(this,part.items,preP.intersect(this.origin.polytope).simplify())}).filter(_=>!_.origins.isEmpty);return this.supports}}serialize(includeGraph){let supports=null;if(includeGraph!=null&&includeGraph&&this._supports!=null){supports=this._supports.map(_=>_.serialize())}return{targets:Array.from(this.targets,_=>_.label),controls:this.controls.toUnion().serialize(),supports:supports}}}exports.Action=Action;class ActionSupport{constructor(action,targets,origins){this.action=action;this.targets=new Set(targets);this.origins=origins}static deserialize(json,action){const targets=json.targets.map(x=>action.origin.system.getState(x));return new ActionSupport(action,targets,_geometry.Union.deserialize(json.origins))}serialize(){return{targets:Array.from(this.targets,x=>x.label),origins:this.origins.toUnion().serialize()}}}exports.ActionSupport=ActionSupport;

},{"./geometry.js":3,"./linalg.js":5,"./tools.js":11}],11:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.just=just;exports.xor=xor;exports.replaceAll=replaceAll;exports.hashString=hashString;exports.n2s=n2s;exports.t2s=t2s;exports.UniqueCollection=exports.ObservableMixin=exports.obj=exports.sets=exports.arr=exports.iter=exports.ValueError=exports.NotImplementedError=void 0;class NotImplementedError extends Error{}exports.NotImplementedError=NotImplementedError;class ValueError extends Error{}exports.ValueError=ValueError;function just(val,err){if(val==null)throw new ValueError(err==null?"Value is null but shouldn't be":err);return val}function xor(p,q){return p?!q:q}const iter={some:function(xs){for(let x of xs){if(x)return true}return false},every:function(xs){for(let x of xs){if(!x)return false}return true},sum:function(xs){let s=0;for(let x of xs){s+=x}return s},count:function(xs){let c=0;for(let x of xs){c++}return c},map:function*(fun,xs){for(let x of xs){yield fun(x)}},filter:function*(test,xs){for(let x of xs){if(test(x)){yield x}}},chain:function*(...xss){for(let xs of xss){yield*xs}},argmax:function(value,xs){let maxArg=null;let maxVal=-Infinity;for(let x of xs){const val=value(x);if(val>maxVal){maxArg=x;maxVal=val}}return maxArg}};exports.iter=iter;const arr={zip2map:function(fun,xs,ys){let zs=[];for(let i=0;i<xs.length;i++){zs[i]=fun(xs[i],ys[i])}return zs},zip2:function(xs,ys){return arr.zip2map((x,y)=>[x,y],xs,ys)},cyc2map:function(fun,xs){if(xs.length==0)return[];const zs=[];for(let i=0;i<xs.length-1;i++){zs.push(fun(xs[i],xs[i+1]))}zs.push(fun(xs[xs.length-1],xs[0]));return zs},intersperse:function(delim,items){const out=[];for(let item of items){out.push(item);out.push(delim)}out.pop();return out},sample:function(items){return items[Math.floor(Math.random()*items.length)]}};exports.arr=arr;const sets={areEqual:function(xs,ys){if(xs.size!==ys.size){return false}for(let y of ys){if(!xs.has(y)){return false}}return true},isSubset:function(subs,sups){for(let sub of subs){if(!sups.has(sub)){return false}}return true},doIntersect:function(xs,ys){for(let x of xs){if(ys.has(x)){return true}}return false},union:function(...xss){return new Set(iter.chain(...xss))},intersection:function(xs,ys){return new Set(iter.filter(x=>ys.has(x),xs))},difference:function(xs,ys){return new Set(iter.filter(x=>!ys.has(x),xs))},map:function(fun,xs){return new Set(iter.map(fun,xs))},filter:function(fun,xs){return new Set(iter.filter(fun,xs))}};exports.sets=sets;const obj={forEach:function(fun,kvs){for(let key in kvs){if(kvs.hasOwnProperty(key)){fun(key,kvs[key])}}},map2Array:function(fun,kvs){const out=[];obj.forEach((key,val)=>{out.push(fun(key,val))},kvs);return out},map:function(fun,kvs){const out={};obj.forEach((key,val)=>{out[key]=fun(key,val)},kvs);return out},values:function(kvs){return obj.map2Array((k,v)=>v,kvs)},keys:function(kvs){return obj.map2Array((k,v)=>k,kvs)},merge:function(...kvss){const out={};for(let kvs of kvss){obj.forEach((key,val)=>{out[key]=val},kvs)}return out},clone:function(kvs){return Object.assign({},kvs)},fromMap:function(fun,ks){const out={};for(let k of ks){out[k]=fun(k)}return out}};exports.obj=obj;function replaceAll(haystack,needle,substitute){return haystack.split(needle).join(substitute)}function hashString(s){let hash=0;if(s.length!==0){for(let i=0;i<s.length;i++){hash=(hash<<5)-hash+s.charCodeAt(i);hash|=0}}return hash}function n2s(x,places){if(places==null)places=5;return x.toFixed(places).replace(/\.?0*$/,"")}const MSINS=1000;const MSINM=60*MSINS;const MSINH=60*MSINM;function t2s(x){const hor=Math.floor(x/MSINH);const min=Math.floor((x-hor*MSINH)/MSINM);const sec=Math.floor((x-hor*MSINH-min*MSINM)/MSINS);if(sec===0&&min===0&&hor===0){return(x/1000).toFixed(3)+" s"}else{const parts=[];if(hor>0)parts.push(hor+" h");if(min>0)parts.push(min+" min");if(sec>0)parts.push(sec+" s");return parts.join(" ")}}class ObservableMixin{constructor(){this.observers=[];this.isSendingNotifications=true}attach(observer,callImmediately){this.observers.push(observer);if(callImmediately===true)observer()}detach(observer){let idx=this.observers.indexOf(observer);if(idx<0){throw new Error("observer was not attached")}this.observers.splice(idx,1)}notify(event){if(this.isSendingNotifications){for(let observer of this.observers){observer(event)}}}}exports.ObservableMixin=ObservableMixin;class UniqueCollection{constructor(hash,areEqual){this._hash=hash;this._areEqual=areEqual;this._buckets=new Map;this._size=0}get size(){return this._size}has(value){const hash=this._hash(value);const bucket=this._buckets.get(hash);if(bucket!=null){for(let item of bucket){if(this._areEqual(item,value)){return true}}}return false}take(value){const hash=this._hash(value);let bucket=this._buckets.get(hash);if(bucket==null){bucket=this._newBucket(hash);bucket.add(value);this._size++;return value}for(let item of bucket){if(this._areEqual(item,value)){return item}}bucket.add(value);this._size++;return value}_newBucket(hash){const bucket=new Set;this._buckets.set(hash,bucket);return bucket}*[Symbol.iterator](){for(let values of this._buckets.values()){yield*values}}}exports.UniqueCollection=UniqueCollection;

},{}],12:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.Communicator=void 0;class Communicator{constructor(idPrefix){this._idPrefix=idPrefix;this._idCounter=0;this._callbacks=new Map;this._handlers=new Map;this._host=null}get host(){if(this._host==null)throw new Error("No host attached");return this._host}set host(host){this._host=host;this._host.onmessage=e=>this._receive(e.data)}request(kind,data){const message={kind:kind,data:data,id:this._genId()};return new Promise((resolve,reject)=>{this._callbacks.set(message.id,answer=>{this._callbacks.delete(message.id);if(answer.kind==="error"){reject(new Error(answer.data))}else{resolve(answer.data)}});this.host.postMessage(message)})}onRequest(kind,handler){this._handlers.set(kind,handler)}postAnswer(msg,data){this.host.postMessage({id:msg.id,kind:msg.kind,data:data})}postError(msg,data){this.host.postMessage({id:msg.id,kind:"error",data:data})}_genId(){return this._idPrefix+this._idCounter++}_receive(raw){if(typeof raw==="object"&&raw!=null){const message={id:"",kind:"",data:null};if(raw.hasOwnProperty("id")&&typeof raw.id==="string"){message.id=raw.id}else{throw new Error("No/Invalid id in message '"+JSON.stringify(raw)+"'")}if(raw.hasOwnProperty("kind")&&typeof raw.kind==="string"){message.kind=raw.kind}else{throw new Error("No/Invalid kind in message '"+JSON.stringify(raw)+"'")}if(raw.hasOwnProperty("data")){message.data=raw.data}const callback=this._callbacks.get(message.id);if(callback!=null){callback(message);return}const handler=this._handlers.get(message.kind);if(handler!=null){try{this.postAnswer(message,handler(message.data))}catch(err){this.postError(message,err.message)}return}throw new Error("No handler for request of kind '"+message.kind+"'")}else{throw new Error("Received invalid message: '"+JSON.stringify(raw)+"'")}}}exports.Communicator=Communicator;

},{}]},{},[4]);
