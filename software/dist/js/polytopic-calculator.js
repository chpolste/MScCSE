(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.renderTeX=renderTeX;exports.create=create;exports.createSVG=createSVG;exports.nodeify=nodeify;exports.setAttributes=setAttributes;exports.addEventListeners=addEventListeners;exports.removeChildren=removeChildren;exports.appendChildren=appendChildren;exports.replaceChildren=replaceChildren;exports.appendAfter=appendAfter;exports.createButton=createButton;exports.fromChildElement=fromChildElement;exports.setCursor=setCursor;exports.popupDownload=popupDownload;exports.infoBox=infoBox;exports.snLabel=exports.Keybindings=exports.SVGNS=exports.TEXTAREA=exports.TABLE=exports.SPAN=exports.SELECT=exports.P=exports.OPTION=exports.LABEL=exports.INPUT=exports.H3=exports.FORM=exports.DIV=exports.BUTTON=exports.A=void 0;function renderTeX(tex,element){katex.render(tex,element,{throwOnError:false});return element}function create(tag,attributes,children){const node=document.createElement(tag);if(attributes!=null)setAttributes(node,attributes);if(children!=null)appendChildren(node,children);return node}const A=(a,c)=>create("a",a,c);exports.A=A;const BUTTON=(a,c)=>create("button",a,c);exports.BUTTON=BUTTON;const DIV=(a,c)=>create("div",a,c);exports.DIV=DIV;const FORM=(a,c)=>create("form",a,c);exports.FORM=FORM;const H3=(a,c)=>create("h3",a,c);exports.H3=H3;const INPUT=(a,c)=>create("input",a,c);exports.INPUT=INPUT;const LABEL=(a,c)=>create("label",a,c);exports.LABEL=LABEL;const OPTION=(a,c)=>create("option",a,c);exports.OPTION=OPTION;const P=(a,c)=>create("p",a,c);exports.P=P;const SELECT=(a,c)=>create("select",a,c);exports.SELECT=SELECT;const SPAN=(a,c)=>create("span",a,c);exports.SPAN=SPAN;const TABLE=(a,c)=>create("table",a,c);exports.TABLE=TABLE;const TEXTAREA=(a,c)=>create("textarea",a,c);exports.TEXTAREA=TEXTAREA;const SVGNS="http://www.w3.org/2000/svg";exports.SVGNS=SVGNS;function createSVG(tag,attributes,children){const node=document.createElementNS(SVGNS,tag);if(attributes!=null)setAttributes(node,attributes);if(children!=null)appendChildren(node,children);return node}function nodeify(item){return typeof item==="string"?document.createTextNode(item):item}function setAttributes(node,attributes){for(let name in attributes){node.setAttribute(name,attributes[name])}}function addEventListeners(node,handlers){for(let event in handlers){node.addEventListener(event,handlers[event])}}function removeChildren(node){while(node.firstChild){node.removeChild(node.firstChild)}}function appendChildren(parentNode,children){for(let child of children){parentNode.appendChild(nodeify(child))}}function replaceChildren(parentNode,childNodes){let i=0;for(let childNode of childNodes){const oldNode=parentNode.childNodes[i];const newNode=nodeify(childNode);if(oldNode!=null){parentNode.replaceChild(newNode,oldNode)}else{parentNode.appendChild(newNode)}i++}while(parentNode.childNodes[i]!=null){parentNode.removeChild(parentNode.childNodes[i])}}function appendAfter(parent,before,after){const sibling=before.nextSibling;if(sibling==null){parent.appendChild(nodeify(after))}else{parent.insertBefore(nodeify(after),sibling)}}function createButton(a,c,f){const button=BUTTON(a,c);button.addEventListener("click",f);return button}function fromChildElement(node,e){let tgt=e.relatedTarget;if(tgt instanceof Node){while(tgt!=null&&tgt!==node){tgt=tgt.parentNode}}return tgt===node}function setCursor(cursor){let body=document.body;if(body!=null){body.style.cursor=cursor}}function popupDownload(content,filename){const body=document.body;if(body!=null){const a=document.createElement("a");a.href=content;a.setAttribute("download",filename);body.appendChild(a);a.click();body.removeChild(a)}else{window.open(content)}}class Keybindings{constructor(){this.bindings=new Map;document.addEventListener("keypress",e=>this.keyPress(e))}bind(key,callback){this.bindings.set(key,callback)}keyPress(event){const callback=this.bindings.get(event.key);if(event.target===document.body&&!event.ctrlKey&&!event.altKey&&callback!=null){callback(event)}}}exports.Keybindings=Keybindings;const SPLIT_LABEL_REGEX=/^([a-zA-Z]+)(\d+)$/;const NUM_TSPAN_ATTRS={"dy":"2","font-size":"0.8em"};const snLabel={split:function(text){const match=SPLIT_LABEL_REGEX.exec(text);return match==null?[text,""]:[match[1],match[2]]},toTeX:function(text){const[name,num]=snLabel.split(text);return num.length===0?name:name+"_"+num},toHTML:function(text){const[name,num]=snLabel.split(text);return SPAN({},num.length===0?[name]:[name,create("sub",{},[num])])},toSVG:function(text){const[name,num]=snLabel.split(text);return createSVG("text",{},num.length===0?[name]:[name,createSVG("tspan",NUM_TSPAN_ATTRS,[num])])}};exports.snLabel=snLabel;function infoBox(contentID){const node=DIV({"class":"info-button"},["?"]);node.addEventListener("mouseover",e=>{const content=document.getElementById(contentID);if(content!=null){content.style.display="block";content.style.top=String(node.offsetTop)+"px";content.style.left=String(node.offsetLeft-content.offsetWidth-5)+"px"}});node.addEventListener("mouseout",e=>{const content=document.getElementById(contentID);if(content!=null){content.style.display="none"}});return node}

},{}],2:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.autoProjection=autoProjection;exports.Horizontal1D=exports.Cartesian2D=exports.Layer=exports.Figure=void 0;var linalg=_interopRequireWildcard(require("./linalg.js"));var _tools=require("./tools.js");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}}newObj.default=obj;return newObj}}class Figure extends _tools.ObservableMixin{constructor(){super();this.layers=[]}newLayer(style){let layer=new Layer(this,style);this.layers.push(layer);this.notify({event:"newLayer",layer:layer});return layer}}exports.Figure=Figure;class Layer extends _tools.ObservableMixin{constructor(figure,style){super();this.figure=figure;this._shapes=[];this.style=style!=null?style:{}}get shapes(){return this._shapes}set shapes(shapes){this._shapes=Array.from(shapes);this.notify()}}exports.Layer=Layer;function largestPowerOf10In(x){return Math.pow(10,Math.floor(Math.log10(x)))}function linearTicks(min,max,n){const diff=(max-min)/n;const lp10=largestPowerOf10In(diff);const increment=Math.ceil(diff/lp10)*lp10;let init;if(min<=0&&0<=max){init=0}else if(max-min>lp10*10){init=Math.ceil(min/lp10/10)*lp10*10}else{init=Math.ceil(min/lp10)*lp10}const ticks=[];for(let i=-n;i<=n;i++){const tick=init+i*increment;if(min<tick&&tick<max)ticks.push(tick)}return ticks}class Cartesian2D{constructor(limX,limY){this.minX=limX[0];this.maxX=limX[1];this.minY=limY[0];this.maxY=limY[1]}get center(){return[(this.minX+this.maxX)/2,(this.minY+this.maxY)/2]}fwd(coords){let[x,y]=coords;return[(x-this.minX)/(this.maxX-this.minX),(y-this.minY)/(this.maxY-this.minY)]}bwd(coords){let[x,y]=coords;return[x*(this.maxX-this.minX)+this.minX,y*(this.maxY-this.minY)+this.minY]}project(shape){let primitives=[];if(shape.kind==="polytope"){primitives.push({kind:"polygon",points:shape.vertices.map(vertex=>this.fwd(vertex))})}else if(shape.kind==="arrow"){primitives.push({kind:"arrow",origin:this.fwd(shape.origin),target:this.fwd(shape.target)})}else if(shape.kind==="label"){primitives.push({kind:"label",coords:this.fwd(shape.coords),text:shape.text})}else if(shape.kind==="marker"){primitives.push({kind:"marker",coords:this.fwd(shape.coords),size:shape.size})}else if(shape.kind==="halfspace"){const normal=shape.normal;const offset=shape.offset;const cs=[[this.minX,this.minY],[this.minX,this.maxY],[this.maxX,this.maxY],[this.maxX,this.minY]];const csIn=cs.map(v=>linalg.dot(v,normal)-offset<linalg.TOL);const vertices=[];if(csIn[0])vertices.push(cs[0]);if((0,_tools.xor)(csIn[0],csIn[1]))vertices.push([cs[0][0],(offset-normal[0]*cs[0][0])/normal[1]]);if(csIn[1])vertices.push(cs[1]);if((0,_tools.xor)(csIn[1],csIn[2]))vertices.push([(offset-normal[1]*cs[1][1])/normal[0],cs[1][1]]);if(csIn[2])vertices.push(cs[2]);if((0,_tools.xor)(csIn[2],csIn[3]))vertices.push([cs[2][0],(offset-normal[0]*cs[2][0])/normal[1]]);if(csIn[3])vertices.push(cs[3]);if((0,_tools.xor)(csIn[3],csIn[0]))vertices.push([(offset-normal[1]*cs[3][1])/normal[0],cs[3][1]]);primitives.push({kind:"polygon",points:vertices.map(v=>this.fwd(v))})}else if(shape.kind==="vectorField"){const s=shape.scaling==null?1:shape.scaling;for(let x of linearTicks(this.minX,this.maxX,shape.n==null?10:shape.n[0])){for(let y of linearTicks(this.minY,this.maxY,shape.n==null?10:shape.n[1])){const o=this.fwd([x,y]);const t=this.fwd(shape.fun([x,y]));primitives.push({kind:"arrow",origin:o,target:linalg.add(o,linalg.sub(t,o).map(_=>s*_))})}}}else if(shape.kind==="state"){const coords=this.fwd(shape.coords);primitives.push({kind:"marker",coords:coords,size:20,style:shape.member.indexOf("E")!==-1?{"stroke-dasharray":"5 3"}:{}});if(shape.member.indexOf("F")!==-1){primitives.push({kind:"marker",coords:coords,size:16})}}else if(shape.kind==="transition"){primitives.push({kind:"arrow",origin:this.fwd(shape.origin),target:this.fwd(shape.target),deltaO:[20,-6],deltaT:[-21,-6]})}else if(shape.kind==="loop"){primitives.push({kind:"loop",coords:this.fwd(shape.coords),angle:shape.angle})}else if(shape.kind==="transitionLabel"){primitives.push({kind:"__label",text:shape.text,p1:this.fwd(shape.origin),p2:this.fwd(shape.target),offset:-17})}else if(shape.kind==="loopLabel"){const[x,y]=shape.coords;const dx=Math.cos(Math.PI*shape.angle/180);const dy=-Math.sin(Math.PI*shape.angle/180);primitives.push({kind:"__label",text:shape.text,p1:this.fwd([x-dx,y-dy]),p2:this.fwd([x+dx,y+dy]),offset:-49})}else{throw new Error("unknown shape kind '"+shape.kind+"' (Cartesian2D)")}return primitives}zoom(factor){let center=this.center;let lengthX=(this.maxX-this.minX)/2;let lengthY=(this.maxY-this.minY)/2;let limX=[center[0]-lengthX*factor,center[0]+lengthX*factor];let limY=[center[1]-lengthY*factor,center[1]+lengthY*factor];return new Cartesian2D(limX,limY)}translate(start,end){let diffX=end[0]-start[0];let diffY=end[1]-start[1];let limX=[this.minX-diffX,this.maxX-diffX];let limY=[this.minY-diffY,this.maxY-diffY];return new Cartesian2D(limX,limY)}getXTicks(n){return linearTicks(this.minX,this.maxX,n).map(t=>[this.fwd([t,0])[0],(0,_tools.n2s)(t)])}getYTicks(n){return linearTicks(this.minY,this.maxY,n).map(t=>[this.fwd([0,t])[1],(0,_tools.n2s)(t)])}}exports.Cartesian2D=Cartesian2D;class Horizontal1D{constructor(lim,ylim){this.minX=lim[0];this.maxX=lim[1];this.minY=ylim==null?0.4:ylim[0];this.maxY=ylim==null?0.6:ylim[1]}get center(){return[(this.minX+this.maxX)/2]}fwd(coords){return[(coords[0]-this.minX)/(this.maxX-this.minX),0.5]}bwd(coords){return[coords[0]*(this.maxX-this.minX)+this.minX]}project(shape){let primitives=[];if(shape.kind==="polytope"){if(shape.vertices.length<2){return[]}let[l,r]=shape.vertices.map(vertex=>this.fwd(vertex));primitives.push({kind:"polygon",points:[[l[0],this.maxY],[l[0],this.minY],[r[0],this.minY],[r[0],this.maxY]]})}else if(shape.kind==="arrow"){primitives.push({kind:"arrow",origin:this.fwd(shape.origin),target:this.fwd(shape.target)})}else if(shape.kind==="label"){primitives.push({kind:"label",coords:this.fwd(shape.coords),text:shape.text})}else if(shape.kind==="marker"){primitives.push({kind:"marker",coords:this.fwd(shape.coords),size:shape.size})}else if(shape.kind==="halfspace"){const normal=shape.normal;const offset=shape.offset;let left=0;let right=1;if(normal[0]<0){left=Math.max(left,this.fwd([-offset])[0])}else{right=Math.min(right,this.fwd([offset])[0])}if(left<right){primitives.push({kind:"polygon",points:[[left,0],[left,1],[right,1],[right,0]]})}}else if(shape.kind==="vectorField"){const s=shape.scaling==null?1:shape.scaling;for(let x of linearTicks(this.minX,this.maxX,shape.n==null?10:shape.n[0])){const o=this.fwd([x]);const t=this.fwd(shape.fun([x]));primitives.push({kind:"arrow",origin:o,target:linalg.add(o,linalg.sub(t,o).map(_=>s*_))})}}else{throw new Error("unknown shape kind '"+shape.kind+"' (Horizontal1D)")}return primitives}zoom(factor){let center=this.center[0];return new Horizontal1D([center-(center-this.minX)*factor,center+(this.maxX-center)*factor],[this.minY,this.maxY])}translate(start,end){let diff=end[0]-start[0];return new Horizontal1D([this.minX-diff,this.maxX-diff],[this.minY,this.maxY])}getXTicks(n){return linearTicks(this.minX,this.maxX,n).map(t=>[this.fwd([t])[0],(0,_tools.n2s)(t)])}getYTicks(n){return[[0.5,"1D"]]}}exports.Horizontal1D=Horizontal1D;const PADDING=1.2;function autoProjection(aspectRatio,...ranges){let dim=ranges.length;if(dim==0){return new Cartesian2D([NaN,NaN],[NaN,NaN])}else if(dim==1){let[min,max]=ranges[0];let radius=(max-min)/2*PADDING;let mid=(min+max)/2;return new Horizontal1D([mid-radius,mid+radius])}else if(dim==2){let[minX,maxX]=ranges[0];let[minY,maxY]=ranges[1];let radiusX=(maxX-minX)/2*PADDING;let radiusY=(maxY-minY)/2*PADDING;let midX=(minX+maxX)/2;let midY=(minY+maxY)/2;let ratio=radiusX/radiusY;let factorX=ratio<aspectRatio?aspectRatio/ratio:1;let factorY=ratio>aspectRatio?ratio/aspectRatio:1;return new Cartesian2D([midX-radiusX*factorX,midX+radiusX*factorX],[midY-radiusY*factorY,midY+radiusY*factorY])}else{throw new Error("dim not supported")}}

},{"./linalg.js":4,"./tools.js":7}],3:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.Union=exports.Polygon=exports.Interval=exports.Polytope=exports.Halfspace=exports.TOL=void 0;var linalg=_interopRequireWildcard(require("./linalg.js"));var _tools=require("./tools.js");var _parser=require("./parser.js");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}}newObj.default=obj;return newObj}}const TOL=linalg.TOL;exports.TOL=TOL;function cartesian(...tuples){let cart=[[]];for(let tuple of tuples){cart=[].concat(...cart.map(xs=>tuple.map(y=>xs.concat([y]))))}return cart}function angleOrder(v){const angle=Math.atan2(v[1],v[0]);return angle===Math.PI?angle-2*Math.PI:angle}function angleCCW(g,h){const det=g[0]*h[1]-g[1]*h[0];const dot=g[0]*h[0]+g[1]*h[1];let angle=Math.atan2(det,dot);if(angle<0){angle=angle+2*Math.PI}return angle===2*Math.PI?0:angle}function isCCWTurn(p,q,r,zero){return(p[0]-r[0])*(q[1]-r[1])-(p[1]-r[1])*(q[0]-r[0])>zero}function reduceHullPart(hull,p,zero){while(hull.length>1&&!isCCWTurn(hull[hull.length-2],hull[hull.length-1],p,zero)){hull.pop()}}function halfplaneIntersection(g,h){const[g0,g1]=g.normal;const[h0,h1]=h.normal;const det=g0*h1-g1*h0;if(Math.abs(det)<TOL){return null}else{return[(h1*g.offset-g1*h.offset)/det,(g0*h.offset-h0*g.offset)/det]}}const hsieParse=(0,_parser.ASTParser)(/\+|-|([0-9\.]+\s*\*?\s*[a-z]?)|[0-9\.]+|[a-z]/,[{op:"+",precedence:20,associativity:-1},{op:"-",precedence:20,associativity:-1},{op:"+",precedence:50,associativity:0},{op:"-",precedence:50,associativity:0}]);function hsieSplit(text){const parts=text.split(/\s*([<>]=?)\s*/);if(parts.length!=3)throw new _parser.ParseError("not a valid inequality (requires exactly one of <=, <, >, >=)");return[hsieParse(parts[0]),parts[1][0],hsieParse(parts[2])]}const hsieNumVarPattern=/^((?:\d+(?:\.\d+)?)|(?:\.\d+))?\s*\*?\s*([a-z])?$/;function hsieTerms(node,flip){if(typeof node==="string"){const match=node.match(hsieNumVarPattern);if(match==null)throw new _parser.ParseError("unrecognized term "+node);return[{coefficient:(flip?-1:1)*(match[1]==null?1:parseFloat(match[1])),variable:match[2]==null?"":match[2]}]}else if(node.op==="-"||node.op==="+"){const isMinus=node.op==="-";const isUnary=node.args.length===1;const out=hsieTerms(node.args[0],isUnary&&isMinus?!flip:flip);if(!isUnary)out.push(...hsieTerms(node.args[1],isMinus?!flip:flip));return out}else{throw new _parser.ParseError("unexpected operator "+node.op)}}class Halfspace{constructor(normal,offset){this.normal=normal;this.offset=offset;this.dim=normal.length}static deserialize(json){return new Halfspace(json.normal,json.offset)}static normalized(normal,offset){let norm=linalg.norm2(normal);if(norm<TOL){offset=offset===0?Infinity:Math.sign(offset)*Infinity;norm=1}return new Halfspace(normal.map(x=>x/norm),offset/norm)}static parse(text,variables){const[lhs,comp,rhs]=hsieSplit(text);const terms=hsieTerms(lhs,comp===">").concat(hsieTerms(rhs,comp==="<"));let offset=0;let normal=new Array(variables.length);normal.fill(0);for(let term of terms){if(term.variable===""){offset-=term.coefficient}else{const idx=variables.indexOf(term.variable);if(idx<0)throw new _parser.ParseError("unexpected variable '"+term.variable+"'");normal[idx]+=term.coefficient}}return Halfspace.normalized(normal,offset)}get isInfeasible(){return this.offset===-Infinity}get isTrivial(){return this.offset===Infinity}applyRight(m){return Halfspace.normalized(linalg.applyRight(m,this.normal),this.offset)}contains(point){linalg.assertEqualDims(this.dim,point.length);return linalg.dot(this.normal,point)-this.offset<TOL}flip(){return new Halfspace(this.normal.map(x=>-x),-this.offset)}isSameAs(other){return linalg.areClose(this.normal,other.normal)&&Math.abs(this.offset-other.offset)<TOL}translate(v){return Halfspace.normalized(this.normal,this.offset+linalg.dot(this.normal,v))}serialize(){return{normal:this.normal,offset:this.offset}}}exports.Halfspace=Halfspace;class Polytope{constructor(vertices,halfspaces){if(this.constructor.name==="Polytope"){throw new TypeError("must not instanciate Polytope")}this._vertices=vertices;this._halfspaces=halfspaces;this._isEmpty=null}static deserialize(json){if(json.dim===1)return new Interval(json.vertices,null);if(json.dim===2)return new Polygon(json.vertices,null);throw new _tools.NotImplementedError}static empty(){throw new _tools.NotImplementedError}static hull(ps){throw new _tools.NotImplementedError}static intersection(hs){throw new _tools.NotImplementedError}static noredund(hs){throw new _tools.NotImplementedError}static ofDim(dim){if(dim===1)return Interval;if(dim===2)return Polygon;throw new _tools.NotImplementedError}get boundingBox(){if(this.isEmpty)return this;let bbox=cartesian(...this.extent);return this.constructor.hull(bbox)}get centroid(){throw new _tools.NotImplementedError}get extent(){let mins=new Array(this.dim);mins.fill(Infinity);let maxs=new Array(this.dim);maxs.fill(-Infinity);for(let vertex of this.vertices){vertex.map((x,i)=>{if(x<mins[i]){mins[i]=x}if(x>maxs[i]){maxs[i]=x}})}return _tools.arr.zip2(mins,maxs)}get halfspaces(){if(this._halfspaces!=null)return this._halfspaces;this._VtoH();return this.halfspaces}get isDisjunct(){return true}get isEmpty(){if(this._isEmpty!=null)return this._isEmpty;this._isEmpty=this._vertices!=null&&this._vertices.length<=this.dim||this._halfspaces!=null&&this._halfspaces.length<=this.dim||this.volume<TOL;return this._isEmpty}get polytopes(){return this.isEmpty?[]:[this]}get vertices(){if(this._vertices!=null)return this._vertices;this._HtoV();return this.vertices}get volume(){throw new _tools.NotImplementedError}apply(m){linalg.assertEqualDims(m[0].length,this.dim);return Polytope.ofDim(m.length).hull(this.vertices.map(v=>linalg.apply(m,v)))}applyRight(m){linalg.assertEqualDims(m.length,this.dim);return Polytope.ofDim(m[0].length).intersection(this.halfspaces.map(h=>h.applyRight(m)))}contains(p){linalg.assertEqualDims(this.dim,p.length);return _tools.iter.every(this.halfspaces.map(h=>h.contains(p)))}covers(other){if(this.isEmpty)return other.isEmpty;return other.remove(this).isEmpty}disjunctify(){return this}fulfils(predicate){linalg.assertEqualDims(this.dim,predicate.dim);return _tools.iter.every(this.vertices.map(v=>predicate.contains(v)))}hull(){return this}intersect(other){linalg.assertEqualDims(this.dim,other.dim);if(other instanceof Union){return other.intersect(this)}else{if(other.isEmpty||this.isEmpty)return other.constructor.empty();return this._intersectPolytope(other)}}intersects(other){for(let p of other.polytopes){if(!this.intersect(p).isEmpty)return true}return false}invert(){return this.constructor.hull(this.vertices.map(v=>v.map(x=>-x)))}isSameAs(other){if(other instanceof Union){return other.isSameAs(this)}else{const vs=this.vertices;const ws=other.vertices;if(this.dim!==other.dim||vs.length!==ws.length){return false}let idxoff=0;while(idxoff<vs.length){if(linalg.areClose(vs[idxoff],ws[0])){break}idxoff++}for(let i=0;i<vs.length;i++){if(!linalg.areClose(vs[(idxoff+i)%vs.length],ws[i])){return false}}return idxoff<vs.length}}minkowski(other){linalg.assertEqualDims(this.dim,other.dim);let points=[];for(let v of this.vertices){for(let w of other.vertices){points.push(linalg.add(v,w))}}return this.constructor.hull(points)}pontryagin(other){linalg.assertEqualDims(this.dim,other.dim);const ws=other.invert().vertices;const halfspaces=[];for(let h of this.halfspaces){for(let w of ws){halfspaces.push(h.translate(w))}}return this.constructor.noredund(halfspaces)}remove(other){const polytopes=other.polytopes;if(polytopes.length===0)return this;let k=0;let halfspaces=null;while(halfspaces==null&&k<polytopes.length){const intersection=this.intersect(polytopes[k]);if(intersection.isEmpty){k++}else{halfspaces=intersection.halfspaces}}if(halfspaces==null)return this;const out=[];let poly=this;for(let halfspace of halfspaces){const[_poly,polyCandidate]=poly.split(halfspace);if(!polyCandidate.isEmpty){if(k<polytopes.length-1){const toRemove=new Union(this.dim,polytopes.slice(k+1),null);out.push(...polyCandidate.remove(toRemove).polytopes)}else{out.push(polyCandidate)}}poly=_poly}return out.length===1?out[0]:new Union(this.dim,out,true)}sample(){const extent=this.extent;for(let i=0;i<10*this.dim;i++){const point=this.extent.map(([l,u])=>l+(u-l)*Math.random());if(this.contains(point))return point}return this.centroid}scale(factor){const c=this.centroid;return this.constructor.hull(this.vertices.map(v=>_tools.arr.zip2map((a,b)=>a+factor*(b-a),c,v)))}serialize(){return{dim:this.dim,vertices:this.vertices}}simplify(){return this}shatter(){throw new _tools.NotImplementedError}split(h){const intersection=this.constructor.intersection;return[intersection([...this.halfspaces,h]),intersection([...this.halfspaces,h.flip()])]}toUnion(){return new Union(this.dim,[this],true)}translate(v){linalg.assertEqualDims(v.length,this.dim);return this.constructor.hull(this.vertices.map(x=>linalg.add(x,v)))}union(other){return Union.from([this,...other.polytopes])}_intersectPolytope(other){return other.constructor.intersection([...this.halfspaces,...other.halfspaces])}_VtoH(){throw new _tools.NotImplementedError}_HtoV(){throw new _tools.NotImplementedError}}exports.Polytope=Polytope;class Interval extends Polytope{constructor(vertices,halfspaces){super(vertices,halfspaces);this.dim=1}static empty(){return new Interval([],[])}static hull(ps){ps.forEach(p=>linalg.assertEqualDims(p.length,1));let leftIdx=0;let rightIdx=0;for(let idx=1;idx<ps.length;idx++){if(ps[idx][0]<ps[leftIdx][0]){leftIdx=idx}if(ps[idx][0]>ps[rightIdx][0]){rightIdx=idx}}if(ps.length<2||linalg.areClose(ps[leftIdx],ps[rightIdx])){return Interval.empty()}else{return new Interval([ps[leftIdx],ps[rightIdx]],null)}}static intersection(halfspaces){return Interval.noredund(halfspaces)}static noredund(halfspaces){const hs=[];for(let h of halfspaces){linalg.assertEqualDims(h.dim,1);if(h.isInfeasible){return Interval.empty()}else if(!h.isTrivial){hs.push(h)}}let leftIdx=-1;let rightIdx=-1;for(let idx=0;idx<hs.length;idx++){if(hs[idx].normal[0]<0&&(leftIdx<0||hs[idx].offset<hs[leftIdx].offset)){leftIdx=idx}if(hs[idx].normal[0]>0&&(rightIdx<0||hs[idx].offset<hs[rightIdx].offset)){rightIdx=idx}}if(leftIdx<0||rightIdx<0||hs[rightIdx].offset+hs[leftIdx].offset<TOL){return Interval.empty()}else{return new Interval(null,[hs[leftIdx],hs[rightIdx]])}}get boundingBox(){return this}get centroid(){const[l,r]=this.vertices;return[(l[0]+r[0])/2]}get volume(){const vs=this.vertices;if(vs.length===0)return 0;return vs[1][0]-vs[0][0]}shatter(){const vertices=this.vertices;const centroid=this.centroid;return new Union(this.dim,[Interval.hull([centroid,vertices[0]]),Interval.hull([centroid,vertices[1]])],true)}_HtoV(){if(this._halfspaces==null){throw new _tools.ValueError}this._vertices=[[-this._halfspaces[0].offset],[this._halfspaces[1].offset]]}_VtoH(){if(this._vertices==null){throw new _tools.ValueError}const[left,right]=this._vertices;this._halfspaces=[new Halfspace([-1],-left[0]),new Halfspace([1],right[0])]}}exports.Interval=Interval;class Polygon extends Polytope{constructor(vertices,halfspaces){super(vertices,halfspaces);this.dim=2}static empty(){return new Polygon([],[])}static hull(ps){ps.forEach(p=>linalg.assertEqualDims(p.length,2));const points=ps.slice().sort((p,q)=>p[0]==q[0]?q[1]-p[1]:p[0]-q[0]);const ls=[];for(let i=0;i<points.length;i++){reduceHullPart(ls,points[i],0);ls.push(points[i])}const us=[];for(let i=points.length-1;i>=0;i--){reduceHullPart(us,points[i],0);us.push(points[i])}if(ls.length+us.length<5){return Polygon.empty()}const vs=[];for(let i=0;i<ls.length-1;i++){reduceHullPart(vs,ls[i],TOL);vs.push(ls[i])}for(let i=0;i<us.length-1;i++){reduceHullPart(vs,us[i],TOL);vs.push(us[i])}reduceHullPart(vs,vs[0],TOL);while(vs.length>1&&!isCCWTurn(vs[vs.length-1],vs[0],vs[1],TOL)){vs.shift()}return vs.length<3?Polygon.empty():new Polygon(vs,null)}static intersection(halfspaces){const hs=[];for(let h of halfspaces){linalg.assertEqualDims(h.dim,2);if(h.isInfeasible){return Polygon.empty()}hs.push(h)}return Polygon.noredund(hs.sort((g,h)=>{const gOrder=angleOrder(g.normal);const hOrder=angleOrder(h.normal);return gOrder==hOrder?angleCCW(g.normal,h.normal)-Math.PI:gOrder-hOrder}))}static noredund(halfplanes){const loop=[];const cuts=[];let idx=0;while(idx<halfplanes.length){const next=halfplanes[idx];if(next.isTrivial){idx++;continue}if(loop.length==0){loop.push(next);idx++;continue}const last=loop[loop.length-1];const angle=angleCCW(last.normal,next.normal);if(angle>Math.PI-TOL){return Polygon.empty()}const nextCut=halfplaneIntersection(last,next);if(nextCut==null){if(last.offset>next.offset){cuts.pop();loop.pop()}else{idx++}continue}if(cuts.length>0&&(!next.contains(cuts[cuts.length-1])||linalg.areClose(nextCut,cuts[cuts.length-1]))){cuts.pop();loop.pop();continue}cuts.push(nextCut);loop.push(next);idx++}let lidx=0;let ridx=loop.length;while(ridx-lidx>=3){const angle=angleCCW(loop[ridx-1].normal,loop[lidx].normal);if(angle>Math.PI-TOL){return Polygon.empty()}const endCut=halfplaneIntersection(loop[lidx],loop[ridx-1]);if(endCut==null){if(loop[lidx].offset>loop[ridx-1].offset){lidx++}else{ridx--}}else if(!loop[ridx-2].contains(endCut)||linalg.areClose(cuts[ridx-2],endCut)){ridx--}else if(!loop[lidx+1].contains(endCut)||linalg.areClose(cuts[lidx],endCut)){lidx++}else{break}}const out=ridx-lidx<3||angleCCW(loop[ridx-1].normal,loop[lidx].normal)>Math.PI-TOL?[]:loop.slice(lidx,ridx);return new Polygon(null,out)}get centroid(){const vol=this.volume;const x=_tools.iter.sum(_tools.arr.cyc2map((a,b)=>(a[0]+b[0])*(a[0]*b[1]-b[0]*a[1]),this.vertices));const y=_tools.iter.sum(_tools.arr.cyc2map((a,b)=>(a[1]+b[1])*(a[0]*b[1]-b[0]*a[1]),this.vertices));return[x/6/vol,y/6/vol]}get volume(){return 0.5*_tools.iter.sum(_tools.arr.cyc2map((a,b)=>a[0]*b[1]-b[0]*a[1],this.vertices))}shatter(){const c=this.centroid;const vs=this.vertices;const l=vs.length;const polys=[[c,vs[0],linalg.midpoint(vs[l-1],vs[0]),linalg.midpoint(vs[0],vs[1])],[c,vs[l-1],linalg.midpoint(vs[l-2],vs[l-1]),linalg.midpoint(vs[l-1],vs[0])]];for(let i=1;i<l-1;i++){polys.push([c,vs[i],linalg.midpoint(vs[i-1],vs[i]),linalg.midpoint(vs[i],vs[i+1])])}return new Union(this.dim,polys.map(Polygon.hull),true)}_HtoV(){if(this._halfspaces==null){throw new _tools.ValueError}else{this._vertices=_tools.arr.cyc2map(function(v,w){const cut=halfplaneIntersection(v,w);if(cut==null){throw{}}else{return cut}},this._halfspaces)}}_VtoH(){if(this._vertices==null){throw new _tools.ValueError}else{this._halfspaces=_tools.arr.cyc2map(function(v,w){return Halfspace.normalized([w[1]-v[1],v[0]-w[0]],v[0]*w[1]-w[0]*v[1])},this._vertices)}}}exports.Polygon=Polygon;class Union{constructor(dim,polytopes,isDisjunct){this.dim=dim;this.polytopes=polytopes.filter(_=>!_.isEmpty);this.isEmpty=this.polytopes.length===0;this._isDisjunct=this.polytopes.length<2||isDisjunct}static deserialize(json){return new Union(json.dim,json.polytopes.map(Polytope.deserialize),null)}static empty(dim){return new Union(dim,[],true)}static from(polytopes,fallbackDim){const dim=polytopes.length>0?polytopes[0].dim:fallbackDim;if(dim==null)throw new _tools.ValueError("Unable to determine dimension from empty set of polytopes (no fallback provided)");polytopes.forEach(_=>linalg.assertEqualDims(_.dim,dim));return new Union(dim,polytopes,null)}get boundingBox(){const Poly=Polytope.ofDim(this.dim);return this.isEmpty?Poly.empty():Poly.hull(cartesian(...this.extent))}get extent(){const init=new Array(this.dim);init.fill([Infinity,-Infinity]);return this.polytopes.map(_=>_.extent).reduce((ext,cur)=>{return _tools.arr.zip2map((a,b)=>[a[0]<b[0]?a[0]:b[0],a[1]<b[1]?b[1]:a[1]],ext,cur)},init)}get isDisjunct(){return this._isDisjunct!=null&&this._isDisjunct}get volume(){const polytopes=this.isDisjunct?this.polytopes:this.simplify().polytopes;return _tools.iter.sum(polytopes.map(_=>_.volume))}apply(m){return new Union(this.dim,this.polytopes.map(_=>_.apply(m)),this._isDisjunct)}applyRight(m){linalg.assertEqualDims(m.length,this.dim);return new Union(m[0].length,this.polytopes.map(_=>_.applyRight(m)),this._isDisjunct)}contains(v){for(let p of this.polytopes){if(p.contains(v))return true}return false}covers(other){if(this.isEmpty)return other.isEmpty;return other.remove(this).isEmpty}disjunctify(){const ps=this.polytopes.slice().sort((x,y)=>x.volume-y.volume);const out=[];while(ps.length>0){const p=ps.pop();out.push(...p.remove(new Union(this.dim,out,true)).polytopes)}return new Union(this.dim,out,true)}fulfils(h){return _tools.iter.every(this.polytopes.map(_=>_.fulfils(h)))}hull(){const vertices=[];for(let polytope of this.polytopes){vertices.push(...polytope.vertices)}return Polytope.ofDim(this.dim).hull(vertices)}intersect(other){const out=[];for(let x of this.polytopes){for(let y of other.polytopes){const intersection=x.intersect(y);if(!intersection.isEmpty){out.push(intersection)}}}return out.length===1?out[0]:new Union(this.dim,out,this._isDisjunct?true:null)}intersects(other){for(let p of this.polytopes){if(p.intersects(other))return true}return false}invert(){return new Union(this.dim,this.polytopes.map(_=>_.invert()),this._isDisjunct)}isSameAs(other){return this.covers(other)&&other.covers(this)}minkowski(other){return new Union(this.dim,this.polytopes.map(_=>_.minkowski(other)),null)}pontryagin(other){const bbox=this.boundingBox;const complement=bbox.remove(this);return bbox.pontryagin(other).remove(complement.minkowski(other.invert()))}remove(other){const out=[];for(let p of this.polytopes){out.push(...p.remove(other).polytopes)}return new Union(this.dim,out,this._isDisjunct?true:null)}sample(){if(this.polytopes.length>=1){return this.polytopes[0].sample()}throw new _tools.NotImplementedError}serialize(){return{dim:this.dim,polytopes:this.polytopes.map(_=>_.serialize())}}shatter(){const pieces=[];for(let x of this.polytopes){pieces.push(...x.shatter().polytopes)}return new Union(this.dim,pieces,this._isDisjunct)}simplify(){if(this.isEmpty)return this;if(this.polytopes.length===1)return this.polytopes[0];const hull=this.hull();const rest=hull.remove(this);if(rest.isEmpty){return hull}else{return hull.remove(rest)}}toUnion(){return this}translate(v){return new Union(this.dim,this.polytopes.map(_=>_.translate(v)),this._isDisjunct)}union(other){linalg.assertEqualDims(this.dim,other.dim);return new Union(this.dim,[...this.polytopes,...other.polytopes],null)}}exports.Union=Union;

},{"./linalg.js":4,"./parser.js":5,"./tools.js":7}],4:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.assertEqualDims=assertEqualDims;exports.norm2=norm2;exports.dot=dot;exports.add=add;exports.sub=sub;exports.midpoint=midpoint;exports.areClose=areClose;exports.apply=apply;exports.applyRight=applyRight;exports.eye=eye;exports.det=det;exports.inv=inv;exports.transpose=transpose;exports.matmul=matmul;exports.minkowski=exports.TOL=exports.MathError=exports.DimensionMismatch=void 0;var _tools=require("./tools.js");class DimensionMismatch extends Error{}exports.DimensionMismatch=DimensionMismatch;class MathError extends Error{}exports.MathError=MathError;const TOL=1e-8;exports.TOL=TOL;function assertEqualDims(n,m){if(n!=m){throw new DimensionMismatch(String(n)+" != "+String(m))}}function norm2(v){let squares=0;for(let x of v){squares+=x*x}return Math.sqrt(squares)}function dot(v,w){assertEqualDims(v.length,w.length);let sum=0;for(let i=0;i<v.length;i++){sum+=v[i]*w[i]}return sum}function add(v,w){assertEqualDims(v.length,w.length);return _tools.arr.zip2map((a,b)=>a+b,v,w)}function sub(v,w){assertEqualDims(v.length,w.length);return _tools.arr.zip2map((a,b)=>a-b,v,w)}function midpoint(v,w){assertEqualDims(v.length,w.length);return _tools.arr.zip2map((a,b)=>a+0.5*(b-a),v,w)}function areClose(v,w){assertEqualDims(v.length,w.length);return norm2(sub(v,w))<TOL}function apply(m,v){assertEqualDims(m[0].length,v.length);return m.map(row=>dot(row,v))}function applyRight(m,v){return matmul([v],m)[0]}function eye(size){const m=[];for(let i=0;i<size;i++){const row=new Array(size);row.fill(0);row[i]=1;m.push(row)}return m}function det(m){assertEqualDims(m.length,m[0].length);switch(m.length){case 1:return m[0][0];case 2:return m[0][0]*m[1][1]-m[0][1]*m[1][0];default:throw new _tools.NotImplementedError;}}function inv(m){assertEqualDims(m.length,m[0].length);const d=det(m);if(Math.abs(d)<TOL){throw new MathError("matrix not invertible")}else{switch(m.length){case 1:return[[1/d]];case 2:return[[m[1][1]/d,-m[0][1]/d],[-m[1][0]/d,m[0][0]/d]];default:throw new _tools.NotImplementedError;}}}function transpose(m){const result=[];for(let j=0;j<m[0].length;j++){const row=[];for(let i=0;i<m.length;i++){row.push(m[i][j])}result.push(row)}return result}function matmul(m,n){assertEqualDims(m[0].length,n.length);const result=[];for(let i=0;i<m.length;i++){const row=[];for(let j=0;j<n[0].length;j++){let akkumulator=0;for(let k=0;k<n.length;k++){akkumulator+=m[i][k]*n[k][j]}row.push(akkumulator)}result.push(row)}return result}const minkowski={xmy(xs,ys){const out=[];for(let x of xs){for(let y of ys){out.push(sub(x,y))}}return out},axpy(A,xs,ys){const out=[];for(let x of xs){const Ax=apply(A,x);for(let y of ys){out.push(add(Ax,y))}}return out}};exports.minkowski=minkowski;

},{"./tools.js":7}],5:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.ASTParser=ASTParser;exports.printAST=printAST;exports.ParseError=void 0;class ParseError extends Error{}exports.ParseError=ParseError;function ASTParser(tokenPattern,operators){const pcparser=new PCParser(operators);return function(text){const tokenStream=new TokenStream(text,tokenPattern);return pcparser.parse(tokenStream)}}function printAST(node){return typeof node==="string"?node:node.op+"("+node.args.map(printAST).join(", ")+")"}class TokenStream{constructor(text,pattern){this.text=text;this.pattern=RegExp("\\s*("+pattern.source+")\\s*","gy");this.advance()}advance(){if(this.pattern.lastIndex==this.text.length){this.current=null}else{const lastIndex=this.pattern.lastIndex;const match=this.pattern.exec(this.text);if(match==null)throw new ParseError("unable to tokenize '"+this.text.slice(lastIndex)+"'");this.current=match[1]}}list(){const tokens=[];while(this.current!=null){tokens.push(this.current);this.advance()}return tokens}}class PCParser{constructor(operators){this.uProp={};this.bProp={};for(let operator of operators){if(operator.associativity===0){this.uProp[operator.op]=operator.precedence}else{this.bProp[operator.op]=[operator.precedence,operator.associativity<0]}}}parse(tokens){const ast=this.computeExpr(tokens,0);if(tokens.current!=null)throw new ParseError("expected end token but found token "+tokens.current);return ast}computeExpr(tokens,minPrec){let left=this.computeAtom(tokens);while(true){const token=tokens.current;if(token==null||!this.bProp.hasOwnProperty(token)){break}const[prec,lAssoc]=this.bProp[token];if(prec<minPrec){break}tokens.advance();const right=this.computeExpr(tokens,lAssoc?prec+1:prec);left={op:token,args:[left,right]}}return left}computeAtom(tokens){const token=tokens.current;if(token==null)throw new ParseError("unexpected end of token stream");tokens.advance();if(this.uProp.hasOwnProperty(token)){const arg=this.computeExpr(tokens,this.uProp[token]);return{op:token,args:[arg]}}else if(token==="("){const inner=this.computeExpr(tokens,0);if(tokens.current!==")")throw new ParseError("unexpected token "+String(tokens.current)+", expected closing parenthesis");tokens.advance();return inner}else{return token}}}

},{}],6:[function(require,module,exports){
"use strict";var dom=_interopRequireWildcard(require("./dom.js"));var _figure=require("./figure.js");var _geometry=require("./geometry.js");var _linalg=require("./linalg.js");var _tools=require("./tools.js");var _widgetsInput=require("./widgets-input.js");var _widgetsPlot=require("./widgets-plot.js");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}}newObj.default=obj;return newObj}}const VAR_NAMES="xy";function texifyVertex(v){if(v.length===1){return"\\OneByOne{"+(0,_tools.n2s)(v[0],4)+"}"}else if(v.length===2){return"\\TwoByOne{"+(0,_tools.n2s)(v[0],4)+"}{"+(0,_tools.n2s)(v[1],4)+"}"}throw new Error}class PolytopeViewer{constructor(){const fig=new _figure.Figure;this.layers={poly:fig.newLayer({"stroke":"#000","fill":"#EEE"}),halfspace:fig.newLayer({"stroke":"#000","fill":"#000","fill-opacity":"0.2"}),vertex:fig.newLayer({"stroke":"#000","stroke-width":"5","fill":"#000"})};this.plot=new _widgetsPlot.AxesPlot([400,300],fig,(0,_figure.autoProjection)(4/3));this.input=dom.TEXTAREA({"cols":"30","rows":"10"},[]);this.input.addEventListener("change",()=>this.handleChange());this.errorBox=dom.DIV({"class":"error"});this.vertices=dom.DIV({"class":"vertices"},["-"]);this.halfspaces=dom.DIV({"class":"halfspaces"},["-"]);this.tex=dom.TEXTAREA({"class":"tex","rows":"3","cols":"60"});this.node=dom.DIV({"class":"widget viewer"},[dom.DIV({},[dom.P({},["Vertex Input"]),this.input]),dom.DIV({},[this.plot.node]),dom.DIV({},[dom.P({},["TeX"]),this.tex,dom.P({},["Vertices"]),this.vertices,dom.P({},["Halfspaces"]),this.halfspaces,this.errorBox])])}set polytope(poly){this.input.value=JSON.stringify(poly.vertices);this.handleChange()}handleChange(){try{const input=JSON.parse(this.input.value);const dim=input[0].length;const poly=_geometry.Polytope.ofDim(dim).hull(input);if(poly.isEmpty)throw new Error("Polytope is empty");dom.replaceChildren(this.vertices,_tools.arr.intersperse(", ",poly.vertices.map(_=>this._vertexToNode(_))));dom.replaceChildren(this.halfspaces,poly.halfspaces.map(_=>this._halfspaceToNode(_)));this.tex.value="\\Hull \\Big( \\Big\\{ "+poly.vertices.map(texifyVertex).join(", ")+" \\Big\\} \\Big)";this.layers.poly.shapes=[{"kind":"polytope","vertices":poly.vertices}];this.plot.projection=(0,_figure.autoProjection)(4/3,...poly.extent);this.setError()}catch(err){dom.replaceChildren(this.vertices,["-"]);dom.replaceChildren(this.halfspaces,["-"]);this.tex.value="";this.layers.poly.shapes=[];this.plot.projection=(0,_figure.autoProjection)(4/3);this.setError(err.message)}}drawVertex(v){this.layers.vertex.shapes=v==null?[]:[{kind:"arrow",origin:v,target:v}]}drawHalfspace(h){this.layers.halfspace.shapes=h==null?[]:[{kind:"halfspace",normal:h.normal,offset:h.offset}]}setError(message){if(message==null){dom.removeChildren(this.errorBox)}else{dom.replaceChildren(this.errorBox,[message])}}_vertexToNode(v){const node=dom.SPAN({"class":"item"},["["+v.map(_=>(0,_tools.n2s)(_,3)).join(", ")+"]"]);node.addEventListener("mouseover",()=>this.drawVertex(v));node.addEventListener("mouseout",()=>this.drawVertex(null));return node}_halfspaceToNode(h){const terms=[];for(let i=0;i<h.dim;i++){if(h.normal[i]===0){continue}else if(h.normal[i]<0){terms.push("-")}else if(terms.length>0){terms.push("+")}if(h.normal[i]!==1&&h.normal[i]!==-1){terms.push((0,_tools.n2s)(Math.abs(h.normal[i])))}terms.push(VAR_NAMES[i])}const node=dom.DIV({"class":"item"},[dom.DIV({},[terms.join(" ")]),dom.DIV({},[" < "]),dom.DIV({},[(0,_tools.n2s)(h.offset)])]);node.addEventListener("mouseover",()=>this.drawHalfspace(h));node.addEventListener("mouseout",()=>this.drawHalfspace(null));return node}}class PolytopeForm extends _tools.ObservableMixin{constructor(viewer,readOnly){super();this.viewer=viewer;this.input=dom.TEXTAREA({"cols":"15","rows":"8"});if(!readOnly)this.input.addEventListener("change",()=>this.handleChange());const send=dom.createButton({},["send to viewer"],()=>this.sendToViewer());const fig=new _figure.Figure;this.layer=fig.newLayer({"stroke":"#000","fill":"#EEE"});this.plot=new _widgetsPlot.ShapePlot([100,100],fig,(0,_figure.autoProjection)(1));let cls="polytope-input";if(readOnly)cls+=" read-only";this.node=dom.DIV({"class":cls},[this.input,dom.DIV({},[send,this.plot.node])]);this.handleChange()}get text(){return this.input.value}set text(txt){this.input.value=txt;this.handleChange()}get polytope(){const input=JSON.parse(this.input.value);if(input.length===0)throw new Error("polytope is empty");const dim=input[0].length;return _geometry.Polytope.ofDim(dim).hull(input)}set polytope(polytope){this.input.value=polytope!=null?JSON.stringify(polytope.vertices):"";this.handleChange()}handleChange(){try{const polytope=this.polytope;if(polytope.isEmpty)throw new Error("Polytope is empty");this.layer.shapes=[{"kind":"polytope","vertices":polytope.vertices}];this.plot.projection=(0,_figure.autoProjection)(1,...polytope.extent);this.setError()}catch(err){this.layer.shapes=[];this.plot.projection=(0,_figure.autoProjection)(1);this.setError(err.message)}this.notify()}sendToViewer(){if(this.polytope!=null){this.viewer.polytope=this.polytope}}setError(message){this.input.className=message==null?"":"error";this.input.title=message==null?"":message}}function progressDiv(text){if(text==null)text="\u25B6";return dom.DIV({"class":"progress"},[text])}class TransformationWidget{constructor(viewer){this.input=new PolytopeForm(viewer,false);this.input.attach(()=>this.handleChange());this.matrix=dom.TEXTAREA({"cols":"15","rows":"3"});this.matrix.addEventListener("change",()=>this.handleChange());this.transformationForm=dom.P();this.transformation=new _widgetsInput.DropdownInput({"apply left":(p,m)=>p.apply(m),"apply right":(p,m)=>p.applyRight(m),"translate":(p,m)=>p.translate(m)},"apply left");this.transformation.attach(()=>this.handleChange());this.output=new PolytopeForm(viewer,true);this.errorBox=dom.DIV({"class":"error"});this.node=dom.DIV({"class":"widget"},[this.input.node,progressDiv(),dom.DIV({},[dom.P({},[this.transformation.node]),this.matrix]),progressDiv(),this.output.node,this.errorBox]);this.handleChange()}handleChange(){try{const polytope=this.input.polytope;const matrix=JSON.parse(this.matrix.value);this.output.polytope=this.transformation.value(polytope,matrix);dom.removeChildren(this.errorBox)}catch(err){this.output.polytope=null;dom.replaceChildren(this.errorBox,[err.message])}}}class MinkowskiPontryaginWidget{constructor(viewer){this.op=new _widgetsInput.DropdownInput({"+":(p,q)=>p.minkowski(q),"-":(p,q)=>p.pontryagin(q)});this.op.attach(()=>this.handleChange());this.arg1=new PolytopeForm(viewer,false);this.arg1.attach(()=>this.handleChange());this.arg2=new PolytopeForm(viewer,false);this.arg2.attach(()=>this.handleChange());this.result=new PolytopeForm(viewer,true);this.errorBox=dom.DIV({"class":"error"});this.node=dom.DIV({"class":"widget"},[this.arg1.node,dom.DIV({},[this.op.node]),this.arg2.node,progressDiv("="),this.result.node,this.errorBox]);this.handleChange()}handleChange(){try{const arg1=this.arg1.polytope;const arg2=this.arg2.polytope;this.result.polytope=this.op.value(arg1,arg2);dom.removeChildren(this.errorBox)}catch(err){this.result.polytope=null;dom.replaceChildren(this.errorBox,[err.message])}}}class OperatorsWidget extends _tools.ObservableMixin{constructor(viewer){super();this.matrixA=dom.TEXTAREA({"cols":"15","rows":"3"});this.matrixA.addEventListener("change",()=>this.handleChange());this.matrixB=dom.TEXTAREA({"cols":"15","rows":"3"});this.matrixB.addEventListener("change",()=>this.handleChange());this.inputs={x:new PolytopeForm(viewer,false),u:new PolytopeForm(viewer,false),y:new PolytopeForm(viewer,false),w:new PolytopeForm(viewer,false),r:new PolytopeForm(viewer,true)};this.inputs.x.attach(()=>this.handleChange());this.inputs.u.attach(()=>this.handleChange());this.inputs.y.attach(()=>this.handleChange());this.inputs.w.attach(()=>this.handleChange());this.op=new _widgetsInput.DropdownInput({"Post(X, U)":(A,B)=>this.post(A,B),"Act(X, {Y})":(A,B)=>this.act(A,B),"ActR(X, {Y})":(A,B)=>this.actR(A,B),"Pre(X, U, {Y})":(A,B)=>this.pre(A,B),"PreR(X, U, {Y})":(A,B)=>this.preR(A,B)},"Post(X, U)");this.op.attach(()=>this.handleChange());this.node=dom.DIV({},[dom.DIV({"class":"widget"},[progressDiv("x' = "),dom.DIV({"class":"eq-matrix"},[this.matrixA]),progressDiv("x + "),dom.DIV({"class":"eq-matrix"},[this.matrixB]),progressDiv("u + w")]),dom.DIV({"class":"widget"},[dom.DIV({},[dom.P({},["X"]),this.inputs.x.node]),dom.DIV({},[dom.P({},["U"]),this.inputs.u.node]),dom.DIV({},[dom.P({},["Y"]),this.inputs.y.node]),dom.DIV({},[dom.P({},["W"]),this.inputs.w.node])]),dom.DIV({"class":"widget"},[dom.DIV({},[this.op.node]),progressDiv("="),this.inputs.r.node])]);this.handleChange()}handleChange(){try{const A=JSON.parse(this.matrixA.value);const B=JSON.parse(this.matrixB.value);this.inputs.r.polytope=this.op.value(A,B)}catch(err){this.inputs.r.polytope=null}this.notify()}post(A,B){const x=this.inputs.x.polytope;const u=this.inputs.u.polytope;const w=this.inputs.w.polytope;return _geometry.Polytope.ofDim(x.dim).hull(_linalg.minkowski.axpy(A,x.vertices,_linalg.minkowski.axpy(B,u.vertices,w.vertices)))}act(A,B){const x=this.inputs.x.polytope;const y=this.inputs.y.polytope;const w=this.inputs.w.polytope;return _geometry.Polytope.ofDim(x.dim).hull(_linalg.minkowski.xmy(y.vertices,_linalg.minkowski.axpy(A,x.vertices,w.vertices))).applyRight(B)}actR(A,B){const x=this.inputs.x.polytope;const y=this.inputs.y.polytope;const w=this.inputs.w.polytope;const poly=_geometry.Polytope.ofDim(x.dim).hull(_linalg.minkowski.axpy(A,x.vertices,w.vertices));return y.pontryagin(poly).applyRight(B)}pre(A,B){const x=this.inputs.x.polytope;const u=this.inputs.u.polytope;const y=this.inputs.y.polytope;const w=this.inputs.w.polytope;const Bus=u.vertices.map(_=>(0,_linalg.apply)(B,_));return _geometry.Polytope.ofDim(x.dim).hull(_linalg.minkowski.xmy(y.vertices,_linalg.minkowski.axpy(B,u.vertices,w.vertices))).applyRight(A).intersect(x)}preR(A,B){const x=this.inputs.x.polytope;const u=this.inputs.u.polytope;const y=this.inputs.y.polytope;const w=this.inputs.w.polytope;const Bus=u.vertices.map(_=>(0,_linalg.apply)(B,_));return _geometry.Polytope.ofDim(x.dim).hull(_linalg.minkowski.xmy(y.pontryagin(w).vertices,Bus)).applyRight(A).intersect(x)}serialize(){return{"A":this.matrixA.value,"B":this.matrixB.value,"X":this.inputs.x.text,"U":this.inputs.u.text,"Y":this.inputs.y.text,"W":this.inputs.w.text}}load(data){this.matrixA.value=data.A;this.matrixB.value=data.B;this.inputs.x.text=data.X;this.inputs.u.text=data.U;this.inputs.y.text=data.Y;this.inputs.w.text=data.W}}function toExportURL(ops){const data=ops.serialize();return window.btoa(JSON.stringify(data))}document.addEventListener("DOMContentLoaded",function(){const viewer=new PolytopeViewer;const operators=new OperatorsWidget(viewer);const widget=dom.DIV();const widgets=new _widgetsInput.DropdownInput({"Transformations":new TransformationWidget(viewer),"Minkowski/Pontryagin":new MinkowskiPontryaginWidget(viewer),"Polytopic Operators":operators},"Polytopic Operators");widgets.attach(()=>dom.replaceChildren(widget,[widgets.value.node]));widgets.notify();const contentNode=(0,_tools.just)(document.getElementById("content"));dom.replaceChildren(contentNode,[viewer.node,dom.DIV({"class":"widget"},[widgets.node]),widget]);if(window.location.hash.length>0){const hash=window.location.hash.substring(1);const data=JSON.parse(window.atob(hash));operators.load(data)}operators.attach(()=>{window.location.hash="#"+toExportURL(operators)})});

},{"./dom.js":1,"./figure.js":2,"./geometry.js":3,"./linalg.js":4,"./tools.js":7,"./widgets-input.js":8,"./widgets-plot.js":9}],7:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.just=just;exports.xor=xor;exports.replaceAll=replaceAll;exports.hashString=hashString;exports.n2s=n2s;exports.t2s=t2s;exports.UniqueCollection=exports.ObservableMixin=exports.obj=exports.sets=exports.arr=exports.iter=exports.ValueError=exports.NotImplementedError=void 0;class NotImplementedError extends Error{}exports.NotImplementedError=NotImplementedError;class ValueError extends Error{}exports.ValueError=ValueError;function just(val,err){if(val==null)throw new ValueError(err==null?"Value is null but shouldn't be":err);return val}function xor(p,q){return p?!q:q}const iter={some:function(xs){for(let x of xs){if(x)return true}return false},every:function(xs){for(let x of xs){if(!x)return false}return true},sum:function(xs){let s=0;for(let x of xs){s+=x}return s},count:function(xs){let c=0;for(let x of xs){c++}return c},map:function*(fun,xs){for(let x of xs){yield fun(x)}},filter:function*(test,xs){for(let x of xs){if(test(x)){yield x}}},chain:function*(...xss){for(let xs of xss){yield*xs}},argmax:function(value,xs){let maxArg=null;let maxVal=-Infinity;for(let x of xs){const val=value(x);if(val>maxVal){maxArg=x;maxVal=val}}return maxArg}};exports.iter=iter;const arr={zip2map:function(fun,xs,ys){let zs=[];for(let i=0;i<xs.length;i++){zs[i]=fun(xs[i],ys[i])}return zs},zip2:function(xs,ys){return arr.zip2map((x,y)=>[x,y],xs,ys)},cyc2map:function(fun,xs){if(xs.length==0)return[];const zs=[];for(let i=0;i<xs.length-1;i++){zs.push(fun(xs[i],xs[i+1]))}zs.push(fun(xs[xs.length-1],xs[0]));return zs},intersperse:function(delim,items){const out=[];for(let item of items){out.push(item);out.push(delim)}out.pop();return out},sample:function(items){return items[Math.floor(Math.random()*items.length)]}};exports.arr=arr;const sets={areEqual:function(xs,ys){if(xs.size!==ys.size){return false}for(let y of ys){if(!xs.has(y)){return false}}return true},isSubset:function(subs,sups){for(let sub of subs){if(!sups.has(sub)){return false}}return true},doIntersect:function(xs,ys){for(let x of xs){if(ys.has(x)){return true}}return false},union:function(...xss){return new Set(iter.chain(...xss))},intersection:function(xs,ys){return new Set(iter.filter(x=>ys.has(x),xs))},difference:function(xs,ys){return new Set(iter.filter(x=>!ys.has(x),xs))},map:function(fun,xs){return new Set(iter.map(fun,xs))},filter:function(fun,xs){return new Set(iter.filter(fun,xs))}};exports.sets=sets;const obj={forEach:function(fun,kvs){for(let key in kvs){if(kvs.hasOwnProperty(key)){fun(key,kvs[key])}}},map2Array:function(fun,kvs){const out=[];obj.forEach((key,val)=>{out.push(fun(key,val))},kvs);return out},map:function(fun,kvs){const out={};obj.forEach((key,val)=>{out[key]=fun(key,val)},kvs);return out},values:function(kvs){return obj.map2Array((k,v)=>v,kvs)},keys:function(kvs){return obj.map2Array((k,v)=>k,kvs)},merge:function(...kvss){const out={};for(let kvs of kvss){obj.forEach((key,val)=>{out[key]=val},kvs)}return out},clone:function(kvs){return Object.assign({},kvs)},fromMap:function(fun,ks){const out={};for(let k of ks){out[k]=fun(k)}return out}};exports.obj=obj;function replaceAll(haystack,needle,substitute){return haystack.split(needle).join(substitute)}function hashString(s){let hash=0;if(s.length!==0){for(let i=0;i<s.length;i++){hash=(hash<<5)-hash+s.charCodeAt(i);hash|=0}}return hash}function n2s(x,places){if(places==null)places=5;return x.toFixed(places).replace(/\.?0*$/,"")}const MSINS=1000;const MSINM=60*MSINS;const MSINH=60*MSINM;function t2s(x){const hor=Math.floor(x/MSINH);const min=Math.floor((x-hor*MSINH)/MSINM);const sec=Math.floor((x-hor*MSINH-min*MSINM)/MSINS);if(sec===0&&min===0&&hor===0){return(x/1000).toFixed(3)+" s"}else{const parts=[];if(hor>0)parts.push(hor+" h");if(min>0)parts.push(min+" min");if(sec>0)parts.push(sec+" s");return parts.join(" ")}}class ObservableMixin{constructor(){this.observers=[];this.isSendingNotifications=true}attach(observer,callImmediately){this.observers.push(observer);if(callImmediately===true)observer()}detach(observer){let idx=this.observers.indexOf(observer);if(idx<0){throw new Error("observer was not attached")}this.observers.splice(idx,1)}notify(event){if(this.isSendingNotifications){for(let observer of this.observers){observer(event)}}}}exports.ObservableMixin=ObservableMixin;class UniqueCollection{constructor(hash,areEqual){this._hash=hash;this._areEqual=areEqual;this._buckets=new Map;this._size=0}get size(){return this._size}has(value){const hash=this._hash(value);const bucket=this._buckets.get(hash);if(bucket!=null){for(let item of bucket){if(this._areEqual(item,value)){return true}}}return false}take(value){const hash=this._hash(value);let bucket=this._buckets.get(hash);if(bucket==null){bucket=this._newBucket(hash);bucket.add(value);this._size++;return value}for(let item of bucket){if(this._areEqual(item,value)){return item}}bucket.add(value);this._size++;return value}_newBucket(hash){const bucket=new Set;this._buckets.set(hash,bucket);return bucket}*[Symbol.iterator](){for(let values of this._buckets.values()){yield*values}}}exports.UniqueCollection=UniqueCollection;

},{}],8:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.inputTextRotation=inputTextRotation;exports.MatrixInput=exports.CheckboxInput=exports.RadioInput=exports.DropdownInput=exports.MultiLineInput=exports.LineInput=exports.ValidationError=void 0;var dom=_interopRequireWildcard(require("./dom.js"));var _tools=require("./tools.js");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}}newObj.default=obj;return newObj}}class ValidationError extends Error{}exports.ValidationError=ValidationError;;function inputTextRotation(input,texts){if(texts.length<1)throw new Error("texts must contain at least one choice");return function(){const idx=texts.indexOf(input.text);input.text=idx<0?texts[0]:texts[(idx+1)%texts.length]}}class LineInput extends _tools.ObservableMixin{constructor(parse,size,initialText){super();this.parse=parse;this.node=dom.INPUT({"type":"text"});if(size!=null){this.size=size}if(initialText!=null){this.text=initialText}this.node.addEventListener("change",()=>this.handleChange())}get value(){return this.parse(this.text)}get text(){return this.node.value}set text(text){this.node.value=text;this.handleChange()}set disabled(tf){this.node.disabled=tf}get isValid(){return this.node.checkValidity()}set size(size){this.node.size=size}handleChange(){try{this.value;this.node.setCustomValidity("")}catch(e){this.node.setCustomValidity("Parse Error: "+e.message)}this.notify()}}exports.LineInput=LineInput;class MultiLineInput extends _tools.ObservableMixin{constructor(parseLine,size,initialText){super();this.node=dom.TEXTAREA();this.node.addEventListener("change",()=>this.handleChange());this.parseLine=parseLine;if(size!=null){this.size=size}if(initialText!=null){this.text=initialText}}get value(){return this.text.split("\n").filter(line=>line.length>0).map((line,i)=>{try{return this.parseLine(line)}catch(e){e.message="Line "+(i+1)+": "+e.message;throw e}})}get text(){return this.node.value}set text(text){this.node.value=text;this.handleChange()}set disabled(tf){this.node.disabled=tf}get isValid(){return this.node.checkValidity()}set size(size){this.node.rows=size[0];this.node.cols=size[1]}handleChange(){try{this.value;this.node.setCustomValidity("")}catch(e){this.node.setCustomValidity("Parse Error: "+e.message)}this.notify()}}exports.MultiLineInput=MultiLineInput;class DropdownInput extends _tools.ObservableMixin{constructor(options,initialText){super();this.node=dom.SELECT();this.node.addEventListener("change",()=>this.handleChange());this.isValid=true;this.setOptions(options,initialText)}get value(){return this._options[this.text]}get text(){return this.node.value}set text(text){if(!this._options.hasOwnProperty(text))throw new Error("text '"+text+"' not in options: "+_tools.obj.keys(this._options).join(", "));this.node.value=text;this.handleChange()}set disabled(tf){this.node.disabled=tf}setOptions(options,initialText){this._options=options;dom.replaceChildren(this.node,_tools.obj.map2Array((k,v)=>dom.OPTION({},[k]),options));this.text=initialText!=null?initialText:Object.keys(options)[0]}handleChange(){this.notify()}static rangeOptions(start,stop,step){const options={};for(let i=start;i<stop;i+=step){options[String(i)]=i}return options}}exports.DropdownInput=DropdownInput;let ID_GEN=0;class RadioInput extends _tools.ObservableMixin{constructor(options,initialText,nodeify){super();this.nodeify=nodeify==null?null:nodeify;this.isValid=true;this._disabled=false;this.name="radio_id_"+ID_GEN++;this.node=dom.DIV();this.setOptions(options,initialText)}get value(){return this._options[this.text]}get text(){for(let radio of this._radios){if(radio.checked)return radio.value}throw new Error("no radio is selected")}set text(text){if(!this._options.hasOwnProperty(text))throw new Error("text '"+text+"' not in options: "+_tools.obj.keys(this._options).join(", "));for(let radio of this._radios){radio.checked=radio.value===text}this.notify()}set disabled(tf){this._disabled=tf;for(let radio of this._radios){radio.disabled=tf}}setOptions(options,initialText){this._radios=[];this._options=options;dom.replaceChildren(this.node,_tools.obj.map2Array((text,_)=>{const radio=dom.INPUT({"type":"radio","name":this.name,"value":text});radio.addEventListener("change",()=>this.handleChange());radio.disabled=this._disabled;this._radios.push(radio);return dom.LABEL({},[radio,this.nodeify==null?text:this.nodeify(text)])},options));this.text=initialText!=null?initialText:Object.keys(options)[0]}handleChange(){this.notify()}}exports.RadioInput=RadioInput;class CheckboxInput extends _tools.ObservableMixin{constructor(initialValue,label){super();this.isValid=true;this._box=dom.INPUT({"type":"checkbox"});this._box.addEventListener("change",()=>this.handleChange());this._box.checked=initialValue!=null&&initialValue;this.node=dom.LABEL({},label==null?[this._box]:[this._box,label])}get value(){return this._box.checked}get text(){return this.value?"t":"f"}set text(text){this._box.checked=text==="t";this.handleChange()}set disabled(tf){this._box.disabled=tf}handleChange(){this.notify()}}exports.CheckboxInput=CheckboxInput;class MatrixInput extends _tools.ObservableMixin{constructor(parse,shape,size,initialText){super();this.parse=parse;this._shape=shape;this._size=size;this._disabled=false;this.node=dom.TABLE({"class":"matrix"});this._createLineInputs();if(initialText!=null){this.text=initialText}}get value(){let[nrows,ncols]=this._shape;let value=[];for(let i=0;i<nrows;i++){let row=[];for(let j=0;j<ncols;j++){row.push(this.lineInputs[i*ncols+j].value)}value.push(row)}return value}get text(){return this.lineInputs.map(lineInput=>lineInput.text).join("\n")}set text(text){this.isSendingNotifications=false;_tools.arr.zip2map((lineInput,text)=>{lineInput.text=text},this.lineInputs,text.split("\n"));this.isSendingNotifications=true;this.handleChange()}set disabled(tf){this._disabled=tf;for(let lineInput of this.lineInputs){lineInput.disabled=tf}}get isValid(){for(let lineInput of this.lineInputs){if(!lineInput.isValid){return false}}return true}set size(size){this._size=size;for(let lineInput of this.lineInputs){lineInput.size=size}}get shape(){return this._shape}set shape(shape){let[nrowsOld,ncolsOld]=this._shape;let oldTexts=this.text.split("\n");this.isSendingNotifications=false;this._shape=shape;this._createLineInputs();let[nrows,ncols]=shape;for(let i=0;i<Math.min(nrows,nrowsOld);i++){for(let j=0;j<Math.min(ncols,ncolsOld);j++){this.lineInputs[i*ncols+j].text=oldTexts[i*ncolsOld+j]}}this.isSendingNotifications=true;this.handleChange()}_createLineInputs(){const[nrows,ncols]=this._shape;this.lineInputs=[];const callback=()=>this.handleChange();const trs=[];for(let i=0;i<nrows;i++){const tds=[];for(let j=0;j<ncols;j++){const input=new LineInput(this.parse,this._size,"");input.attach(callback);input.disabled=this._disabled;tds.push(dom.create("td",{},[input.node]));this.lineInputs.push(input)}trs.push(dom.create("tr",{},tds))}dom.replaceChildren(this.node,trs)}handleChange(){this.notify()}}exports.MatrixInput=MatrixInput;

},{"./dom.js":1,"./tools.js":7}],9:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.ShapePlot=exports.AxesPlot=exports.InteractivePlot=void 0;var linalg=_interopRequireWildcard(require("./linalg.js"));var dom=_interopRequireWildcard(require("./dom.js"));var _tools=require("./tools.js");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}}newObj.default=obj;return newObj}}function toStr(x){return x.toFixed(3)}class InteractivePlot{constructor(size,figure,projection){this._referenceProjection=projection;const resetButton=dom.create("a",{"href":""},["reset"]);resetButton.addEventListener("click",e=>{this.projection=this._referenceProjection;e.preventDefault()});const saveButton=dom.create("a",{"href":"","download":"plot.svg"},["export"]);saveButton.addEventListener("click",()=>{saveButton.setAttribute("href","data:image/svg+xml;base64,"+window.btoa(this.axesPlot.source))});const coordsDisplay=dom.SPAN({"class":"coords"});this.menu=dom.DIV({"class":"menu"},[coordsDisplay,"hold shift to pan and zoom :: ",resetButton," :: ",saveButton]);this.axesPlot=new AxesPlot(size,figure,projection);this.node=dom.DIV({"class":"plot"},[this.menu,this.axesPlot.node]);const shapePlot=this.axesPlot.shapePlot;shapePlot.node.addEventListener("mousemove",e=>{const coords=shapePlot.getCoords(e.clientX,e.clientY);dom.replaceChildren(coordsDisplay,[coords.map(_=>(0,_tools.n2s)(_,2)).join(", ")])});shapePlot.node.addEventListener("wheel",e=>{if(e.shiftKey){this.projection=this.projection.zoom(e.deltaY>0?1.12:1/1.12);e.preventDefault()}});let panningState=null;shapePlot.node.addEventListener("mouseleave",()=>{dom.removeChildren(coordsDisplay);if(panningState!=null){panningState=null;dom.setCursor("auto")}});shapePlot.node.addEventListener("mousedown",e=>{if(e.buttons==1&&e.shiftKey){panningState=shapePlot.getCoords(e.clientX,e.clientY);e.preventDefault();dom.setCursor("grabbing")}});shapePlot.node.addEventListener("mouseup",e=>{if(panningState!=null&&e.target!=shapePlot.node){this.projection=this.projection.translate(panningState,shapePlot.getCoords(e.clientX,e.clientY));panningState=null;dom.setCursor("auto");e.stopPropagation()}});shapePlot.node.addEventListener("click",e=>{if(panningState!=null){this.projection=this.projection.translate(panningState,shapePlot.getCoords(e.clientX,e.clientY));panningState=null;dom.setCursor("auto");e.stopPropagation()}})}get size(){return this.axesPlot.size}set size(size){this.axesPlot.size=size}get projection(){return this.axesPlot.projection}set projection(projection){this.axesPlot.projection=projection}set referenceProjection(projection){this._referenceProjection=projection}get figure(){return this.axesPlot.figure}addMenuElement(node){dom.appendChildren(this.menu,[" :: ",node])}}exports.InteractivePlot=InteractivePlot;class AxesPlot{constructor(size,figure,projection){this.ticks=dom.createSVG("g",{"stroke":"#000","stroke-width":"1"});this.tickLabels=dom.createSVG("g",{"font-family":"DejaVu Sans, sans-serif","font-size":"8pt"});this.shapePlot=new ShapePlot(size,figure,projection);this.shapePlot.node.setAttribute("x","5");this.shapePlot.node.setAttribute("y","5");this.node=dom.createSVG("svg",{xmlns:dom.SVGNS},[this.tickLabels,this.shapePlot.node,this.ticks]);this.draw()}get size(){return this.shapePlot.size}set size(size){this.shapePlot.size=size;this.draw()}get figure(){return this.shapePlot.figure}get projection(){return this.shapePlot.projection}set projection(projection){this.shapePlot.projection=projection;this.draw()}get source(){return this.node.outerHTML}draw(){let[sizeX,sizeY]=this.size;this.node.setAttribute("width",String(sizeX+45));this.node.setAttribute("height",String(sizeY+25));const ticks=[];const labels=[];for(let tick of this.projection.getXTicks(Math.ceil(sizeX/43))){let x=5+tick[0]*sizeX;ticks.push(this._createTickLine(x,x,sizeY+1,sizeY+4.5));labels.push(this._createTickLabel(x,sizeY+20,"middle",tick[1]))}for(let tick of this.projection.getYTicks(Math.ceil(sizeY/30))){let y=(1-tick[0])*sizeY+5;ticks.push(this._createTickLine(sizeX+1,sizeX+4.5,y,y));labels.push(this._createTickLabel(12+sizeX,y+4,"start",tick[1]))}dom.replaceChildren(this.ticks,ticks);dom.replaceChildren(this.tickLabels,labels)}_createTickLine(x1,x2,y1,y2){return dom.createSVG("line",{"x1":toStr(x1),"y1":toStr(y1),"x2":toStr(x2),"y2":toStr(y2)})}_createTickLabel(x,y,anchor,label){return dom.createSVG("text",{"x":toStr(x),"y":toStr(y),"text-anchor":anchor},[label])}}exports.AxesPlot=AxesPlot;class ShapePlot{constructor(size,figure,projection,drawBorder){this._projection=projection;this.figure=figure;this.figure.attach(e=>{if(e!=null&&e.event=="newLayer"){let group=new ShapeGroup(this,e.layer);this.groups.push(group)}this.draw()});this.groups=[];for(let layer of figure.layers){this.groups.push(new ShapeGroup(this,layer))}this._background=dom.createSVG("rect",{x:"0",y:"0",width:"0",height:"0",stroke:"none",fill:"#FFFFFF"});this._drawBorder=drawBorder==null||drawBorder;this._border=dom.createSVG("rect",{x:"0.5",y:"0.5",width:"0",height:"0",stroke:"#000000","stroke-width":"1",fill:"none"});this.node=dom.createSVG("svg",{xmlns:dom.SVGNS});this.size=size}get size(){return[this._sizeX,this._sizeY]}set size(size){this._sizeX=size[0];this._sizeY=size[1];this.node.setAttribute("width",String(this._sizeX));this.node.setAttribute("height",String(this._sizeY));this._background.setAttribute("width",String(this._sizeX));this._background.setAttribute("height",String(this._sizeY));this._border.setAttribute("width",String(this._sizeX-1));this._border.setAttribute("height",String(this._sizeY-1));this.draw()}get projection(){return this._projection}set projection(projection){this._projection=projection;this.draw()}getCoords(clientX,clientY){let rect=this.node.getBoundingClientRect();let x=Math.floor(clientX-rect.left)/(rect.width-1)*rect.width;let y=Math.floor(clientY-rect.top)/(rect.height-1)*rect.height;return this.projection.bwd(this.scaleBwd([x,y]))}scaleFwd(coords){let[x,y]=coords;return[x*this._sizeX,(1-y)*this._sizeY]}scaleBwd(coords){let x=coords[0]/this._sizeX;let y=1-coords[1]/this._sizeY;return[x,y]}project(shape){return this.projection.project(shape)}draw(){const children=[this._background];for(let group of this.groups){children.push(group.node);group.draw()}if(this._drawBorder){children.push(this._border)}dom.replaceChildren(this.node,children)}}exports.ShapePlot=ShapePlot;class ShapeGroup{constructor(shapePlot,layer){this.shapePlot=shapePlot;this.layer=layer;this.layer.attach(()=>this.draw());this.node=dom.createSVG("g",this.layer.style)}draw(){const children=[];for(let shape of this.layer.shapes){const primitives=this.shapePlot.project(shape);const shapeStyle=shape.style==null?{}:shape.style;const events=shape.events==null?{}:shape.events;for(let primitive of primitives){const style=_tools.obj.merge(primitive.style==null?{}:primitive.style,shapeStyle);if(primitive.kind==="polygon"){let node=dom.createSVG("polygon",{points:primitive.points.map(point=>{return this.fwd(point).map(toStr).join(",")}).join(" ")});dom.setAttributes(node,style);dom.addEventListeners(node,events);children.push(node)}else if(primitive.kind==="label"){let xy=this.fwd(primitive.coords);let node=dom.snLabel.toSVG(primitive.text);node.setAttribute("x",toStr(xy[0]));node.setAttribute("y",toStr(xy[1]));dom.setAttributes(node,style);dom.addEventListeners(node,events);children.push(node)}else if(primitive.kind==="marker"){const[x,y]=this.fwd(primitive.coords);const node=dom.createSVG("circle",{cx:toStr(x),cy:toStr(y),r:toStr(primitive.size)});dom.setAttributes(node,style);dom.addEventListeners(node,events);children.push(node)}else if(primitive.kind==="arrow"){let[x1,y1]=this.fwd(primitive.origin);let[x2,y2]=this.fwd(primitive.target);if(linalg.areClose(primitive.origin,primitive.target)){const node=dom.createSVG("circle",{cx:toStr(x1),cy:toStr(y1),r:"3"});dom.setAttributes(node,style);dom.addEventListeners(node,events);children.push(node)}else{let nvec=[x2-x1,y2-y1];let norm=linalg.norm2(nvec);nvec=[nvec[0]/norm,nvec[1]/norm];if(primitive.deltaO!=null){const[dxO,dyO]=primitive.deltaO;x1+=dxO*nvec[0]-dyO*nvec[1];y1+=dxO*nvec[1]+dyO*nvec[0]}if(primitive.deltaT!=null){const[dxT,dyT]=primitive.deltaT;x2+=dxT*nvec[0]-dyT*nvec[1];y2+=dxT*nvec[1]+dyT*nvec[0]}const line=dom.createSVG("line",{x1:toStr(x1),y1:toStr(y1),x2:toStr(x2),y2:toStr(y2)});const scale=6/Math.sqrt(2);const l=[x2-(nvec[0]-nvec[1])*scale,y2-(nvec[0]+nvec[1])*scale];const r=[x2-(nvec[0]+nvec[1])*scale,y2-(nvec[1]-nvec[0])*scale];const triangle=dom.createSVG("polygon",{points:[[x2,y2],l,r].map(p=>p.map(toStr).join(",")).join(" ")});dom.setAttributes(line,style);dom.addEventListeners(line,events);dom.setAttributes(triangle,style);dom.addEventListeners(triangle,events);children.push(line,triangle)}}else if(primitive.kind==="loop"){const[x,y]=this.fwd(primitive.coords);const line=dom.createSVG("path",{d:"M -6,-20 C -18,-35 -6,-40 0,-40 C 6,-40 18,-35 7,-22",fill:"none",transform:"translate("+toStr(x)+" "+toStr(y)+") rotate("+toStr(primitive.angle)+")"});const triangle=dom.createSVG("polygon",{points:"4.95,-26.63 12.63,-23.05 7,-21",transform:"translate("+toStr(x)+" "+toStr(y)+") rotate("+toStr(primitive.angle)+")"});dom.setAttributes(line,style);line.setAttribute("fill","none");dom.addEventListeners(line,events);dom.setAttributes(triangle,style);dom.addEventListeners(triangle,events);children.push(line,triangle)}else if(primitive.kind==="__label"){const[x1,y1]=this.fwd(primitive.p1);const[x2,y2]=this.fwd(primitive.p2);const nvec=[x2-x1,y2-y1];const scale=-primitive.offset/linalg.norm2(nvec);const x=0.5*(x1+x2)+nvec[1]*scale;const y=0.5*(y1+y2)-nvec[0]*scale;const angle=180*Math.atan2(nvec[1],nvec[0])/Math.PI;let textAnchor="middle";if(angle>15&&angle<165)textAnchor="start";if(angle<-15&&angle>-165)textAnchor="end";const text=dom.createSVG("text",{"x":toStr(x),"y":toStr(y),"text-anchor":textAnchor,"transform":"rotate("+0+" "+toStr(x)+" "+toStr(y)+")"},[primitive.text]);dom.setAttributes(text,style);dom.addEventListeners(text,events);children.push(text)}else{throw new Error("unknown primitive kind '"+primitive.kind+"'")}}}dom.replaceChildren(this.node,children)}fwd(coords){return this.shapePlot.scaleFwd(coords)}}

},{"./dom.js":1,"./linalg.js":4,"./tools.js":7}]},{},[6]);
