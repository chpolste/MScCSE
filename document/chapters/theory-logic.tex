A temporal logic is an extension of propositional logic by a set of temporal connectives \cite[authoryears][Baier2008].
With these connectives, statements about the current and future state of a system can be expressed.
While formulae of propositional logic are evaluated with a single valuation of its atomic propositions, temporal logic formulae are evaluated with a sequence or a tree of valuations that describe the evolution of the system state in time.


\startsubsection[title={Linear Temporal Logic},reference=sec:theory-logic-ltl]

    Linear temporal logic (LTL) is an extension of propositional logic applied to discrete-time, infinite sequences of valuations of propositional atoms.
    LTL formulae are able to express the relative temporal order of events occurring in such sequences.
    As the name suggests, LTL is concerned with a linear, path-based understanding of time where every moment in time has a unique successor.

    LTL formulae over a set of atomic propositions $AP$ are formed from the grammar
    
    \startformula
        \varphi \coloncolonequals \True \mid a \mid \varphi_1 \wedge \varphi_2 \mid \neg \varphi \mid \Next \varphi \mid \varphi_1 \Until\, \varphi_2 \EndComma
    \stopformula

    where $a \in AP$ \cite[authoryears][Baier2008].
    $\wedge$ and $\neg$ are the known propositional operators \quotation{and} and \quotation{not}.
    $\Next$ and $\empty\Until\empty$ are temporal operators named \quotation{next} and \quotation{until}.
    $\True$ is the tautology symbol.
    Operator precedence is adopted from propositional logic where possible, $\Next$ binds as strongly as $\neg$ and $\Until$ takes precedence over all propositional binary operators.

    LTL formulae are interpreted over words $w = w_0 w_1 ... \in (2^{AP})^\omega$ constructed from an alphabet of valuations of the atomic propositions.
    The semantics of LTL is expressed by the satisfaction relation $\vDash$, given by 

    \startformula
        \startalign[n=3,align={right,left,left}]
            \NC w \vDash
            \NC \True
            \NC ~~\text{unconditionally (tautology),}
            \NR
            \NC w \vDash
            \NC a
            \NC \iff a \in w_0 \EndComma
            \NR
            \NC w \vDash
            \NC \neg \varphi
            \NC \iff w \nvDash \varphi \EndComma
            \NR
            \NC w \vDash
            \NC \varphi_1 \wedge \varphi_2
            \NC \iff w \vDash \varphi_1 \;\text{and}\; w \vDash \varphi_2 \EndComma
            \NR
            \NC w \vDash
            \NC \Next \varphi
            \NC \iff w_1 w_2 ... \vDash \varphi \EndComma
            \NR
            \NC w \vDash
            \NC \varphi_1 \Until\, \varphi_2
            \NC \iff \exists j \ge 0 : w_j w_{j+1} ... \vDash \varphi_2 \;\text{and}\; \forall 0 \le i \lt j : w_i w_{i+1} ... \vDash \varphi_1 \EndPeriod
            \NR
        \stopalign
    \stopformula

    Other connectives can be derived for convenience, for example

    \startformula
        \startalign[n=3,align={right,left,middle}]
            \NC \varphi_1 \vee \varphi_2
            \NC \colonequals \neg(\neg \varphi_1 \wedge \neg \varphi_2) ~~~
            \NC \text{\quotation{or},}
            \NR
            \NC \Finally \varphi
            \NC \colonequals \True \,\Until\, \varphi
            \NC \text{\quotation{finally},}
            \NR
            \NC \Globally \varphi
            \NC \colonequals \neg \Finally \neg \varphi
            \NC \text{\quotation{globally}.}
            \NR
        \stopalign
    \stopformula

    Consider a transition system with states $2^{AP}$, such that the set of atomic propositions $AP$ coincides with that of an LTL formula $\varphi$.
    The evolution of this transition system when starting in state $s$ generates words $w = w_0 w_1 ...$, where $w_0 = s$, over the alphabet $2^{AP}$.
    The function
    
    \startformula
        \Function{{\mathrm Words}}{2^{AP}}{(2^{AP})^\omega}
    \stopformula

    associates a state with all words that can be generated by starting in this state and following the transitions of the system.
    The semantics of LTL is extended to a state-based notion in the following way:

    \startformula
        s \vDash \varphi \iff \forall w \in {\mathrm Words}(s) : w \vDash \varphi \EndPeriod
    \stopformula

\stopsubsection


\startsubsection[title={Other Temporal Logics},reference=sec:theory-logic-other]

    Whenever there are multiple futures possible in a moment, the linear understanding of time considers every future individually.
    In a branching time interpretation, the future is seen as a tree that branches out whenever a moment allows for more than one future.
    Computation Tree Logic (CTL) is a temporal logic with this understanding of time.
    CTL can reason over a branching future with the quantifiers $\exists$ (there is some future) and $\forall$ (for all possible futures).
    While the expressiveness of CTL overlaps with that of LTL, properties exists that can only be expressed in one but not the other \cite[authoryears][Baier2008].

    The understanding of time as linear or branching is not the only concept that influences the construction of a temporal logic.
    While LTL and CTL are only concerned with the ordering of time, there are also temporal logics that include the concept of a clock.
    In such logics properties like \quotation{in less than 10 time units} or \quotation{for the next 10 time units} can be expressed.
    Quantitative and qualitative properties are of interest when verifying probabilistic systems and systems that associate rewards with certain behaviour.
    Probabilistic Computation Tree Logic incorporates quantitative measures of certainty with the addition of a probabilistic operator to CTL.
    The certainty of temporal logic properties can also be quantified on the semantic level by changing the satisfaction relation \cite[authoryears][Baier2008].
    The boolean question \quotation{Does formula $\varphi$ hold?} can therefore be transformed into a quantitative inquiry such as \quotation{With which probability does formula $\varphi$ hold?} in the probabilistic setting.

\stopsubsection


\startreusableMPgraphic{automaton-reachability}
    with spacing((30,10)) matrix.a(3,6);
    node_dash.a[1][1](btex $q_0$ etex);
    node_double.a[1][4](btex $q_1$ etex);
    incoming(0, "") (a[1][1]) 180;
    loop.rt(.4, btex \small ${\neg \phi}$ etex) (a[1][1]) 90;
    arrow.top(.5, btex \small ${\phi}$ etex) (a[1][1],a[1][4]) a[1][1].c..a[1][4].c;
    loop.rt(.4, btex \small ${\True}$ etex) (a[1][4]) 90;
\stopreusableMPgraphic

\startreusableMPgraphic{automaton-avoidance}
    with spacing((30,10)) matrix.a(3,6);
    node_dash.a[1][1](btex $q_0$ etex);
    node_double.a[1][4](btex $q_1$ etex);
    incoming(0, "") (a[1][1]) 180;
    loop.rt(.4, btex \small ${\neg \theta}$ etex) (a[1][1]) 90;
    arrow.top(.5, btex \small ${\phi}$ etex) (a[1][1],a[1][4]) a[1][1].c..a[1][4].c;
    loop.rt(.4, btex \small ${\True}$ etex) (a[1][4]) 90;
\stopreusableMPgraphic

\startreusableMPgraphic{automaton-recurrence}
    with spacing((30,10)) matrix.a(3,6);
    node_dash.a[1][1](btex $q_0$ etex);
    node_double.a[1][4](btex $q_1$ etex);
    incoming(0, "") (a[1][1]) 180;
    loop.rt(.4, btex \small ${\neg \phi}$ etex) (a[1][1]) 90;
    arrow.top(.5, btex \small ${\phi}$ etex) (a[1][1],a[1][4]) a[1][1].c..a[0][2].c..a[0][3].c..a[1][4].c;
    loop.rt(.4, btex \small ${\phi}$ etex) (a[1][4]) 90;
    arrow.bot(.5, btex \small ${\neg \phi}$ etex) (a[1][4],a[1][1]) a[1][4].c..a[2][3].c..a[2][2].c..a[1][1].c;
\stopreusableMPgraphic

\startreusableMPgraphic{automaton-safety}
    with spacing((30,10)) matrix.a(3,3);
    node.a[1][1](btex $q_0$ etex);
    incoming(0, "") (a[1][1]) 180;
    loop.rt(.4, btex \small ${\neg \theta}$ etex) (a[1][1]) 90;
\stopreusableMPgraphic

\startreusableMPgraphic{automaton-eventualsafety}
    with spacing((30,10)) matrix.a(3,6);
    node_dash.a[1][1](btex $q_0$ etex);
    node.a[1][4](btex $q_1$ etex);
    incoming(0, "") (a[1][1]) 180;
    loop.rt(.4, btex \small ${\,\theta}$ etex) (a[1][1]) 90;
    arrow.top(.5, btex \small ${\neg \theta}$ etex) (a[1][1],a[1][4]) a[1][1].c..a[0][2].c..a[0][3].c..a[1][4].c;
    loop.rt(.4, btex \small ${\neg \theta}$ etex) (a[1][4]) 90;
    arrow.bot(.5, btex \small ${\theta}$ etex) (a[1][4],a[1][1]) a[1][4].c..a[2][3].c..a[2][2].c..a[1][1].c;
\stopreusableMPgraphic

\startsubsection[title={Automata for LTL Objectives},reference=sec:theory-logic-automata]

    For every LTL formula, an \omega-automaton can be constructed such that the automaton accepts all words that satisfy the formula and rejects all words that do not satisfy the formula.
    Formula-to-automaton translation is a key component of LTL model checking because it allows to systematically combine the system model and the specification it is verified against.
    Tools for the automatic translation of LTL formulae to various types of \omega-automata have beed developed, e.g. by \cite[Kretinsky2018], \cite[Duret2016] and \cite[Gastin2001].

    \placetable[top][tab:theory-logic-objectives]{
        Description of five basic linear time objectives and their translations into \omega-automata with one-pair Streett acceptance condition.
        The highlighting of states from the acceptance sets is analogous to Figure \in[fig:theory-automaton-example].
    }{
        \setupTABLE[frame=off,option=stretch]
        \setupTABLE[r][each][bottomframe=on]
        \setupTABLE[r][last][bottomframe=off]
        \setupTABLE[c][1][align={justified,lohi}]
        \setupTABLE[c][2][toffset=2mm,align={middle,lohi}]
        \bTABLE
            \bTR
                \bTD \underbar{Reachability}: $\Finally \phi$. \par Eventually satisfy $\phi$. \par One-pair Streett condition: $(\Set{q_0}, \Set{q_1})$ \eTD
                \bTD {\leavevmode\reuseMPgraphic{automaton-reachability}} \eTD
            \eTR
            \bTR
                \bTD \underbar{Reachability/Avoidance}: $\neg \theta \,\Until\, \phi$. \par Avoid satisfying $\theta$ until a $\phi$ is satisfied. \par One-pair Streett condition: $(\Set{q_0}, \Set{q_1})$ \eTD
                \bTD {\leavevmode\reuseMPgraphic{automaton-avoidance}} \eTD
            \eTR
            \bTR
                \bTD \underbar{Recurrence}: $\Globally \Finally \phi$. \par Satisfy $\phi$ again and again. \par One-pair Streett condition: $(\Set{q_0}, \Set{q_1})$ \eTD
                \bTD {\leavevmode\reuseMPgraphic{automaton-recurrence}} \eTD
            \eTR
            \bTR
                \bTD \underbar{Safety}: $\Globally \neg \theta$. \par Forever avoid satisfaction of $\theta$. \par Acceptance expressed through incompletness of $\delta$. \eTD
                \bTD {\leavevmode\reuseMPgraphic{automaton-safety}} \eTD
            \eTR
            \bTR
                \bTD \underbar{Eventual Safety}: $\Finally \Globally \neg \theta$. \par Eventually, $\theta$ must never be satisfied. \par One-pair Streett condition: $(\Set{q_0}, \emptyset)$ \eTD
                \bTD {\leavevmode\reuseMPgraphic{automaton-eventualsafety}} \eTD
            \eTR
        \eTABLE
    }

    \in{Table}[tab:theory-logic-objectives] presents five basic LTL formulae together with corresponding \omega-automata.
    The formulae are specified over words over an alphabet of valuations of the propositional atoms $\phi$ and $\theta$.
    Transition labels of the automata are propositional formulas.
    A transition is taken if the current symbol (i.e.\ valuation) of the run-inducing word satisfies its associated propositional formula.
    The chosen acceptance conditions are one-pair Streett tuples for all but the safety automaton which expresses acceptance sufficiently through an incomplete transition relation.

\stopsubsection


\startsubsection[title={Fragments of LTL},reference=sec:theory-logic-fragments]

    The complexity of an LTL model-checking procedure is goverened by the cost of the translation of the specification formula to an automaton and the analysis of the synchronized product of the automaton and system model.
    The size of a deterministic finite automaton (DFA) corresponding to an LTL formula is doubly exponential in the number of subformulae in the worst case \cite[authoryears][Baier2008].
    The worst-case time complexity of a DFA-based model checking procedure for LTL is therefore at least doubly exponential in the size of the specification, assuming that the procedure has to visit each state in the product of automaton and system model at least once.
    Restricting specifications to a fragment of LTL with reduced expressivity can limit the exponential blow-up in the automaton translation or simplify the analysis procedure.
    If designed carefully, such LTL fragments can still include many properties that are relevant in practical applications.

    The class of LTL formulae with form

    \startformula
        \Big( \bigwedge_{i = 1 ... n} \Globally \Finally \phi_i \Big) \; \rightarrow \; \Big( \bigwedge_{i = 1 ... m} \Globally \Finally \mu_i \Big) \EndComma
    \stopformula

    where $\phi_i$ and $\mu_i$ are propositional formulae, was named General Reactivity(1) (GR(1)) and popularized by \cite[Piterman2005].
    The complexity of model checking procedures with GR(1) specifications is polynomial in the size of the specification which is a substantial reduction from the doubly exponential complexity of full LTL \cite[authoryears][Piterman2005].
    An extended variant of GR(1) contains all formulae

    \startformula
        \Big( \bigwedge_{i = 1 ... n} \varphi_i \Big) \; \rightarrow \; \Big( \bigwedge_{i = 1 ... m} \psi_i \Big) \EndComma
    \stopformula

    where $\varphi_i$ and $\psi_i$ are LTL formulae representable by deterministic automata with Büchi acceptance condition \cite[authoryears][Piterman2005].
    Model checking procedures for GR(1) are generally compatible with extended GR(1).
    In both fragments, a deterministic one-pair Streett automaton of polynomial complexity in the size of the formula (GR(1)) or the number of Büchi conditions (extended GR(1)) can be constructed from the specification \cite[authoryears][Kesten2005].

    LTL formulae are interpreted over words of infinite length.
    For some formulas, satisfiability of a word can be decided already after a finite prefix.
    Any infinite continuation of the word after this prefix has no impact on the satisfiability of the formula.
    A language $\Language \subseteq \Alphabet^\omega$ over the alphabet $\Alphabet$ is called a co-safety language if and only if every word $w \in \Language$ has a prefix $x \in \Alphabet^\ast$ such that $x \cdot y \in \Language$ for all $y \in \Alphabet^\omega$, where $\cdot$ is the concatenation operator \cite[authoryears][Kupferman2001].
    The fragment of co-safe LTL contains all formulae whose language is a co-safety language.
    A co-safe LTL formula can be identified syntactically:
    All formulae that can be written in positive normal form (where negation occurs only in front of atomic propositions) and use only the temporal operators $\Next$ and $\Until$ are co-safe \cite[authoryears][PrasadSistla1994].
    Co-safety languages can be represented by deterministic \omega-automata with an acceptance condition that requires reaching a state in a set of final states.
    Model checking with co-safe LTL specifications can therefore be reduced to a reachability analysis problem with respect to these final states \cite[authoryears][Kupferman2001].
    Note that every one-pair Streett automaton with $E \cup F = Q$ and $\Transition(q, \sigma) = q$ for all $q \in F$ and for all $\sigma \in \Alphabet$ defines a co-safety language.
    Therefore, the reachability and reachability/avoidance objectives in Table \in[tab:theory-logic-objectives] are co-safe.
    
    Finally, the class of $\Next$-free LTL formulae is introduced, i.e.\ the class of all LTL formulae in which the $\Next$ operator does not appear.
    Two words $w$ and $w'$ over an alphabet $\Alphabet$ are called stuttering equivalent if and only if there exist two integer sequences $i_0 < i_1 < ...$ and $j_0 < j_1 < ...$ and a word $v_0 v_1 ... \in \Alphabet^\omega$ such that 
    
    \startformula
        w = (v_0)^{i_0} (v_1)^{i_1} ... \MidAnd w' = (v_0)^{j_0} (v_1)^{j_1} ... \EndPeriod
    \stopformula

    If a word satisfies a $\Next$-free LTL formula, all stuttering equivalent words also satisfy this formula \cite[authoryears][Baier2008].

\stopsubsection

