(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.renderTeX=renderTeX;exports.create=create;exports.createSVG=createSVG;exports.nodeify=nodeify;exports.setAttributes=setAttributes;exports.addEventListeners=addEventListeners;exports.removeChildren=removeChildren;exports.appendChildren=appendChildren;exports.replaceChildren=replaceChildren;exports.appendAfter=appendAfter;exports.createButton=createButton;exports.fromChildElement=fromChildElement;exports.setCursor=setCursor;exports.popupDownload=popupDownload;exports.infoBox=infoBox;exports.snLabel=exports.Keybindings=exports.SVGNS=exports.TEXTAREA=exports.TABLE=exports.SPAN=exports.SELECT=exports.P=exports.OPTION=exports.LABEL=exports.INPUT=exports.H3=exports.FORM=exports.DIV=exports.BUTTON=exports.A=void 0;function renderTeX(tex,element){katex.render(tex,element,{throwOnError:false});return element}function create(tag,attributes,children){const node=document.createElement(tag);if(attributes!=null)setAttributes(node,attributes);if(children!=null)appendChildren(node,children);return node}const A=(a,c)=>create("a",a,c);exports.A=A;const BUTTON=(a,c)=>create("button",a,c);exports.BUTTON=BUTTON;const DIV=(a,c)=>create("div",a,c);exports.DIV=DIV;const FORM=(a,c)=>create("form",a,c);exports.FORM=FORM;const H3=(a,c)=>create("h3",a,c);exports.H3=H3;const INPUT=(a,c)=>create("input",a,c);exports.INPUT=INPUT;const LABEL=(a,c)=>create("label",a,c);exports.LABEL=LABEL;const OPTION=(a,c)=>create("option",a,c);exports.OPTION=OPTION;const P=(a,c)=>create("p",a,c);exports.P=P;const SELECT=(a,c)=>create("select",a,c);exports.SELECT=SELECT;const SPAN=(a,c)=>create("span",a,c);exports.SPAN=SPAN;const TABLE=(a,c)=>create("table",a,c);exports.TABLE=TABLE;const TEXTAREA=(a,c)=>create("textarea",a,c);exports.TEXTAREA=TEXTAREA;const SVGNS="http://www.w3.org/2000/svg";exports.SVGNS=SVGNS;function createSVG(tag,attributes,children){const node=document.createElementNS(SVGNS,tag);if(attributes!=null)setAttributes(node,attributes);if(children!=null)appendChildren(node,children);return node}function nodeify(item){return typeof item==="string"?document.createTextNode(item):item}function setAttributes(node,attributes){for(let name in attributes){node.setAttribute(name,attributes[name])}}function addEventListeners(node,handlers){for(let event in handlers){node.addEventListener(event,handlers[event])}}function removeChildren(node){while(node.firstChild){node.removeChild(node.firstChild)}}function appendChildren(parentNode,children){for(let child of children){parentNode.appendChild(nodeify(child))}}function replaceChildren(parentNode,childNodes){let i=0;for(let childNode of childNodes){const oldNode=parentNode.childNodes[i];const newNode=nodeify(childNode);if(oldNode!=null){parentNode.replaceChild(newNode,oldNode)}else{parentNode.appendChild(newNode)}i++}while(parentNode.childNodes[i]!=null){parentNode.removeChild(parentNode.childNodes[i])}}function appendAfter(parent,before,after){const sibling=before.nextSibling;if(sibling==null){parent.appendChild(nodeify(after))}else{parent.insertBefore(nodeify(after),sibling)}}function createButton(a,c,f){const button=BUTTON(a,c);button.addEventListener("click",f);return button}function fromChildElement(node,e){let tgt=e.relatedTarget;if(tgt instanceof Node){while(tgt!=null&&tgt!==node){tgt=tgt.parentNode}}return tgt===node}function setCursor(cursor){let body=document.body;if(body!=null){body.style.cursor=cursor}}function popupDownload(content,filename){const body=document.body;if(body!=null){const a=document.createElement("a");a.href=content;a.setAttribute("download",filename);body.appendChild(a);a.click();body.removeChild(a)}else{window.open(content)}}class Keybindings{constructor(){this.bindings=new Map;document.addEventListener("keypress",e=>this.keyPress(e))}bind(key,callback){this.bindings.set(key,callback)}keyPress(event){const callback=this.bindings.get(event.key);if(event.target===document.body&&!event.ctrlKey&&!event.altKey&&callback!=null){callback(event)}}}exports.Keybindings=Keybindings;const SPLIT_LABEL_REGEX=/^([a-zA-Z]+)(\d+)$/;const NUM_TSPAN_ATTRS={"dy":"2","font-size":"0.8em"};const snLabel={split:function(text){const match=SPLIT_LABEL_REGEX.exec(text);return match==null?[text,""]:[match[1],match[2]]},toTeX:function(text){const[name,num]=snLabel.split(text);return num.length===0?name:name+"_"+num},toHTML:function(text){const[name,num]=snLabel.split(text);return SPAN({},num.length===0?[name]:[name,create("sub",{},[num])])},toSVG:function(text){const[name,num]=snLabel.split(text);return createSVG("text",{},num.length===0?[name]:[name,createSVG("tspan",NUM_TSPAN_ATTRS,[num])])}};exports.snLabel=snLabel;function infoBox(contentID){const node=DIV({"class":"info-button"},["?"]);node.addEventListener("mouseover",e=>{const content=document.getElementById(contentID);if(content!=null){content.style.display="block";content.style.top=String(node.offsetTop)+"px";content.style.left=String(node.offsetLeft-content.offsetWidth-5)+"px"}});node.addEventListener("mouseout",e=>{const content=document.getElementById(contentID);if(content!=null){content.style.display="none"}});return node}

},{}],2:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.autoProjection=autoProjection;exports.Horizontal1D=exports.Cartesian2D=exports.Layer=exports.Figure=void 0;var linalg=_interopRequireWildcard(require("./linalg.js"));var _tools=require("./tools.js");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}}newObj.default=obj;return newObj}}class Figure extends _tools.ObservableMixin{constructor(){super();this.layers=[]}newLayer(style){let layer=new Layer(this,style);this.layers.push(layer);this.notify({event:"newLayer",layer:layer});return layer}}exports.Figure=Figure;class Layer extends _tools.ObservableMixin{constructor(figure,style){super();this.figure=figure;this._shapes=[];this.style=style!=null?style:{}}get shapes(){return this._shapes}set shapes(shapes){this._shapes=Array.from(shapes);this.notify()}}exports.Layer=Layer;function largestPowerOf10In(x){return Math.pow(10,Math.floor(Math.log10(x)))}function linearTicks(min,max,n){const diff=(max-min)/n;const lp10=largestPowerOf10In(diff);const increment=Math.ceil(diff/lp10)*lp10;let init;if(min<=0&&0<=max){init=0}else if(max-min>lp10*10){init=Math.ceil(min/lp10/10)*lp10*10}else{init=Math.ceil(min/lp10)*lp10}const ticks=[];for(let i=-n;i<=n;i++){const tick=init+i*increment;if(min<tick&&tick<max)ticks.push(tick)}return ticks}class Cartesian2D{constructor(limX,limY){this.minX=limX[0];this.maxX=limX[1];this.minY=limY[0];this.maxY=limY[1]}get center(){return[(this.minX+this.maxX)/2,(this.minY+this.maxY)/2]}fwd(coords){let[x,y]=coords;return[(x-this.minX)/(this.maxX-this.minX),(y-this.minY)/(this.maxY-this.minY)]}bwd(coords){let[x,y]=coords;return[x*(this.maxX-this.minX)+this.minX,y*(this.maxY-this.minY)+this.minY]}project(shape){let primitives=[];if(shape.kind==="polytope"){primitives.push({kind:"polygon",points:shape.vertices.map(vertex=>this.fwd(vertex))})}else if(shape.kind==="arrow"){primitives.push({kind:"arrow",origin:this.fwd(shape.origin),target:this.fwd(shape.target)})}else if(shape.kind==="label"){primitives.push({kind:"label",coords:this.fwd(shape.coords),text:shape.text})}else if(shape.kind==="marker"){primitives.push({kind:"marker",coords:this.fwd(shape.coords),size:shape.size})}else if(shape.kind==="halfspace"){const normal=shape.normal;const offset=shape.offset;const cs=[[this.minX,this.minY],[this.minX,this.maxY],[this.maxX,this.maxY],[this.maxX,this.minY]];const csIn=cs.map(v=>linalg.dot(v,normal)-offset<linalg.TOL);const vertices=[];if(csIn[0])vertices.push(cs[0]);if((0,_tools.xor)(csIn[0],csIn[1]))vertices.push([cs[0][0],(offset-normal[0]*cs[0][0])/normal[1]]);if(csIn[1])vertices.push(cs[1]);if((0,_tools.xor)(csIn[1],csIn[2]))vertices.push([(offset-normal[1]*cs[1][1])/normal[0],cs[1][1]]);if(csIn[2])vertices.push(cs[2]);if((0,_tools.xor)(csIn[2],csIn[3]))vertices.push([cs[2][0],(offset-normal[0]*cs[2][0])/normal[1]]);if(csIn[3])vertices.push(cs[3]);if((0,_tools.xor)(csIn[3],csIn[0]))vertices.push([(offset-normal[1]*cs[3][1])/normal[0],cs[3][1]]);primitives.push({kind:"polygon",points:vertices.map(v=>this.fwd(v))})}else if(shape.kind==="vectorField"){const s=shape.scaling==null?1:shape.scaling;for(let x of linearTicks(this.minX,this.maxX,shape.n==null?10:shape.n[0])){for(let y of linearTicks(this.minY,this.maxY,shape.n==null?10:shape.n[1])){const o=this.fwd([x,y]);const t=this.fwd(shape.fun([x,y]));primitives.push({kind:"arrow",origin:o,target:linalg.add(o,linalg.sub(t,o).map(_=>s*_))})}}}else if(shape.kind==="state"){const coords=this.fwd(shape.coords);primitives.push({kind:"marker",coords:coords,size:20,style:shape.member.indexOf("E")!==-1?{"stroke-dasharray":"5 3"}:{}});if(shape.member.indexOf("F")!==-1){primitives.push({kind:"marker",coords:coords,size:16})}}else if(shape.kind==="transition"){primitives.push({kind:"arrow",origin:this.fwd(shape.origin),target:this.fwd(shape.target),deltaO:[20,-6],deltaT:[-21,-6]})}else if(shape.kind==="loop"){primitives.push({kind:"loop",coords:this.fwd(shape.coords),angle:shape.angle})}else if(shape.kind==="transitionLabel"){primitives.push({kind:"__label",text:shape.text,p1:this.fwd(shape.origin),p2:this.fwd(shape.target),offset:-17})}else if(shape.kind==="loopLabel"){const[x,y]=shape.coords;const dx=Math.cos(Math.PI*shape.angle/180);const dy=-Math.sin(Math.PI*shape.angle/180);primitives.push({kind:"__label",text:shape.text,p1:this.fwd([x-dx,y-dy]),p2:this.fwd([x+dx,y+dy]),offset:-49})}else{throw new Error("unknown shape kind '"+shape.kind+"' (Cartesian2D)")}return primitives}zoom(factor){let center=this.center;let lengthX=(this.maxX-this.minX)/2;let lengthY=(this.maxY-this.minY)/2;let limX=[center[0]-lengthX*factor,center[0]+lengthX*factor];let limY=[center[1]-lengthY*factor,center[1]+lengthY*factor];return new Cartesian2D(limX,limY)}translate(start,end){let diffX=end[0]-start[0];let diffY=end[1]-start[1];let limX=[this.minX-diffX,this.maxX-diffX];let limY=[this.minY-diffY,this.maxY-diffY];return new Cartesian2D(limX,limY)}getXTicks(n){return linearTicks(this.minX,this.maxX,n).map(t=>[this.fwd([t,0])[0],(0,_tools.n2s)(t)])}getYTicks(n){return linearTicks(this.minY,this.maxY,n).map(t=>[this.fwd([0,t])[1],(0,_tools.n2s)(t)])}}exports.Cartesian2D=Cartesian2D;class Horizontal1D{constructor(lim,ylim){this.minX=lim[0];this.maxX=lim[1];this.minY=ylim==null?0.4:ylim[0];this.maxY=ylim==null?0.6:ylim[1]}get center(){return[(this.minX+this.maxX)/2]}fwd(coords){return[(coords[0]-this.minX)/(this.maxX-this.minX),0.5]}bwd(coords){return[coords[0]*(this.maxX-this.minX)+this.minX]}project(shape){let primitives=[];if(shape.kind==="polytope"){if(shape.vertices.length<2){return[]}let[l,r]=shape.vertices.map(vertex=>this.fwd(vertex));primitives.push({kind:"polygon",points:[[l[0],this.maxY],[l[0],this.minY],[r[0],this.minY],[r[0],this.maxY]]})}else if(shape.kind==="arrow"){primitives.push({kind:"arrow",origin:this.fwd(shape.origin),target:this.fwd(shape.target)})}else if(shape.kind==="label"){primitives.push({kind:"label",coords:this.fwd(shape.coords),text:shape.text})}else if(shape.kind==="marker"){primitives.push({kind:"marker",coords:this.fwd(shape.coords),size:shape.size})}else if(shape.kind==="halfspace"){const normal=shape.normal;const offset=shape.offset;let left=0;let right=1;if(normal[0]<0){left=Math.max(left,this.fwd([-offset])[0])}else{right=Math.min(right,this.fwd([offset])[0])}if(left<right){primitives.push({kind:"polygon",points:[[left,0],[left,1],[right,1],[right,0]]})}}else if(shape.kind==="vectorField"){const s=shape.scaling==null?1:shape.scaling;for(let x of linearTicks(this.minX,this.maxX,shape.n==null?10:shape.n[0])){const o=this.fwd([x]);const t=this.fwd(shape.fun([x]));primitives.push({kind:"arrow",origin:o,target:linalg.add(o,linalg.sub(t,o).map(_=>s*_))})}}else{throw new Error("unknown shape kind '"+shape.kind+"' (Horizontal1D)")}return primitives}zoom(factor){let center=this.center[0];return new Horizontal1D([center-(center-this.minX)*factor,center+(this.maxX-center)*factor],[this.minY,this.maxY])}translate(start,end){let diff=end[0]-start[0];return new Horizontal1D([this.minX-diff,this.maxX-diff],[this.minY,this.maxY])}getXTicks(n){return linearTicks(this.minX,this.maxX,n).map(t=>[this.fwd([t])[0],(0,_tools.n2s)(t)])}getYTicks(n){return[[0.5,"1D"]]}}exports.Horizontal1D=Horizontal1D;const PADDING=1.2;function autoProjection(aspectRatio,...ranges){let dim=ranges.length;if(dim==0){return new Cartesian2D([NaN,NaN],[NaN,NaN])}else if(dim==1){let[min,max]=ranges[0];let radius=(max-min)/2*PADDING;let mid=(min+max)/2;return new Horizontal1D([mid-radius,mid+radius])}else if(dim==2){let[minX,maxX]=ranges[0];let[minY,maxY]=ranges[1];let radiusX=(maxX-minX)/2*PADDING;let radiusY=(maxY-minY)/2*PADDING;let midX=(minX+maxX)/2;let midY=(minY+maxY)/2;let ratio=radiusX/radiusY;let factorX=ratio<aspectRatio?aspectRatio/ratio:1;let factorY=ratio>aspectRatio?ratio/aspectRatio:1;return new Cartesian2D([midX-radiusX*factorX,midX+radiusX*factorX],[midY-radiusY*factorY,midY+radiusY*factorY])}else{throw new Error("dim not supported")}}

},{"./linalg.js":7,"./tools.js":12}],3:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.Union=exports.Polygon=exports.Interval=exports.Polytope=exports.Halfspace=exports.TOL=void 0;var linalg=_interopRequireWildcard(require("./linalg.js"));var _tools=require("./tools.js");var _parser=require("./parser.js");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}}newObj.default=obj;return newObj}}const TOL=linalg.TOL;exports.TOL=TOL;function cartesian(...tuples){let cart=[[]];for(let tuple of tuples){cart=[].concat(...cart.map(xs=>tuple.map(y=>xs.concat([y]))))}return cart}function angleOrder(v){const angle=Math.atan2(v[1],v[0]);return angle===Math.PI?angle-2*Math.PI:angle}function angleCCW(g,h){const det=g[0]*h[1]-g[1]*h[0];const dot=g[0]*h[0]+g[1]*h[1];let angle=Math.atan2(det,dot);if(angle<0){angle=angle+2*Math.PI}return angle===2*Math.PI?0:angle}function isCCWTurn(p,q,r,zero){return(p[0]-r[0])*(q[1]-r[1])-(p[1]-r[1])*(q[0]-r[0])>zero}function reduceHullPart(hull,p,zero){while(hull.length>1&&!isCCWTurn(hull[hull.length-2],hull[hull.length-1],p,zero)){hull.pop()}}function halfplaneIntersection(g,h){const[g0,g1]=g.normal;const[h0,h1]=h.normal;const det=g0*h1-g1*h0;if(Math.abs(det)<TOL){return null}else{return[(h1*g.offset-g1*h.offset)/det,(g0*h.offset-h0*g.offset)/det]}}const hsieParse=(0,_parser.ASTParser)(/\+|-|([0-9\.]+\s*\*?\s*[a-z]?)|[0-9\.]+|[a-z]/,[{op:"+",precedence:20,associativity:-1},{op:"-",precedence:20,associativity:-1},{op:"+",precedence:50,associativity:0},{op:"-",precedence:50,associativity:0}]);function hsieSplit(text){const parts=text.split(/\s*([<>]=?)\s*/);if(parts.length!=3)throw new _parser.ParseError("not a valid inequality (requires exactly one of <=, <, >, >=)");return[hsieParse(parts[0]),parts[1][0],hsieParse(parts[2])]}const hsieNumVarPattern=/^((?:\d+(?:\.\d+)?)|(?:\.\d+))?\s*\*?\s*([a-z])?$/;function hsieTerms(node,flip){if(typeof node==="string"){const match=node.match(hsieNumVarPattern);if(match==null)throw new _parser.ParseError("unrecognized term "+node);return[{coefficient:(flip?-1:1)*(match[1]==null?1:parseFloat(match[1])),variable:match[2]==null?"":match[2]}]}else if(node.op==="-"||node.op==="+"){const isMinus=node.op==="-";const isUnary=node.args.length===1;const out=hsieTerms(node.args[0],isUnary&&isMinus?!flip:flip);if(!isUnary)out.push(...hsieTerms(node.args[1],isMinus?!flip:flip));return out}else{throw new _parser.ParseError("unexpected operator "+node.op)}}class Halfspace{constructor(normal,offset){this.normal=normal;this.offset=offset;this.dim=normal.length}static deserialize(json){return new Halfspace(json.normal,json.offset)}static normalized(normal,offset){let norm=linalg.norm2(normal);if(norm<TOL){offset=offset===0?Infinity:Math.sign(offset)*Infinity;norm=1}return new Halfspace(normal.map(x=>x/norm),offset/norm)}static parse(text,variables){const[lhs,comp,rhs]=hsieSplit(text);const terms=hsieTerms(lhs,comp===">").concat(hsieTerms(rhs,comp==="<"));let offset=0;let normal=new Array(variables.length);normal.fill(0);for(let term of terms){if(term.variable===""){offset-=term.coefficient}else{const idx=variables.indexOf(term.variable);if(idx<0)throw new _parser.ParseError("unexpected variable '"+term.variable+"'");normal[idx]+=term.coefficient}}return Halfspace.normalized(normal,offset)}get isInfeasible(){return this.offset===-Infinity}get isTrivial(){return this.offset===Infinity}applyRight(m){return Halfspace.normalized(linalg.applyRight(m,this.normal),this.offset)}contains(point){linalg.assertEqualDims(this.dim,point.length);return linalg.dot(this.normal,point)-this.offset<TOL}flip(){return new Halfspace(this.normal.map(x=>-x),-this.offset)}isSameAs(other){return linalg.areClose(this.normal,other.normal)&&Math.abs(this.offset-other.offset)<TOL}translate(v){return Halfspace.normalized(this.normal,this.offset+linalg.dot(this.normal,v))}serialize(){return{normal:this.normal,offset:this.offset}}}exports.Halfspace=Halfspace;class Polytope{constructor(vertices,halfspaces){if(this.constructor.name==="Polytope"){throw new TypeError("must not instanciate Polytope")}this._vertices=vertices;this._halfspaces=halfspaces;this._isEmpty=null}static deserialize(json){if(json.dim===1)return new Interval(json.vertices,null);if(json.dim===2)return new Polygon(json.vertices,null);throw new _tools.NotImplementedError}static empty(){throw new _tools.NotImplementedError}static hull(ps){throw new _tools.NotImplementedError}static intersection(hs){throw new _tools.NotImplementedError}static noredund(hs){throw new _tools.NotImplementedError}static ofDim(dim){if(dim===1)return Interval;if(dim===2)return Polygon;throw new _tools.NotImplementedError}get boundingBox(){if(this.isEmpty)return this;let bbox=cartesian(...this.extent);return this.constructor.hull(bbox)}get centroid(){throw new _tools.NotImplementedError}get extent(){let mins=new Array(this.dim);mins.fill(Infinity);let maxs=new Array(this.dim);maxs.fill(-Infinity);for(let vertex of this.vertices){vertex.map((x,i)=>{if(x<mins[i]){mins[i]=x}if(x>maxs[i]){maxs[i]=x}})}return _tools.arr.zip2(mins,maxs)}get halfspaces(){if(this._halfspaces!=null)return this._halfspaces;this._VtoH();return this.halfspaces}get isDisjunct(){return true}get isEmpty(){if(this._isEmpty!=null)return this._isEmpty;this._isEmpty=this._vertices!=null&&this._vertices.length<=this.dim||this._halfspaces!=null&&this._halfspaces.length<=this.dim||this.volume<TOL;return this._isEmpty}get polytopes(){return this.isEmpty?[]:[this]}get vertices(){if(this._vertices!=null)return this._vertices;this._HtoV();return this.vertices}get volume(){throw new _tools.NotImplementedError}apply(m){linalg.assertEqualDims(m[0].length,this.dim);return Polytope.ofDim(m.length).hull(this.vertices.map(v=>linalg.apply(m,v)))}applyRight(m){linalg.assertEqualDims(m.length,this.dim);return Polytope.ofDim(m[0].length).intersection(this.halfspaces.map(h=>h.applyRight(m)))}contains(p){linalg.assertEqualDims(this.dim,p.length);return _tools.iter.every(this.halfspaces.map(h=>h.contains(p)))}covers(other){if(this.isEmpty)return other.isEmpty;return other.remove(this).isEmpty}disjunctify(){return this}fulfils(predicate){linalg.assertEqualDims(this.dim,predicate.dim);return _tools.iter.every(this.vertices.map(v=>predicate.contains(v)))}hull(){return this}intersect(other){linalg.assertEqualDims(this.dim,other.dim);if(other instanceof Union){return other.intersect(this)}else{if(other.isEmpty||this.isEmpty)return other.constructor.empty();return this._intersectPolytope(other)}}intersects(other){for(let p of other.polytopes){if(!this.intersect(p).isEmpty)return true}return false}invert(){return this.constructor.hull(this.vertices.map(v=>v.map(x=>-x)))}isSameAs(other){if(other instanceof Union){return other.isSameAs(this)}else{const vs=this.vertices;const ws=other.vertices;if(this.dim!==other.dim||vs.length!==ws.length){return false}let idxoff=0;while(idxoff<vs.length){if(linalg.areClose(vs[idxoff],ws[0])){break}idxoff++}for(let i=0;i<vs.length;i++){if(!linalg.areClose(vs[(idxoff+i)%vs.length],ws[i])){return false}}return idxoff<vs.length}}minkowski(other){linalg.assertEqualDims(this.dim,other.dim);let points=[];for(let v of this.vertices){for(let w of other.vertices){points.push(linalg.add(v,w))}}return this.constructor.hull(points)}pontryagin(other){linalg.assertEqualDims(this.dim,other.dim);const ws=other.invert().vertices;const halfspaces=[];for(let h of this.halfspaces){for(let w of ws){halfspaces.push(h.translate(w))}}return this.constructor.noredund(halfspaces)}remove(other){const polytopes=other.polytopes;if(polytopes.length===0)return this;let k=0;let halfspaces=null;while(halfspaces==null&&k<polytopes.length){const intersection=this.intersect(polytopes[k]);if(intersection.isEmpty){k++}else{halfspaces=intersection.halfspaces}}if(halfspaces==null)return this;const out=[];let poly=this;for(let halfspace of halfspaces){const[_poly,polyCandidate]=poly.split(halfspace);if(!polyCandidate.isEmpty){if(k<polytopes.length-1){const toRemove=new Union(this.dim,polytopes.slice(k+1),null);out.push(...polyCandidate.remove(toRemove).polytopes)}else{out.push(polyCandidate)}}poly=_poly}return out.length===1?out[0]:new Union(this.dim,out,true)}sample(){const extent=this.extent;for(let i=0;i<10*this.dim;i++){const point=this.extent.map(([l,u])=>l+(u-l)*Math.random());if(this.contains(point))return point}return this.centroid}scale(factor){const c=this.centroid;return this.constructor.hull(this.vertices.map(v=>_tools.arr.zip2map((a,b)=>a+factor*(b-a),c,v)))}serialize(){return{dim:this.dim,vertices:this.vertices}}simplify(){return this}shatter(){throw new _tools.NotImplementedError}split(h){const intersection=this.constructor.intersection;return[intersection([...this.halfspaces,h]),intersection([...this.halfspaces,h.flip()])]}toUnion(){return new Union(this.dim,[this],true)}translate(v){linalg.assertEqualDims(v.length,this.dim);return this.constructor.hull(this.vertices.map(x=>linalg.add(x,v)))}union(other){return Union.from([this,...other.polytopes])}_intersectPolytope(other){return other.constructor.intersection([...this.halfspaces,...other.halfspaces])}_VtoH(){throw new _tools.NotImplementedError}_HtoV(){throw new _tools.NotImplementedError}}exports.Polytope=Polytope;class Interval extends Polytope{constructor(vertices,halfspaces){super(vertices,halfspaces);this.dim=1}static empty(){return new Interval([],[])}static hull(ps){ps.forEach(p=>linalg.assertEqualDims(p.length,1));let leftIdx=0;let rightIdx=0;for(let idx=1;idx<ps.length;idx++){if(ps[idx][0]<ps[leftIdx][0]){leftIdx=idx}if(ps[idx][0]>ps[rightIdx][0]){rightIdx=idx}}if(ps.length<2||linalg.areClose(ps[leftIdx],ps[rightIdx])){return Interval.empty()}else{return new Interval([ps[leftIdx],ps[rightIdx]],null)}}static intersection(halfspaces){return Interval.noredund(halfspaces)}static noredund(halfspaces){const hs=[];for(let h of halfspaces){linalg.assertEqualDims(h.dim,1);if(h.isInfeasible){return Interval.empty()}else if(!h.isTrivial){hs.push(h)}}let leftIdx=-1;let rightIdx=-1;for(let idx=0;idx<hs.length;idx++){if(hs[idx].normal[0]<0&&(leftIdx<0||hs[idx].offset<hs[leftIdx].offset)){leftIdx=idx}if(hs[idx].normal[0]>0&&(rightIdx<0||hs[idx].offset<hs[rightIdx].offset)){rightIdx=idx}}if(leftIdx<0||rightIdx<0||hs[rightIdx].offset+hs[leftIdx].offset<TOL){return Interval.empty()}else{return new Interval(null,[hs[leftIdx],hs[rightIdx]])}}get boundingBox(){return this}get centroid(){const[l,r]=this.vertices;return[(l[0]+r[0])/2]}get volume(){const vs=this.vertices;if(vs.length===0)return 0;return vs[1][0]-vs[0][0]}shatter(){const vertices=this.vertices;const centroid=this.centroid;return new Union(this.dim,[Interval.hull([centroid,vertices[0]]),Interval.hull([centroid,vertices[1]])],true)}_HtoV(){if(this._halfspaces==null){throw new _tools.ValueError}this._vertices=[[-this._halfspaces[0].offset],[this._halfspaces[1].offset]]}_VtoH(){if(this._vertices==null){throw new _tools.ValueError}const[left,right]=this._vertices;this._halfspaces=[new Halfspace([-1],-left[0]),new Halfspace([1],right[0])]}}exports.Interval=Interval;class Polygon extends Polytope{constructor(vertices,halfspaces){super(vertices,halfspaces);this.dim=2}static empty(){return new Polygon([],[])}static hull(ps){ps.forEach(p=>linalg.assertEqualDims(p.length,2));const points=ps.slice().sort((p,q)=>p[0]==q[0]?q[1]-p[1]:p[0]-q[0]);const ls=[];for(let i=0;i<points.length;i++){reduceHullPart(ls,points[i],0);ls.push(points[i])}const us=[];for(let i=points.length-1;i>=0;i--){reduceHullPart(us,points[i],0);us.push(points[i])}if(ls.length+us.length<5){return Polygon.empty()}const vs=[];for(let i=0;i<ls.length-1;i++){reduceHullPart(vs,ls[i],TOL);vs.push(ls[i])}for(let i=0;i<us.length-1;i++){reduceHullPart(vs,us[i],TOL);vs.push(us[i])}reduceHullPart(vs,vs[0],TOL);while(vs.length>1&&!isCCWTurn(vs[vs.length-1],vs[0],vs[1],TOL)){vs.shift()}return vs.length<3?Polygon.empty():new Polygon(vs,null)}static intersection(halfspaces){const hs=[];for(let h of halfspaces){linalg.assertEqualDims(h.dim,2);if(h.isInfeasible){return Polygon.empty()}hs.push(h)}return Polygon.noredund(hs.sort((g,h)=>{const gOrder=angleOrder(g.normal);const hOrder=angleOrder(h.normal);return gOrder==hOrder?angleCCW(g.normal,h.normal)-Math.PI:gOrder-hOrder}))}static noredund(halfplanes){const loop=[];const cuts=[];let idx=0;while(idx<halfplanes.length){const next=halfplanes[idx];if(next.isTrivial){idx++;continue}if(loop.length==0){loop.push(next);idx++;continue}const last=loop[loop.length-1];const angle=angleCCW(last.normal,next.normal);if(angle>Math.PI-TOL){return Polygon.empty()}const nextCut=halfplaneIntersection(last,next);if(nextCut==null){if(last.offset>next.offset){cuts.pop();loop.pop()}else{idx++}continue}if(cuts.length>0&&(!next.contains(cuts[cuts.length-1])||linalg.areClose(nextCut,cuts[cuts.length-1]))){cuts.pop();loop.pop();continue}cuts.push(nextCut);loop.push(next);idx++}let lidx=0;let ridx=loop.length;while(ridx-lidx>=3){const angle=angleCCW(loop[ridx-1].normal,loop[lidx].normal);if(angle>Math.PI-TOL){return Polygon.empty()}const endCut=halfplaneIntersection(loop[lidx],loop[ridx-1]);if(endCut==null){if(loop[lidx].offset>loop[ridx-1].offset){lidx++}else{ridx--}}else if(!loop[ridx-2].contains(endCut)||linalg.areClose(cuts[ridx-2],endCut)){ridx--}else if(!loop[lidx+1].contains(endCut)||linalg.areClose(cuts[lidx],endCut)){lidx++}else{break}}const out=ridx-lidx<3||angleCCW(loop[ridx-1].normal,loop[lidx].normal)>Math.PI-TOL?[]:loop.slice(lidx,ridx);return new Polygon(null,out)}get centroid(){const vol=this.volume;const x=_tools.iter.sum(_tools.arr.cyc2map((a,b)=>(a[0]+b[0])*(a[0]*b[1]-b[0]*a[1]),this.vertices));const y=_tools.iter.sum(_tools.arr.cyc2map((a,b)=>(a[1]+b[1])*(a[0]*b[1]-b[0]*a[1]),this.vertices));return[x/6/vol,y/6/vol]}get volume(){return 0.5*_tools.iter.sum(_tools.arr.cyc2map((a,b)=>a[0]*b[1]-b[0]*a[1],this.vertices))}shatter(){const c=this.centroid;const vs=this.vertices;const l=vs.length;const polys=[[c,vs[0],linalg.midpoint(vs[l-1],vs[0]),linalg.midpoint(vs[0],vs[1])],[c,vs[l-1],linalg.midpoint(vs[l-2],vs[l-1]),linalg.midpoint(vs[l-1],vs[0])]];for(let i=1;i<l-1;i++){polys.push([c,vs[i],linalg.midpoint(vs[i-1],vs[i]),linalg.midpoint(vs[i],vs[i+1])])}return new Union(this.dim,polys.map(Polygon.hull),true)}_HtoV(){if(this._halfspaces==null){throw new _tools.ValueError}else{this._vertices=_tools.arr.cyc2map(function(v,w){const cut=halfplaneIntersection(v,w);if(cut==null){throw{}}else{return cut}},this._halfspaces)}}_VtoH(){if(this._vertices==null){throw new _tools.ValueError}else{this._halfspaces=_tools.arr.cyc2map(function(v,w){return Halfspace.normalized([w[1]-v[1],v[0]-w[0]],v[0]*w[1]-w[0]*v[1])},this._vertices)}}}exports.Polygon=Polygon;class Union{constructor(dim,polytopes,isDisjunct){this.dim=dim;this.polytopes=polytopes.filter(_=>!_.isEmpty);this.isEmpty=this.polytopes.length===0;this._isDisjunct=this.polytopes.length<2||isDisjunct}static deserialize(json){return new Union(json.dim,json.polytopes.map(Polytope.deserialize),null)}static empty(dim){return new Union(dim,[],true)}static from(polytopes,fallbackDim){const dim=polytopes.length>0?polytopes[0].dim:fallbackDim;if(dim==null)throw new _tools.ValueError("Unable to determine dimension from empty set of polytopes (no fallback provided)");polytopes.forEach(_=>linalg.assertEqualDims(_.dim,dim));return new Union(dim,polytopes,null)}get boundingBox(){const Poly=Polytope.ofDim(this.dim);return this.isEmpty?Poly.empty():Poly.hull(cartesian(...this.extent))}get extent(){const init=new Array(this.dim);init.fill([Infinity,-Infinity]);return this.polytopes.map(_=>_.extent).reduce((ext,cur)=>{return _tools.arr.zip2map((a,b)=>[a[0]<b[0]?a[0]:b[0],a[1]<b[1]?b[1]:a[1]],ext,cur)},init)}get isDisjunct(){return this._isDisjunct!=null&&this._isDisjunct}get volume(){const polytopes=this.isDisjunct?this.polytopes:this.simplify().polytopes;return _tools.iter.sum(polytopes.map(_=>_.volume))}apply(m){return new Union(this.dim,this.polytopes.map(_=>_.apply(m)),this._isDisjunct)}applyRight(m){linalg.assertEqualDims(m.length,this.dim);return new Union(m[0].length,this.polytopes.map(_=>_.applyRight(m)),this._isDisjunct)}contains(v){for(let p of this.polytopes){if(p.contains(v))return true}return false}covers(other){if(this.isEmpty)return other.isEmpty;return other.remove(this).isEmpty}disjunctify(){const ps=this.polytopes.slice().sort((x,y)=>x.volume-y.volume);const out=[];while(ps.length>0){const p=ps.pop();out.push(...p.remove(new Union(this.dim,out,true)).polytopes)}return new Union(this.dim,out,true)}fulfils(h){return _tools.iter.every(this.polytopes.map(_=>_.fulfils(h)))}hull(){const vertices=[];for(let polytope of this.polytopes){vertices.push(...polytope.vertices)}return Polytope.ofDim(this.dim).hull(vertices)}intersect(other){const out=[];for(let x of this.polytopes){for(let y of other.polytopes){const intersection=x.intersect(y);if(!intersection.isEmpty){out.push(intersection)}}}return out.length===1?out[0]:new Union(this.dim,out,this._isDisjunct?true:null)}intersects(other){for(let p of this.polytopes){if(p.intersects(other))return true}return false}invert(){return new Union(this.dim,this.polytopes.map(_=>_.invert()),this._isDisjunct)}isSameAs(other){return this.covers(other)&&other.covers(this)}minkowski(other){return new Union(this.dim,this.polytopes.map(_=>_.minkowski(other)),null)}pontryagin(other){const bbox=this.boundingBox;const complement=bbox.remove(this);return bbox.pontryagin(other).remove(complement.minkowski(other.invert()))}remove(other){const out=[];for(let p of this.polytopes){out.push(...p.remove(other).polytopes)}return new Union(this.dim,out,this._isDisjunct?true:null)}sample(){if(this.polytopes.length>=1){return this.polytopes[0].sample()}throw new _tools.NotImplementedError}serialize(){return{dim:this.dim,polytopes:this.polytopes.map(_=>_.serialize())}}shatter(){const pieces=[];for(let x of this.polytopes){pieces.push(...x.shatter().polytopes)}return new Union(this.dim,pieces,this._isDisjunct)}simplify(){if(this.isEmpty)return this;if(this.polytopes.length===1)return this.polytopes[0];const hull=this.hull();const rest=hull.remove(this);if(rest.isEmpty){return hull}else{return hull.remove(rest)}}toUnion(){return this}translate(v){return new Union(this.dim,this.polytopes.map(_=>_.translate(v)),this._isDisjunct)}union(other){linalg.assertEqualDims(this.dim,other.dim);return new Union(this.dim,[...this.polytopes,...other.polytopes],null)}}exports.Union=Union;

},{"./linalg.js":7,"./parser.js":9,"./tools.js":12}],4:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.SystemInspector=exports.ProblemSummary=exports.COLORS=exports.VAR_NAMES=void 0;var dom=_interopRequireWildcard(require("./dom.js"));var _figure=require("./figure.js");var _geometry=require("./geometry.js");var linalg=_interopRequireWildcard(require("./linalg.js"));var _logic=require("./logic.js");var _tools=require("./tools.js");var _widgetsInput=require("./widgets-input.js");var _widgetsPlot=require("./widgets-plot.js");var _worker=require("./worker.js");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}}newObj.default=obj;return newObj}}const VAR_NAMES="xy";exports.VAR_NAMES=VAR_NAMES;const COLORS={yes:"#093",no:"#CCC",maybe:"#FFF",unreachable:"#C99",selection:"#069",highlight:"#FC0",support:"#09C",action:"#000",stateRegion:"#F60",vectorField:"#333",trace:"#000",traceStep:"#C00"};exports.COLORS=COLORS;function analysisKind(q,analysis){if(analysis==null||analysis.maybe.has(q)){return"maybe"}else if(analysis.yes.has(q)){return"yes"}else if(analysis.no.has(q)){return"no"}else{return"unreachable"}}function stateColor(state,wrtQ){return COLORS[analysisKind(wrtQ,state.analysis)]}function stateLabel(state,wrtQ){const out=dom.snLabel.toHTML(state.label);if(wrtQ!=null)out.className=analysisKind(wrtQ,state.analysis);return out}function automatonLabel(label,ana){const out=dom.snLabel.toHTML(label);out.className=analysisKind(label,ana);return out}function ineq2s(h){const terms=[];for(let i=0;i<h.dim;i++){if(h.normal[i]===0){continue}else if(h.normal[i]<0){terms.push("-")}else if(terms.length>0){terms.push("+")}if(h.normal[i]!==1&&h.normal[i]!==-1){terms.push((0,_tools.n2s)(Math.abs(h.normal[i])))}terms.push(VAR_NAMES[i])}return terms.join(" ")+" < "+(0,_tools.n2s)(h.offset)}function predicateLabel(label,halfspace){const out=dom.snLabel.toHTML(label);out.title=ineq2s(halfspace);return out}function matrixToTeX(m){return"\\begin{pmatrix}"+m.map(row=>row.join("&")).join("\\\\")+"\\end{pmatrix}"}function percentageBar(xs,omit){const total=_tools.iter.sum(_tools.obj.map2Array((_,x)=>x,xs));const bar=dom.DIV({"class":"percentage-bar"});for(let key in xs){const ratio=xs[key]/total;bar.appendChild(dom.DIV({"class":key,"title":(ratio*100).toFixed(1)+"% "+key,"style":"flex-grow:"+ratio}))}return bar}function pluralize(n,word){return n+" "+word+(n===1?"":"s")}class ProblemSummary{constructor(system,objective){const csFig=new _figure.Figure;csFig.newLayer({stroke:"#000",fill:"#EEE"}).shapes=system.lss.uu.polytopes.map(u=>({kind:"polytope",vertices:u.vertices}));const rsFig=new _figure.Figure;rsFig.newLayer({stroke:"#000",fill:"#EEE"}).shapes=[{kind:"polytope",vertices:system.lss.ww.vertices}];const ssFig=new _figure.Figure;ssFig.newLayer({stroke:"#000",fill:"#EEE"}).shapes=[{kind:"polytope",vertices:system.lss.xx.vertices}];const cs=new _widgetsPlot.AxesPlot([90,90],csFig,(0,_figure.autoProjection)(1,...system.lss.uu.extent));const rs=new _widgetsPlot.AxesPlot([90,90],rsFig,(0,_figure.autoProjection)(1,...system.lss.ww.extent));const ss=new _widgetsPlot.AxesPlot([90,90],ssFig,(0,_figure.autoProjection)(1,...system.lss.xx.extent));const transitionFormulas=[];for(let[symbol,prop]of objective.propositions){transitionFormulas.push(symbol+" = "+(0,_logic.texifyProposition)(prop,dom.snLabel.toTeX))}this.node=dom.DIV({"id":"problem-summary"},[dom.renderTeX("x_{t+1} = "+matrixToTeX(system.lss.A)+" x_t + "+matrixToTeX(system.lss.B)+" u_t + w_t",dom.P()),dom.DIV({"class":"boxes"},[dom.DIV({},[dom.H3({},["Control Space Polytope (",dom.renderTeX("U",dom.SPAN()),")"]),cs.node]),dom.DIV({},[dom.H3({},["Random Space Polytope (",dom.renderTeX("W",dom.SPAN()),")"]),rs.node]),dom.DIV({},[dom.H3({},["State Space Polytope (",dom.renderTeX("X",dom.SPAN()),")"]),ss.node]),dom.DIV({},[dom.H3({},["Labeled Predicates"]),...Array.from(system.predicates.entries()).map(([label,halfspace])=>dom.renderTeX(dom.snLabel.toTeX(label)+": "+ineq2s(halfspace),dom.P()))])]),dom.DIV({},[dom.H3({},["Objective"]),dom.P({},[objective.kind.name,objective.coSafeInterpretation?" (co-safe)":"",": "]),dom.P({},[dom.renderTeX(objective.kind.formula,dom.SPAN()),", where"]),dom.P({},_tools.arr.intersperse(", ",transitionFormulas.map(_=>dom.renderTeX(_,dom.SPAN()))))])])}}exports.ProblemSummary=ProblemSummary;class SystemInspector{constructor(system,objective,keys,analyseOnStartup,session){const log=new Logger;const model=new SystemModel(system,objective,log,analyseOnStartup,session);const systemViewCtrl=new SystemViewCtrl(model);const randomSpaceView=new RandomSpaceView(model);const controlSpaceView=new ControlSpaceView(model);const automatonViewCtrl=new AutomatonViewCtrl(model,systemViewCtrl,keys);const stateViewOpCtrl=new StateViewOpCtrl(model,systemViewCtrl,keys);const actionViewCtrl=new ActionViewCtrl(model);const analysisViewCtrl=new AnalysisViewCtrl(model,keys);const holisticRefinementCtrl=new HolisticRefinementCtrl(model);const transitionRefinementCtrl=new TransitionRefinementCtrl(model);const snapshotViewCtrl=new SnapshotViewCtrl(model);const traceCtrl=new TraceCtrl(model);const traceViewStepCtrl=new TraceViewStepCtrl(model);const systemViewCtrlCtrl=new SystemViewCtrlCtrl(systemViewCtrl,keys);const connectivity=new Connectivity(model,systemViewCtrl);const tabs=new TabbedView;const stateTab=tabs.newTab("State",[stateViewOpCtrl,actionViewCtrl]);const systemTab=tabs.newTab("System",[analysisViewCtrl,holisticRefinementCtrl,transitionRefinementCtrl,snapshotViewCtrl]);const controlTab=tabs.newTab("Control",[traceCtrl,traceViewStepCtrl]);const infoTab=tabs.newTab("Info",[connectivity,log]);tabs.select("System");log.attach(isError=>{if(isError)tabs.highlight("Info")});this.node=dom.DIV({"id":"inspector"},[dom.DIV({"class":"left"},[systemViewCtrl.node,dom.DIV({"class":"cols"},[dom.DIV({"class":"left"},[dom.H3({},["Objective Automaton",dom.DIV({"class":"icons"},[dom.infoBox("info-automaton")])]),automatonViewCtrl.node]),dom.DIV({"class":"right"},[dom.H3({},["Control and Random Space",dom.DIV({"class":"icons"},[dom.infoBox("info-control")])]),controlSpaceView.node,randomSpaceView.node,dom.H3({},["View Settings",dom.DIV({"class":"icons"},[dom.infoBox("info-view-settings")])]),systemViewCtrlCtrl.node])])]),tabs.node])}}exports.SystemInspector=SystemInspector;class SystemModel extends _tools.ObservableMixin{constructor(system,objective,log,analyseAtStartup,session){super();this.log=log;this._system=system;this.objective=objective;try{this._comm=new _worker.Communicator("ISYS");this._comm.onRequest("init",data=>[system.serialize(),objective.serialize(),analyseAtStartup,session]);this._comm.onRequest("ready",data=>{this.updateStates();this.notify("snapshot");this.notify("trace")});const worker=new Worker("./js/inspector-worker-system.js");worker.onerror=evt=>{this.log.write(["error"],"System worker error event ("+evt.type+").")};this._comm.host=worker}catch(e){if(e.name==="SecurityError"){this.log.writeError(e);return}throw e}this.states=new Map;this._actions=new Map;this._autoSnapID=1;this._xState=null;this._qState=objective.automaton.initialState.label;this._action=null;this._support=null;this._trace=[];this._traceStep=null}get state(){return[this._xState,this._qState]}set xState(state){this._xState=state==null?null:(0,_tools.just)(this.states.get(state));this.notify("state")}set qState(state){if(!this.objective.automaton.states.has(state))throw new Error("");this._qState=state;this.notify("state")}get action(){return this._action}set action(a){this._action=a;this.notify("action")}get support(){return this._support}set support(s){this._support=s;this.notify("support")}get trace(){return this._trace}set trace(t){this._trace=t;this.notify("trace")}get traceStep(){return this._traceStep}set traceStep(s){this._traceStep=s;this.notify("trace-step")}get lss(){return this._system.lss}get qAll(){return this.objective.allStates}getPredicate(label){return this._system.getPredicate(label)}transitionTo(x,q){return this.objective.nextState(x.predicates,q)}updateStates(){return this._comm.request("update-states",null).then(data=>{this.states=data;this._actions=new Map;const xOld=this._xState;try{this.xState=xOld==null?null:xOld.label}catch(_unused){this.xState=null}this.action=null;this.support=null;this.notify("system");return null})}getActions(state){const cached=this._actions.get(state);if(cached!=null)return Promise.resolve(cached);return this._comm.request("get-actions",state).then(data=>{const actions=data.map(action=>({id:action.id,controls:action.controls,origin:(0,_tools.just)(this.states.get(action.origin)),targets:action.targets.map(_=>(0,_tools.just)(this.states.get(_)))}));this._actions.set(state,actions);return actions}).catch(e=>{this.log.writeError(e);throw e})}getSupports(state,action){return this._comm.request("get-supports",[state,action]).catch(e=>{this.log.writeError(e);throw e})}getTrace(controller,steps){const[x,qLabel]=this.state;const xLabel=x==null?null:x.label;const request={controller:controller,steps:steps,origin:[xLabel,qLabel]};return this._comm.request("get-trace",request).catch(e=>{this.log.writeError(e);throw e})}analyse(){return this._comm.request("analyse",null).then(data=>{this.log.writeAnalysis(data);if(data.updated.length>0){return this.takeSnapshot("Automatic Snapshot "+this._autoSnapID++)}else{return null}}).then(data=>{return this.updateStates()}).catch(e=>{this.log.writeError(e);throw e})}resetAnalysis(){return this._comm.request("reset-analysis",null).then(()=>{this.log.write(["Analysis"],"Analysis results have been reset.");return this.updateStates()}).catch(e=>{this.log.writeError(e);throw e})}refineTransition(request){return this._comm.request("refine-transition",request).then(data=>{const params=["Transition "+request.origin+" \u2192 "+request.target,request.steps+"-step"];const layers=request.layers;if(layers!=null)params.push("Layers "+layers.range[0]+"-"+layers.range[1]+" of "+(0,_tools.n2s)(layers.scaling*100,0)+"% "+layers.generator);this.log.writeRefinement(params,data);return data.removed.length>0?this.updateStates():null}).catch(e=>{this.log.writeError(e);throw e})}refineHolistic(request){return this._comm.request("refine-holistic",request).then(data=>{this.log.writeRefinement(["Holistic ("+request.method+")"],data);return data.removed.length>0?this.updateStates():null}).catch(e=>{this.log.writeError(e);throw e})}getSystemSummary(){return this._comm.request("get-system-summary",null).catch(e=>{this.log.writeError(e);throw e})}getSnapshots(){return this._comm.request("get-snapshots",null).catch(e=>{this.log.writeError(e);throw e})}takeSnapshot(name){return this._comm.request("take-snapshot",name).then(data=>{this.notify("snapshot");return data}).catch(e=>{this.log.writeError(e);throw e})}loadSnapshot(id){return this._comm.request("load-snapshot",id).then(data=>{this.log.write(["Snapshot"],"Loaded snapshot '"+data.name+"' with "+pluralize(data.states,"state")+".");this.notify("snapshot");return this.updateStates()}).catch(e=>{this.log.writeError(e);throw e})}nameSnapshot(id,name){return this._comm.request("name-snapshot",[id,name]).then(data=>{this.notify("snapshot");return data}).catch(e=>{this.log.writeError(e);throw e})}exportSession(){return this._comm.request("export-session",null).catch(e=>{this.log.writeError(e);throw e})}}class SystemViewCtrl{constructor(model){this._model=model;this._model.attach(mc=>this.handleModelChange(mc));this._showLabels=false;this._showVectors=false;this._operator=null;this._stateRegion=null;const fig=new _figure.Figure;this._layers={kind:fig.newLayer({"stroke":"none"}),highlight1:fig.newLayer({"stroke":COLORS.highlight,"fill":COLORS.highlight}),selection:fig.newLayer({"stroke":COLORS.selection,"fill":COLORS.selection}),highlight2:fig.newLayer({"stroke":"none","fill":COLORS.highlight,"fill-opacity":"0.2"}),support:fig.newLayer({"stroke":COLORS.support,"fill":COLORS.support}),vectorField:fig.newLayer({"stroke":COLORS.vectorField,"stroke-width":"1","fill":COLORS.vectorField}),action:fig.newLayer({"stroke":COLORS.action,"stroke-width":"2","fill":COLORS.action}),stateRegion:fig.newLayer({"stroke":"none","fill":COLORS.stateRegion}),trace:fig.newLayer({"stroke":COLORS.trace,"stroke-width":"1.5","fill":COLORS.trace}),traceStep:fig.newLayer({"stroke":COLORS.traceStep,"stroke-width":"1.5","fill":COLORS.traceStep}),label:fig.newLayer({"font-family":"DejaVu Sans, sans-serif","font-size":"8pt","text-anchor":"middle","transform":"translate(0 3)"}),interaction:fig.newLayer({"stroke":"#000","stroke-width":"1","fill":"#FFF","fill-opacity":"0"})};this._plot=new _widgetsPlot.InteractivePlot([660,500],fig,(0,_figure.autoProjection)(660/500,...this._model.lss.xx.extent));this.node=this._plot.node}set showLabels(show){this._showLabels=show;this.drawLabels()}set showVectors(show){this._showVectors=show;this.drawVectors()}set operator(op){this._operator=op;this.drawOperator()}set stateRegion(stateRegion){this._stateRegion=stateRegion;this.drawStateRegion()}handleModelChange(mc){if(mc==="system"){const shapes=[];for(let[label,state]of this._model.states){const click=()=>{const[x,_]=this._model.state;this._model.xState=x!=null&&label===x.label?null:label};shapes.push({kind:"polytope",vertices:state.polytope.vertices,events:{"click":click}})}this._layers.interaction.shapes=shapes;this.drawAnalysis();this.drawLabels()}else if(mc==="state"){this.drawState();this.drawAnalysis()}else if(mc==="action"){this.drawAction()}else if(mc==="support"){this.drawSupport()}else if(mc==="trace"){this.drawTrace()}else if(mc==="trace-step"){this.drawTraceStep()}}drawState(){const[x,_]=this._model.state;if(x==null){this._layers.selection.shapes=[]}else{this._layers.selection.shapes=[{kind:"polytope",vertices:x.polytope.vertices}]}this.drawOperator()}drawAction(){const action=this._model.action;const support=this._model.support;if(action==null){this._layers.action.shapes=[]}else{const polys=support!=null?support.targets:action.targets;this._layers.action.shapes=polys.map(target=>({kind:"arrow",origin:action.origin.centroid,target:target.centroid}))}this.drawOperator()}drawSupport(){const support=this._model.support;if(support==null){this._layers.support.shapes=[]}else{this._layers.support.shapes=support.origins.polytopes.map(origin=>({kind:"polytope",vertices:origin.vertices}))}this.drawAction()}drawOperator(){const op=this._operator;const lss=this._model.lss;const[x,_]=this._model.state;let shapes=[];if(op!=null&&x!=null){const p=_geometry.Polytope.deserialize(x.polytope);let region=_geometry.Polytope.ofDim(lss.dim).empty();if(op==="post"){if(!x.isOuter){const act=this._model.action;const u=act==null?lss.uu:_geometry.Union.deserialize(act.controls);region=lss.post(p,u)}}else if(op==="pre"){region=lss.pre(lss.xx,lss.uu,p)}else if(op==="preR"){region=lss.preR(lss.xx,lss.uu,p)}else if(op==="attr"){region=lss.attr(lss.xx,lss.uu,p)}else if(op==="attrR"){region=lss.attrR(lss.xx,lss.uu,p)}else{throw new Error("Unknown operator '"+op+"'")}shapes=region.polytopes.map(_=>({kind:"polytope",vertices:_.vertices}))}this._layers.highlight1.shapes=shapes;this._layers.highlight2.shapes=shapes}drawAnalysis(){const[_,q]=this._model.state;const shapes=[];for(let state of this._model.states.values()){shapes.push({kind:"polytope",vertices:state.polytope.vertices,style:{fill:stateColor(state,q)}})}this._layers.kind.shapes=shapes}drawLabels(){let shapes=[];if(this._showLabels){for(let[label,state]of this._model.states){shapes.push({kind:"label",coords:state.centroid,text:state.label})}}this._layers.label.shapes=shapes}drawVectors(){const shapes=[];if(this._showVectors){shapes.push({kind:"vectorField",fun:x=>linalg.apply(this._model.lss.A,x),scaling:0.25,n:[12,12]})}this._layers.vectorField.shapes=shapes}drawStateRegion(){const shapes=[];const test=this._stateRegion;if(test!=null){for(let state of this._model.states.values()){if(test(state))shapes.push({kind:"polytope",vertices:state.polytope.vertices})}}this._layers.stateRegion.shapes=shapes}drawTrace(){this._layers.trace.shapes=this._model.trace.map(step=>({kind:"arrow",origin:step.xOrigin[0],target:step.xTarget[0]}))}drawTraceStep(){const step=this._model.traceStep;this._layers.traceStep.shapes=step==null?[]:[{kind:"arrow",origin:step.xOrigin[0],target:step.xTarget[0]}]}toExportURL(){const data={view:{size:null},polytopes:[],trace:this._model.trace.map(step=>[step.xOrigin[0],step.xTarget[0]])};const opShapes=Array.from(this._layers.highlight1.shapes);if(this._operator!=null&&opShapes.length>0){for(let shape of opShapes){if(shape.kind!=="polytope")continue;data.polytopes.push([{dim:this._model.lss.dim,vertices:shape.vertices},[false,this._operator],[true,COLORS.highlight],[false,COLORS.highlight]])}}const[x,q]=this._model.state;for(let[label,state]of this._model.states){data.polytopes.push([state.polytope,[this._showLabels,label],[true,x===state?COLORS.selection:stateColor(state,q)],[true,"#000000"]])}return window.btoa(JSON.stringify(data))}}class ControlSpaceView{constructor(model){this._model=model;this._model.attach(mc=>this.handleModelChange(mc));const fig=new _figure.Figure;this._layers={poly:fig.newLayer({"stroke":"#000","stroke-width":"1","fill":"#FFF"}),action:fig.newLayer({"stroke":COLORS.action,"fill":COLORS.action}),trace:fig.newLayer({"stroke":COLORS.traceStep,"fill":COLORS.traceStep})};const uu=this._model.lss.uu;this._layers.poly.shapes=uu.polytopes.map(u=>({kind:"polytope",vertices:u.vertices}));const proj=(0,_figure.autoProjection)(1,...uu.extent);const plot=new _widgetsPlot.AxesPlot([120,120],fig,proj);this.node=dom.DIV({"id":"control-space-view"},[plot.node])}handleModelChange(mc){if(mc==="action"){const action=this._model.action;if(action==null){this._layers.action.shapes=[]}else{this._layers.action.shapes=action.controls.polytopes.map(poly=>({kind:"polytope",vertices:poly.vertices}))}}else if(mc==="trace-step"){const step=this._model.traceStep;this._layers.trace.shapes=step==null?[]:[{kind:"marker",size:3,coords:step.u}]}}}class RandomSpaceView{constructor(model){this._model=model;this._model.attach(mc=>this.handleModelChange(mc));const fig=new _figure.Figure;this._layers={poly:fig.newLayer({"stroke":"#000","stroke-width":"1","fill":"#FFF"}),trace:fig.newLayer({"stroke":COLORS.traceStep,"fill":COLORS.traceStep})};const ww=this._model.lss.ww;this._layers.poly.shapes=[{kind:"polytope",vertices:ww.vertices}];const proj=(0,_figure.autoProjection)(1,...ww.extent);const plot=new _widgetsPlot.AxesPlot([120,120],fig,proj);this.node=dom.DIV({"id":"random-space-view"},[plot.node])}handleModelChange(mc){if(mc!=="trace-step")return;const step=this._model.traceStep;this._layers.trace.shapes=step==null?[]:[{kind:"marker",size:3,coords:step.w}]}}class SystemViewCtrlCtrl{constructor(systemViewCtrl,keys){const labels=new _widgetsInput.CheckboxInput(false,dom.SPAN({},[dom.create("u",{},["L"]),"abel polytopes"]));labels.attach(()=>{systemViewCtrl.showLabels=labels.value});const vectors=new _widgetsInput.CheckboxInput(false,dom.SPAN({},[dom.create("u",{},["V"]),"ector field"]));vectors.attach(()=>{systemViewCtrl.showVectors=vectors.value});this.node=dom.DIV({},[dom.P({},[labels.node,vectors.node])]);keys.bind("l",(0,_widgetsInput.inputTextRotation)(labels,["t","f"]));keys.bind("v",(0,_widgetsInput.inputTextRotation)(vectors,["t","f"]))}}class AutomatonViewCtrl{constructor(model,systemViewCtrl,keys){this._model=model;this._model.attach(mc=>this.handleModelChange(mc));const objective=this._model.objective;const init=objective.automaton.initialState.label;const fig=new _figure.Figure;this._shapes=objective.toShapes();this._layers={transitionLabels:fig.newLayer({"font-family":"serif","font-size":"10pt","transform":"translate(0 4)","cursor":"default","class":"transition-labels"}),stateLabels:fig.newLayer({"font-family":"DejaVu Sans, sans-serif","font-size":"10pt","text-anchor":"middle","transform":"translate(0 4)"}),transitions:fig.newLayer({"fill":"#000","stroke":"#000","stroke-width":"2"}),traceStep:fig.newLayer({"fill":COLORS.traceStep,"stroke":COLORS.traceStep,"stroke-width":"2"}),states:fig.newLayer({"fill":"#FFF","fill-opacity":"0","stroke":"#000","stroke-width":"2"})};const extent=(0,_tools.just)(this._shapes.extent,"No automaton plot extent given by objective");const proj=new _figure.Cartesian2D(...extent);const width=Math.abs(extent[0][1]-extent[0][0]);const height=Math.abs(extent[1][1]-extent[1][0]);const plot=new _widgetsPlot.ShapePlot([330,height+Math.max(1-330/width,0)],fig,proj,false);this.node=dom.DIV({"id":"automaton-view-ctrl"},[plot.node,dom.P({},[dom.create("u",{},["I"]),"nitial state: ",dom.snLabel.toHTML(init)])]);keys.bind("i",()=>{this._model.qState=init});this._layers.stateLabels.shapes=_tools.iter.map(_=>_[1],this._shapes.states.values());const ts=[];for(let[q,transitions]of this._shapes.transitions){const qState=this._model.objective.getState(q);for(let[qNext,shapes]of transitions){const qNextState=this._model.objective.getState(qNext);const highlighter=x=>{const valuation=this._model.objective.valuationFor(x.predicates);const proposition=qState.proposition(qNextState);return!x.isOuter&&proposition!=null&&proposition.evalWith(valuation)};const t=_tools.obj.clone(shapes[1]);t.events={"mouseover":()=>{systemViewCtrl.stateRegion=highlighter},"mouseout":()=>{systemViewCtrl.stateRegion=null}};ts.push(t)}}this._layers.transitionLabels.shapes=ts;this.draw()}handleModelChange(mc){if(mc==="state"){this.draw()}else if(mc==="trace-step"){this.drawTraceStep()}}draw(){const[x,q]=this._model.state;const next=x==null?null:this._model.transitionTo(x,q);const ss=[];for(let[state,[s,l]]of this._shapes.states){s=_tools.obj.clone(s);s.events={"click":()=>{this._model.qState=state}};if(state===q){s.style={"stroke":COLORS.selection}}ss.push(s)}const ts=[];for(let[origin,transitions]of this._shapes.transitions){for(let[target,[t,l]]of transitions){if(origin===q&&target===next){t=_tools.obj.clone(t);t.style={"stroke":COLORS.selection,"fill":COLORS.selection}}ts.push(t)}}this._layers.states.shapes=ss;this._layers.transitions.shapes=ts}drawTraceStep(){const step=this._model.traceStep;if(step==null){this._layers.traceStep.shapes=[]}else{const transitions=(0,_tools.just)(this._shapes.transitions.get(step.xOrigin[2]),"Trace takes transition which does not exist: "+step.xOrigin[2]+" \u2192 "+step.xTarget[2]);const shapes=(0,_tools.just)(transitions.get(step.xTarget[2]),"Trace takes transition which does not exist: "+step.xOrigin[2]+" \u2192 "+step.xTarget[2]);this._layers.traceStep.shapes=[shapes[0]]}}}class TabbedView{constructor(){this._tabs=new Map;this._bar=dom.DIV({"class":"bar"});this._content=dom.DIV();this.node=dom.DIV({"class":"tabs"},[this._bar,this._content]);this._selection=null}newTab(name,widgets){const tab=new TabContent(this,name,widgets);this._tabs.set(name,tab);this._bar.appendChild(tab.title);return tab}select(name){const oldTab=this._selection;if(oldTab!=null){oldTab.title.className=""}const tab=(0,_tools.just)(this._tabs.get(name));dom.replaceChildren(this._content,tab.children);tab.title.className="selection";this._selection=tab}highlight(name){const tab=(0,_tools.just)(this._tabs.get(name));if(tab!==this._selection)tab.title.className="highlight"}};class TabContent{constructor(view,name,widgets){this.title=dom.DIV({},[name]);this.title.addEventListener("click",()=>view.select(name));this.widgets=widgets}get children(){const out=[];for(let widget of this.widgets){out.push(widget.heading);out.push(widget.node)}return out}}class WidgetPlus{constructor(title,infoBoxId){this._isLoading=0;this._icons=[dom.create("img",{"src":"svg/loading16.svg","style":"display:none;","title":"loading...","alt":"loading..."})];if(infoBoxId!=null)this._icons.push(dom.infoBox(infoBoxId));this.heading=dom.H3({},[title,dom.DIV({"class":"icons"},this._icons)]);this.node=dom.DIV()}get isLoading(){return this._isLoading>0}pushLoad(){this._isLoading++;if(this._isLoading===1)this.handleLoadingChange()}popLoad(){this._isLoading--;if(this._isLoading===0)this.handleLoadingChange()}handleLoadingChange(){this._icons[0].style.display=this.isLoading?"inline-block":"none"}}class StateViewOpCtrl extends WidgetPlus{constructor(model,systemViewCtrl,keys){super("Selection","info-state");this._model=model;this._model.attach(mc=>this.handleModelChange(mc));const operator=new _widgetsInput.DropdownInput({"None":null,"Posterior":"post","Predecessor":"pre","Robust Predecessor":"preR","Attractor":"attr","Robust Attractor":"attrR"},"None");operator.attach(()=>{systemViewCtrl.operator=operator.value});this._lines=[dom.DIV(),dom.DIV(),dom.DIV()];this.node=dom.DIV({"id":"state-view"},[dom.DIV({"class":"div-table"},[dom.DIV({"class":"rowspan"},[dom.DIV({},["State:"]),this._lines[0]]),dom.DIV({"class":"rowspan"},[dom.DIV({},["Analysis:"]),this._lines[1]]),dom.DIV({},[dom.DIV({},["Predicates:"]),this._lines[2]])]),dom.P({"class":"highlight"},[operator.node])]);keys.bind("o",(0,_widgetsInput.inputTextRotation)(operator,["None","Posterior","Predecessor","Robust Predecessor","Attractor","Robust Attractor"]))}handleModelChange(mc){if(mc!=="state")return;const[x,q]=this._model.state;if(x!=null){const analysis=x.analysis;const qNext=this._model.transitionTo(x,q);const text=[dom.SPAN({"class":"selection"},[dom.snLabel.toHTML(x.label),", ",dom.snLabel.toHTML(q)])];if(x.isOuter){text.push(" (outer state)")}else if(analysisKind(q,analysis)==="unreachable"){text.push(" (unreachable state)")}else if(qNext==null){text.push(" (dead end state)")}else{text.push(" (transition to ",automatonLabel(qNext,null),")")}dom.replaceChildren(this._lines[0],text);if(analysis==null){dom.replaceChildren(this._lines[1],["?"])}else{dom.replaceChildren(this._lines[1],_tools.arr.intersperse(", ",_tools.iter.map(_=>automatonLabel(_,analysis),this._model.qAll)))};dom.replaceChildren(this._lines[2],x.predicates.size<1?["-"]:_tools.arr.intersperse(", ",_tools.iter.map(_=>predicateLabel(_,this._model.getPredicate(_)),x.predicates)))}else{for(let line of this._lines)dom.replaceChildren(line,["-"])}}}class ActionViewCtrl extends WidgetPlus{constructor(model){super("Actions","info-actions");this._model=model;this._model.attach(mc=>this.handleModelChange(mc));this._action=null;this._actions=[];this._actionNodes=new Map;this._supports=[];this._supportNode=dom.DIV({"id":"supports"});this.node=dom.DIV({"id":"action-view"})}handleModelChange(mc){if(mc==="state"){const[x,q]=this._model.state;if(x==null||x.isOuter||this._model.transitionTo(x,q)==null||analysisKind(q,x.analysis)==="unreachable"){dom.replaceChildren(this.node,["-"])}else{this.pushLoad();dom.replaceChildren(this.node,[]);this._model.getActions(x.label).then(actions=>{if(this._model.state[0]!==x)return;this._actionNodes=new Map(actions.map(_=>[_,this.actionToNode(_)]));dom.replaceChildren(this.node,this._actionNodes.values())}).catch(e=>{}).finally(()=>{this.popLoad()})}this._action=null;this._model.action=null;this._model.support=null}}clickAction(action){const oldAction=this._action;if(oldAction!=null){const oldNode=this._actionNodes.get(oldAction);if(oldNode!=null)oldNode.className="action"}if(action===oldAction){this._action=null;this.node.removeChild(this._supportNode)}else{this._action=action;const newNode=this._actionNodes.get(action);if(newNode!=null){newNode.className="selection";this.pushLoad();this._model.getSupports(action.origin.label,action.id).then(supports=>{dom.replaceChildren(this._supportNode,supports.map(_=>this.supportToNode(_)));dom.appendAfter(this.node,newNode,this._supportNode)}).catch(e=>{}).finally(()=>{this.popLoad()})}}this._model.action=this._action}actionToNode(action){const[_,q]=this._model.state;const next=this._model.transitionTo(action.origin,q);const origin=stateLabel(action.origin,q);const targets=_tools.arr.intersperse(", ",action.targets.map(target=>stateLabel(target,next)));const node=dom.DIV({"class":"action"},[origin," \u2192 {",...targets,"}"]);node.addEventListener("click",()=>this.clickAction(action));node.addEventListener("mouseover",e=>{if(dom.fromChildElement(node,e))return;this._model.action=action});node.addEventListener("mouseout",e=>{if(dom.fromChildElement(node,e))return;this._model.action=this._action});return node}supportToNode(support){const[_,q]=this._model.state;const next=this._model.transitionTo(support.origin,q);const targets=_tools.arr.intersperse(", ",support.targets.map(target=>stateLabel(target,next)));const node=dom.DIV({},["{",...targets,"}"]);node.addEventListener("mouseover",e=>{if(dom.fromChildElement(node,e))return;this._model.support=support});node.addEventListener("mouseout",e=>{if(dom.fromChildElement(node,e))return;this._model.support=null});return node}}class AnalysisViewCtrl extends WidgetPlus{constructor(model,keys){super("Analysis","info-analysis");this._model=model;this._model.attach(mc=>this.handleModelChange(mc));this._analyse=dom.createButton({},[dom.create("u",{},["a"]),"nalyse"],()=>this.analyse());this._reset=dom.createButton({},["reset"],()=>this.reset());this._info=dom.SPAN({"class":"count-stats"});this._bar=percentageBar({"please wait...":1});this.node=dom.DIV({"id":"analysis-view-ctrl"},[dom.P({},[this._analyse," ",this._reset,this._info]),this._bar]);keys.bind("a",()=>this.analyse())}analyse(){if(this.isLoading)return;this.pushLoad();this._model.analyse().catch(e=>{}).finally(()=>{this.popLoad()})}reset(){if(this.isLoading)return;this.pushLoad();this._model.resetAnalysis().catch(e=>{}).finally(()=>{this.popLoad()})}handleChange(){const[_,q]=this._model.state;const summary=this._summary;if(summary==null)return;const stats=summary.get(q);if(stats==null)return;const count=stats.count;const volume=stats.volume;const totalCount=count.yes+count.no+count.maybe+count.unreachable;const totalVolume=volume.yes+volume.no+volume.maybe+volume.unreachable;const nodes=[];if(count.yes>0)nodes.push(dom.SPAN({"class":"yes","title":"yes"},[count.yes.toString()]));if(count.maybe>0)nodes.push(dom.SPAN({"class":"maybe","title":"maybe"},[count.maybe.toString()]));if(count.no>0)nodes.push(dom.SPAN({"class":"no","title":"no"},[count.no.toString()]));if(count.unreachable>0)nodes.push(dom.SPAN({"class":"unreachable","title":"unreachable"},[count.unreachable.toString()]));dom.replaceChildren(this._info,[automatonLabel(q)," :: ",..._tools.arr.intersperse(" + ",nodes)," = ",pluralize(totalCount,"state")]);const bar=percentageBar(volume);this.node.replaceChild(bar,this._bar);this._bar=bar}handleModelChange(mc){if(mc==="system"){this.pushLoad();this._model.getSystemSummary().then(data=>{this._summary=data;this.handleChange()}).catch(e=>{}).finally(()=>{this.popLoad()})}else if(mc=="state"){this.handleChange()}}handleLoadingChange(){super.handleLoadingChange();this._analyse.disabled=this.isLoading;this._reset.disabled=this.isLoading}}class HolisticRefinementCtrl extends WidgetPlus{constructor(model){super("Holistic Refinement","info-holistic-refinement");this._model=model;const posRobustRefine=dom.createButton({},["refine"],()=>this.refinePosRobust());this._posOperator=new _widgetsInput.DropdownInput({"Robust Attractor":"AttrR","Robust Predecessor":"PreR"},"Robust Attractor");const negAttrRefine=dom.createButton({},["refine"],()=>this.refineNegAttr());const safetyRefine=dom.createButton({},["refine"],()=>this.refineSafety());const loopsRefine=dom.createButton({},["refine"],()=>this.refineLoops());this._loopsOptimistic=new _widgetsInput.DropdownInput({"Optimistic":true,"Pessimistic":false},"Optimistic");this._loopsOnlySafe=new _widgetsInput.CheckboxInput(true,"only safe actions");this.node=dom.DIV({"class":"div-table"},[dom.DIV({},[dom.DIV({},[posRobustRefine]),dom.DIV({},["Positive with ",this._posOperator.node])]),dom.DIV({},[dom.DIV({},[negAttrRefine]),dom.DIV({},["Negative Attractor"])]),dom.DIV({},[dom.DIV({},[safetyRefine]),dom.DIV({},["Safety"])]),dom.DIV({},[dom.DIV({},[loopsRefine]),dom.DIV({},[this._loopsOptimistic.node," self-loop removal, ",this._loopsOnlySafe.node])])])}refinePosRobust(){this.pushLoad();this._model.refineHolistic({method:"positive-robust",operator:this._posOperator.value}).catch(()=>{}).finally(()=>{this.popLoad()})}refineNegAttr(){this.pushLoad();this._model.refineHolistic({method:"negative-attractor"}).catch(()=>{}).finally(()=>{this.popLoad()})}refineSafety(){this.pushLoad();this._model.refineHolistic({method:"safety"}).catch(()=>{}).finally(()=>{this.popLoad()})}refineLoops(){this.pushLoad();this._model.refineHolistic({method:"self-loop",optimistic:this._loopsOptimistic.value,onlySafe:this._loopsOnlySafe.value}).catch(()=>{}).finally(()=>{this.popLoad()})}}const MAX_LAYER_RANGE_END=20;class TransitionRefinementCtrl extends WidgetPlus{constructor(model){super("Robust Transition Refinement","info-transition-refinement");this._model=model;const automaton=model.objective.automaton;const qAllObj=_tools.obj.fromMap(_=>_,model.qAll);this._origin=new _widgetsInput.RadioInput(qAllObj,automaton.initialState.label,automatonLabel);this._target=new _widgetsInput.RadioInput(qAllObj,automaton.initialState.label,automatonLabel);this._expandTarget=new _widgetsInput.CheckboxInput(true,"expand after iteration");this._useLayers=new _widgetsInput.CheckboxInput(false,"layer decomposition");this._layerGenerator=new _widgetsInput.DropdownInput({"Predecessor":"Pre","Robust Predecessor":"PreR"},"Robust Predecessor");this._layerUScale=new _widgetsInput.DropdownInput(_widgetsInput.DropdownInput.rangeOptions(80,125,5),"95");this._layerStart=new _widgetsInput.DropdownInput(_widgetsInput.DropdownInput.rangeOptions(1,20,1),"1");this._layerEnd=new _widgetsInput.DropdownInput({"10":10},"10");this._steps=new _widgetsInput.DropdownInput(_widgetsInput.DropdownInput.rangeOptions(0,20,1),"2");this._dontRefineSmall=new _widgetsInput.CheckboxInput(true,"don't refine small polytopes if safe");this._postProcessing=new _widgetsInput.DropdownInput({"none":"none","convex hull":"hull","largest polytope only":"largest","suppress small polytopes":"suppress"},"none");this._button=dom.createButton({},["refine"],()=>this.refine());this.node=dom.DIV({"id":"layer-refinement-ctrl"},[dom.DIV({"class":"div-table"},[dom.DIV({},[dom.DIV({},["Origin:"]),dom.DIV({},[this._origin.node])]),dom.DIV({},[dom.DIV({},["Target:"]),dom.DIV({},[this._target.node])]),dom.DIV({},[dom.DIV(),dom.DIV({},[this._expandTarget.node])]),dom.DIV({},[dom.DIV({},["Layers:"]),dom.DIV({},[this._useLayers.node])]),dom.DIV({},[dom.DIV(),dom.DIV({},[this._layerStart.node," to ",this._layerEnd.node," of ",this._layerGenerator.node])]),dom.DIV({},[dom.DIV(),dom.DIV({},["scale generating ",dom.renderTeX("U",dom.SPAN())," to ",this._layerUScale.node,"%"])]),dom.DIV({},[dom.DIV({},["AttrR:"]),dom.DIV({},[this._dontRefineSmall.node])]),dom.DIV({},[dom.DIV(),dom.DIV({},["post-processing: ",this._postProcessing.node])]),dom.DIV({},[dom.DIV({},[this._button]),dom.DIV({},["with ",this._steps.node,"-step robust refinement"])])])]);this._layerStart.attach(()=>this.handleRangeChange(),true);this._useLayers.attach(()=>this.handleLayersChange(),true)}refine(){if(this.isLoading)return;this.pushLoad();this._model.refineTransition({origin:this._origin.value,target:this._target.value,steps:this._steps.value,layers:!this._useLayers.value?null:{generator:this._layerGenerator.value,scaling:this._layerUScale.value/100,range:[this._layerStart.value,this._layerEnd.value]},settings:{expandTarget:this._expandTarget.value,dontRefineSmall:this._dontRefineSmall.value,postProcessing:this._postProcessing.value}}).catch(()=>{}).finally(()=>{this.popLoad()})}handleLoadingChange(){super.handleLoadingChange();this._button.disabled=this.isLoading}handleRangeChange(){const lower=this._layerStart.value;const upper=this._layerEnd.value;const init=String(Math.max(lower,upper));this._layerEnd.setOptions(_widgetsInput.DropdownInput.rangeOptions(lower,MAX_LAYER_RANGE_END,1),init)}handleLayersChange(){const disabled=!this._useLayers.value;this._layerStart.disabled=disabled;this._layerEnd.disabled=disabled;this._layerGenerator.disabled=disabled;this._layerUScale.disabled=disabled}}class SnapshotViewCtrl extends WidgetPlus{constructor(model){super("Snapshots","info-snapshots");this._model=model;this._model.attach(mc=>this.handleModelChange(mc));this._forms={take:dom.createButton({},["new"],()=>this.takeSnapshot()),load:dom.createButton({},["load"],()=>this.loadSnapshot()),rename:dom.createButton({},["rename"],()=>this.renameSnapshot()),name:dom.INPUT({"type":"text","placeholder":"Snapshot","size":"25"})};this._treeView=dom.DIV({"class":"tree"});this.node=dom.DIV({"id":"snapshot-ctrl"},[dom.P({},[this._forms.take," ",this._forms.name,dom.DIV({"class":"right"},[this._forms.rename," ",this._forms.load])]),this._treeView]);this._data=null;this._selection=null;this.handleLoadingChange()}takeSnapshot(){const name=this._forms.name.value.trim();this._forms.name.value="";this.pushLoad();this._model.takeSnapshot(name.length===0?"Snapshot":name).catch(e=>{}).finally(()=>{this.popLoad()})}loadSnapshot(){const id=this._selection;if(id!=null){this.pushLoad();this._model.loadSnapshot(id).catch(e=>{}).finally(()=>{this.popLoad()})}}renameSnapshot(){const selection=this._selection;const name=this._forms.name.value.trim();if(selection!=null&&name.length>0){this.pushLoad();this._model.nameSnapshot(selection,name).catch(e=>{}).finally(()=>{this.popLoad()})}}handleModelChange(mc){if(mc!=="snapshot")return;this.pushLoad();this._model.getSnapshots().then(data=>{this._data=data;this.redraw()}).catch(e=>{}).finally(()=>{this.popLoad()})}redraw(){if(this._data!=null){dom.replaceChildren(this._treeView,this._renderTree(this._data))}else{dom.removeChildren(this._treeView)}}_select(which){this._selection=this._selection===which?null:which;this.handleLoadingChange();this.redraw()}_renderTree(snapshot){const nodes=[];const cls="snap"+(snapshot.isCurrent?" current":"")+(snapshot.id===this._selection?" selection":"");const node=dom.DIV({"class":cls},[snapshot.name,dom.SPAN({},[pluralize(snapshot.states,"state")])]);node.addEventListener("click",()=>this._select(snapshot.id));nodes.push(node);if(snapshot.children.size>0){const indented=dom.DIV({"class":"indented"});for(let child of snapshot.children){dom.appendChildren(indented,this._renderTree(child))}nodes.push(indented)}return nodes}handleLoadingChange(){super.handleLoadingChange();this._forms.take.disabled=this.isLoading;this._forms.load.disabled=this.isLoading||this._selection==null;this._forms.rename.disabled=this.isLoading||this._selection==null}}class TraceCtrl extends WidgetPlus{constructor(model){super("Sample Trace","info-trace-sample");this._model=model;this._model.attach(mc=>this.handleModelChange(mc));this._initial=dom.SPAN();const steps=new _widgetsInput.DropdownInput(_widgetsInput.DropdownInput.rangeOptions(15,121,15));const controller=new _widgetsInput.DropdownInput({"Round-robin Controller":"round-robin","Random Controller":"random"},"Round-robin Controller");const sampleButton=dom.createButton({},["sample"],()=>{this.pushLoad();this._model.getTrace(controller.value,steps.value).then(data=>{this._model.trace=data}).catch(e=>{}).finally(()=>{this.popLoad()})});const clearButton=dom.createButton({},["clear"],()=>{this._model.trace=[]});this.node=dom.DIV({},[dom.P({},[sampleButton," ",clearButton]),dom.P({},["Starting from ",this._initial,":"]),dom.P({},["up to ",steps.node," steps with ",controller.node])])}handleModelChange(mc){if(mc!="state")return;const[x,q]=this._model.state;dom.replaceChildren(this._initial,x==null?[dom.snLabel.toHTML(q)]:[dom.snLabel.toHTML(q)," in ",dom.snLabel.toHTML(x.label)])}}class TraceViewStepCtrl extends WidgetPlus{constructor(model){super("Trace","info-trace");this._model=model;this._model.attach(mc=>this.handleModelChange(mc));const fig=new _figure.Figure;this._layers={arrows:fig.newLayer({"stroke":COLORS.trace,"stroke-width":"1.5","fill":COLORS.trace}),step:fig.newLayer({"stroke":COLORS.traceStep,"stroke-width":"1.5","fill":COLORS.traceStep}),states:fig.newLayer({"font-family":"DejaVu Sans, sans-serif","font-size":"8pt","text-anchor":"middle"}),hovers:fig.newLayer({"stroke":"none","fill":"#FFF","fill-opacity":"0"})};const proj=new _figure.Cartesian2D([-0.5,15.5],[-7.7,0.3]);const plot=new _widgetsPlot.ShapePlot([480,400],fig,proj,false);this._terminateText=dom.P();this.node=dom.DIV({},[this._terminateText,plot.node])}handleModelChange(mc){if(mc!="trace")return;const trace=this._model.trace;const arrows=[];const states=[];const hovers=[];let terminateText="";if(trace.length>0){arrows.push({kind:"arrow",origin:[0,0],target:[0,0]});states.push({kind:"label",coords:[0,-0.35],text:trace[0].xOrigin[2]});terminateText+=pluralize(trace.length,"step");const last=trace[trace.length-1];const lastX=(0,_tools.just)(this._model.states.get(last.xTarget[1]));const lastQ=last.xTarget[2];if(this._model.objective.isCoSafeFinal(lastQ)){terminateText+=", objective satisfied"}else if(lastX.isOuter){terminateText+=", outer state reached"}else if(lastX.analysis!=null&&lastX.analysis.no.has(lastQ)){terminateText+=", no-state reached"}}else{terminateText+="none"}dom.replaceChildren(this._terminateText,[terminateText]);for(let i=0;i<trace.length;i++){const step=trace[i];const x=i%15;const y=-Math.floor(i/15);arrows.push({kind:"arrow",origin:[x,y],target:[x+1,y]});hovers.push({kind:"polytope",vertices:[[x,y+0.3],[x+1,y+0.3],[x+1,y-0.3],[x,y-0.3]],events:{"mouseover":()=>this.highlightStep(step,x,y),"mouseout":()=>this.highlightStep(null,0,0)}});if(step.xOrigin[2]!==step.xTarget[2]){states.push({kind:"label",coords:[x+1,y-0.35],text:step.xTarget[2]})}}this._layers.arrows.shapes=arrows;this._layers.hovers.shapes=hovers;this._layers.states.shapes=states}highlightStep(step,x,y){this._layers.step.shapes=step==null?[]:[{kind:"arrow",origin:[x,y],target:[x+1,y]}];this._model.traceStep=step}}class Connectivity extends WidgetPlus{constructor(model,systemViewCtrl){super("Connectivity","info-connectivity");this._model=model;const calculator=dom.createButton({},["Calculator"],()=>{const[y,_]=model.state;const calcData={"A":JSON.stringify(model.lss.A),"B":JSON.stringify(model.lss.B),"X":JSON.stringify(model.lss.xx.vertices),"U":JSON.stringify(model.lss.uu.polytopes[0].vertices),"Y":y==null?"":JSON.stringify(y.polytope.vertices),"W":JSON.stringify(model.lss.ww.vertices)};window.open("polytopic-calculator.html#"+window.btoa(JSON.stringify(calcData)))});const plotter=dom.createButton({},["Plotter"],()=>{window.open("polytopic-plotter.html#"+systemViewCtrl.toExportURL())});const save=dom.createButton({},["Export Session"],()=>this.exportSession());this.node=dom.DIV({},[dom.P({},[calculator," ",plotter," ",save])])}exportSession(){this._model.exportSession().then(data=>{this.pushLoad();dom.popupDownload("data:application/json;base64,"+window.btoa(JSON.stringify(data)),"session.json")}).catch(e=>{}).finally(()=>{this.popLoad()})}}class Logger extends _tools.ObservableMixin{constructor(){super();this._filters={analysis:new _widgetsInput.CheckboxInput(true,"Analysis"),refinement:new _widgetsInput.CheckboxInput(true,"Refinement"),snapshot:new _widgetsInput.CheckboxInput(true,"Snapshot"),error:new _widgetsInput.CheckboxInput(true,"Error")};_tools.obj.forEach((_,input)=>input.attach(()=>this.handleFilterChange()),this._filters);this._entries=dom.DIV();this.node=dom.DIV({"id":"logger"},[dom.P({"class":"log-filter"},[this._filters.analysis.node,this._filters.refinement.node,this._filters.snapshot.node,this._filters.error.node]),this._entries]);this.heading=dom.H3({},["Log Messages",dom.DIV({"class":"icons"},[dom.infoBox("info-log")])]);this.handleFilterChange()}_write(params,content){content.className="log-content";const attrs=params.length===0?{}:{"class":"log-"+params[0].toLowerCase()};const now=new Date(Date.now());const entry=dom.DIV(attrs,[dom.DIV({"class":"log-heading"},[now.toLocaleTimeString()," :: ",params.join(" :: ")]),content]);this._entries.insertBefore(entry,this._entries.firstChild);this.notify(params.length>0&&params[0]==="Error")}write(params,text){this._write(params,dom.DIV({},[text]))}writeError(e){console.log(e);this.write(["Error"],e.message)}writeAnalysis(data){this._write(["Analysis"],dom.DIV({},["Player 1: "+pluralize(data.states[0]," state")+", "+pluralize(data.actions[0],"action")+".",dom.create("br"),"Player 2: "+pluralize(data.states[1]," state")+", "+pluralize(data.actions[1],"action")+".",dom.create("br"),"Updated ",dom.SPAN({"title":data.updated.join(", ")},[pluralize(data.updated.length,"state")]),".",dom.create("br"),"Elapsed time: ",dom.SPAN({"title":"game abstraction"},[(0,_tools.t2s)(data.tGame)])," + ",dom.SPAN({"title":"game analysis"},[(0,_tools.t2s)(data.tAnalysis)])," = "+(0,_tools.t2s)(data.tGame+data.tAnalysis)+"."]))}writeRefinement(params,data){this._write(["Refinement",...params],dom.DIV({},["Removed ",dom.SPAN({"title":data.removed.join(", ")},[pluralize(data.removed.length,"state")]),".",dom.create("br"),"Created ",dom.SPAN({"title":data.created.join(", ")},[pluralize(data.created.length,"state")]),".",dom.create("br"),"Elapsed time: "+(0,_tools.t2s)(data.elapsed)+"."]))}handleFilterChange(){let cls="log-entries";for(let kind in this._filters){if(!this._filters[kind].value){cls+=" hide-"+kind}}this._entries.className=cls}}

},{"./dom.js":1,"./figure.js":2,"./geometry.js":3,"./linalg.js":7,"./logic.js":8,"./tools.js":12,"./widgets-input.js":13,"./widgets-plot.js":14,"./worker.js":15}],5:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.ProblemSetup=exports.SessionManager=void 0;var dom=_interopRequireWildcard(require("./dom.js"));var _figure=require("./figure.js");var _geometry=require("./geometry.js");var _inspectorWidgetsInspector=require("./inspector-widgets-inspector.js");var linalg=_interopRequireWildcard(require("./linalg.js"));var _logic=require("./logic.js");var presets=_interopRequireWildcard(require("./presets.js"));var _system=require("./system.js");var _tools=require("./tools.js");var _widgetsInput=require("./widgets-input.js");var _widgetsPlot=require("./widgets-plot.js");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}}newObj.default=obj;return newObj}}class SessionManager{constructor(problemSetup,callback){this.problemSetup=problemSetup;const sessionFile=dom.INPUT({"type":"file"});const sessionButton=dom.createButton({},["import"],()=>{if(sessionFile.value==="")return;const file=sessionFile.files[0];if(file==null)throw new Error("No file specified");const reader=new FileReader;reader.onload=()=>{const result=reader.result;if(result==null||typeof result!=="string")throw new Error("File contents are not a string");callback(JSON.parse(result))};reader.readAsText(file)});this.presetSelect=new _widgetsInput.DropdownInput(presets.setups);const presetButton=dom.createButton({},["fill in"],()=>this.loadPreset());this.node=dom.DIV({"class":"div-table"},[dom.DIV({},[dom.DIV({},["Continue a session:"]),dom.DIV({},[sessionFile," ",sessionButton])]),dom.DIV({},[dom.DIV({},["Start from a preset:"]),dom.DIV({},[this.presetSelect.node," ",presetButton])])])}loadPreset(){this.problemSetup.load(this.presetSelect.value)}}exports.SessionManager=SessionManager;class ProblemSetup extends _tools.ObservableMixin{constructor(callback){super();this.callback=callback;this.ssDim=new _widgetsInput.DropdownInput({"1-dimensional":1,"2-dimensional":2},"2-dimensional");this.csDim=new _widgetsInput.DropdownInput({"1-dimensional":1,"2-dimensional":2},"2-dimensional");this.equation=new EvolutionEquationInput(this.ssDim,this.csDim);this.ss=new PolytopeInput(this.ssDim,false);this.rs=new PolytopeInput(this.ssDim,false);this.cs=new PolytopeInput(this.csDim,false);this.predicates=new PredicatesInput(this.ssDim);this.objective=new ObjectiveInput(this.predicates);this.preview=new SystemPreview(this,this.equation,this.objective.terms);const columns=dom.DIV({"id":"inspector"},[dom.DIV({"class":"left"},[this.preview.node,dom.H3({},["Objective",dom.DIV({"class":"icons"},[dom.infoBox("info-input-objective")])]),this.objective.node]),dom.DIV({"class":"right"},[dom.H3({},["Control Space Polytope",dom.DIV({"class":"icons"},[dom.infoBox("info-input-control")])]),this.cs.node,dom.H3({},["Random Space Polytope",dom.DIV({"class":"icons"},[dom.infoBox("info-input-random")])]),this.rs.node,dom.H3({},["State Space Polytope",dom.DIV({"class":"icons"},[dom.infoBox("info-input-state")])]),this.ss.node,dom.H3({},["Linear Predicates",dom.DIV({"class":"icons"},[dom.infoBox("info-input-predicates")])]),this.predicates.node])]);const submit=dom.INPUT({"type":"submit","value":"run inspector"});submit.addEventListener("click",e=>{if(this.node.checkValidity()){e.preventDefault();this.submit()}});this.analyseWhenReady=new _widgetsInput.CheckboxInput(true,"analyse at startup");this.node=dom.FORM({},[dom.H3({},["Dimensions"]),dom.P({},[this.ssDim.node," state space"]),dom.P({},[this.csDim.node," control space"]),dom.H3({},["Evolution Equation"]),this.equation.node,columns,dom.H3({},["Continue"]),dom.P({},[this.analyseWhenReady.node]),dom.P({},[submit])]);this.equation.A.attach(()=>this.notify());this.equation.B.attach(()=>this.notify());this.ss.attach(()=>this.notify());this.rs.attach(()=>this.notify());this.cs.attach(()=>this.notify());this.predicates.attach(()=>this.notify())}get lssIsValid(){return this.equation.isValid&&this.ss.isValid&&this.rs.isValid&&this.cs.isValid}get lss(){return new _system.LSS(this.equation.A.value,this.equation.B.value,this.ss.value,this.rs.value,this.cs.value)}get systemIsValid(){return this.lssIsValid&&this.predicates.isValid}get system(){return this.lss.decompose(...this.predicates.value)}load(setup){this.ssDim.text=setup.dimension.stateSpace;this.csDim.text=setup.dimension.controlSpace;this.equation.A.text=setup.equation.A;this.equation.B.text=setup.equation.B;this.cs.text=setup.polytope.controlSpace;this.rs.text=setup.polytope.randomSpace;this.ss.text=setup.polytope.stateSpace;this.predicates.text=setup.predicates;this.objective.text=setup.objective}submit(){this.callback(this.lss,...this.predicates.value,this.objective.value,this.analyseWhenReady.value)}}exports.ProblemSetup=ProblemSetup;class SystemPreview{constructor(setup,equation,terms){this.setup=setup;this.equation=equation;this.terms=terms;this._system=null;let fig=new _figure.Figure;this.plot=new _widgetsPlot.AxesPlot([660,500],fig,(0,_figure.autoProjection)(660/500));this.layers={objective:fig.newLayer({"stroke":_inspectorWidgetsInspector.COLORS.stateRegion,"fill":_inspectorWidgetsInspector.COLORS.stateRegion}),state:fig.newLayer({"stroke":"#000","stroke-width":"1","fill-opacity":"0"}),outer:fig.newLayer({"stroke":"#000","stroke-width":"1","fill":_inspectorWidgetsInspector.COLORS.no}),vectorField:fig.newLayer({"stroke":_inspectorWidgetsInspector.COLORS.vectorField,"stroke-width":"1","fill":_inspectorWidgetsInspector.COLORS.vectorField})};this.node=dom.DIV({"class":"plot"},[this.plot.node]);this.setup.attach(()=>this.drawSystem(),true);this.equation.showVectorField.attach(()=>this.drawVectorField(),true);this.terms.attach(()=>this.drawObjectiveTerm(),true)}drawSystem(){this._system=null;const stateShapes=[];const outerShapes=[];if(this.setup.systemIsValid){const system=this.setup.system;this.plot.projection=(0,_figure.autoProjection)(660/500,...system.extent);for(let state of system.states.values()){(state.isOuter?outerShapes:stateShapes).push({kind:"polytope",vertices:state.polytope.vertices})}this._system=system}else if(this.setup.lssIsValid){const lss=this.setup.lss;this.plot.projection=(0,_figure.autoProjection)(660/500,...lss.extent);stateShapes.push({kind:"polytope",vertices:lss.xx.vertices});outerShapes.push(...lss.oneStepReachable.remove(lss.xx).polytopes.map(poly=>({kind:"polytope",vertices:poly.vertices})))}else{this.plot.projection=(0,_figure.autoProjection)(660/500)}this.layers.state.shapes=stateShapes;this.layers.outer.shapes=outerShapes;this.drawVectorField()}drawVectorField(){const shapes=[];if(this.equation.showVectorField.value&&this.equation.A.isValid){const A=this.equation.A.value;shapes.push({kind:"vectorField",fun:x=>linalg.apply(A,x),scaling:0.25,n:[15,15]})}this.layers.vectorField.shapes=shapes}drawObjectiveTerm(){const system=this._system;const term=this.terms.previewTerm;if(system==null||term==null){this.layers.objective.shapes=[]}else{const shapes=[];for(let state of system.states.values()){if(!state.isOuter&&term.evalWith(_=>state.predicates.has(_.symbol))){shapes.push({kind:"polytope",vertices:state.polytope.vertices})}}this.layers.objective.shapes=shapes}}}class EvolutionEquationInput{constructor(ssDim,csDim){this.ssDim=ssDim;this.csDim=csDim;this.A=new _widgetsInput.MatrixInput(EvolutionEquationInput.parseNumber,[2,2],5);this.B=new _widgetsInput.MatrixInput(EvolutionEquationInput.parseNumber,[2,2],5);this.showVectorField=new _widgetsInput.CheckboxInput(false,"show vector field");this.showVectorField.node.title="scaling: x0.25";this.node=dom.DIV({},[dom.P({},[dom.renderTeX("x_{t+1} =",dom.SPAN()),this.A.node,dom.renderTeX("x_t +",dom.SPAN()),this.B.node,dom.renderTeX("u_t + w_t",dom.SPAN())]),dom.P({},[this.showVectorField.node])]);ssDim.attach(()=>{this.A.shape=[ssDim.value,ssDim.value];this.B.shape=[ssDim.value,csDim.value]});csDim.attach(()=>{this.B.shape=[ssDim.value,csDim.value]})}get isValid(){if(this.A.isValid&&this.B.isValid){let shapeA=this.A.shape;let shapeB=this.B.shape;return shapeA[0]===this.ssDim.value&&shapeA[0]===shapeA[1]&&shapeB[0]===this.ssDim.value&&shapeB[1]===this.csDim.value}return false}static parseNumber(text){let out=parseFloat(text);if(isNaN(out)){throw new _widgetsInput.ValidationError("invalid number '"+text+"'")}return out}}class PolytopeInput extends _tools.ObservableMixin{constructor(dim,allowEmpty){super();this.allowEmpty=allowEmpty;this.dim=dim;this.dim.attach(()=>{this.variables=_inspectorWidgetsInspector.VAR_NAMES.substring(0,this.dim.value);this.predicates.handleChange()});this.variables=_inspectorWidgetsInspector.VAR_NAMES.substring(0,this.dim.value);this.predicates=new _widgetsInput.MultiLineInput(line=>_geometry.Halfspace.parse(line,this.variables),[5,25]);let fig=new _figure.Figure;this.previewLayer=fig.newLayer({"stroke":"#000","stroke-width":"1","fill":"#EEE"});this.preview=new _widgetsPlot.AxesPlot([90,90],fig,(0,_figure.autoProjection)(4/3));this.node=dom.DIV({"class":"polytope-builder"},[this.predicates.node,this.preview.node]);this.predicates.attach(()=>this.handleChange(),true)}get value(){return _geometry.Polytope.ofDim(this.variables.length).intersection(this.predicates.value)}get text(){return this.predicates.text}set text(text){this.predicates.text=text}set disabled(tf){}get isValid(){return this.predicates.isValid&&this.variables.length===this.dim.value&&(this.allowEmpty||!this.value.isEmpty)}handleChange(){let proj=(0,_figure.autoProjection)(1);let shapes=[];if(this.isValid){let poly=this.value;if(!poly.isEmpty){proj=(0,_figure.autoProjection)(1,...poly.extent);shapes=[{kind:"polytope",vertices:poly.vertices}]}}else{if(this.predicates.isValid){this.predicates.node.setCustomValidity("Polytope is empty or unbounded")}}this.preview.projection=proj;this.previewLayer.shapes=shapes;this.notify()}}class PredicatesInput extends _tools.ObservableMixin{constructor(dim){super();this.dim=dim;this.dim.attach(()=>{this.variables=_inspectorWidgetsInspector.VAR_NAMES.substring(0,this.dim.value);this.predicates.handleChange()});this.variables=_inspectorWidgetsInspector.VAR_NAMES.substring(0,this.dim.value);this.predicates=new _widgetsInput.MultiLineInput(line=>this.parsePredicate(line),[10,40]);this.predicates.attach(()=>this.handleChange());this.node=this.predicates.node}get value(){let predicates=[];let names=[];for(let predicate of this.predicates.value){predicates.push(predicate[0]);names.push(predicate[1])}return[predicates,names]}get text(){return this.predicates.text}set text(text){this.predicates.text=text}set disabled(tf){}get isValid(){return this.predicates.isValid&&this.predicates.value.length>0&&this.variables.length===this.dim.value}handleChange(){this.notify()}parsePredicate(line){const match=line.match(/(?:\s*([a-z][a-z0-9]*)\s*:\s*)?(.*)/);if(match==null||match[2]==null)throw new Error("Invalid predicate specification '"+line.trim()+"'");const name=match[1]==null?"":match[1];const pred=_geometry.Halfspace.parse(match[2],this.variables);return[pred,name]}}class ObjectiveInput extends _tools.ObservableMixin{constructor(predicates){super();this.kind=new _widgetsInput.DropdownInput(presets.objectives,"Reachability");this.coSafe=new _widgetsInput.CheckboxInput(false,"co-safe interpretation");this.coSafeLine=dom.P();this.terms=new ObjectiveTermsInput(this.kind,predicates);this.formula=dom.SPAN();this.node=dom.DIV({},[dom.P({},[this.kind.node,": ",this.formula,", where"]),this.terms.node,this.coSafeLine]);this.kind.attach(()=>this.handleChange(),true)}get value(){return new _logic.Objective(this.kind.value,this.terms.value,this.isCoSafeCompatible&&this.coSafe.value)}get text(){return this.kind.text+"\n"+this.terms.text}set text(text){const lines=text.split("\n");if(lines.length<2)throw new Error("Invalid objective specification, requires at least two lines (name and if co-safe)");this.kind.text=lines[0];this.terms.text=lines.slice(1,-1).join("\n");this.coSafe.text=lines[lines.length-1]}set disabled(tf){}get isValid(){return this.terms.isValid}get isCoSafeCompatible(){return _logic.OnePairStreettAutomaton.parse(this.kind.value.automaton).isCoSafeCompatible}handleChange(){const kind=this.kind.value;dom.renderTeX(kind.formula,this.formula);if(this.isCoSafeCompatible){dom.replaceChildren(this.coSafeLine,[this.coSafe.node])}else{dom.replaceChildren(this.coSafeLine,[this.kind.text+" objective has no co-safe interpretation"])}this.notify()}}class ObjectiveTermsInput extends _tools.ObservableMixin{constructor(kind,predicates){super();this.kind=kind;this.predicates=predicates;this.inputs=[];this.previewTerm=null;this.node=dom.DIV({"class":"objective-terms"});this.kind.attach(()=>this.updateTerms(),true);this.predicates.attach(()=>this.handleChange(),true)}get value(){return this.inputs.map(_=>_.value)}get text(){return this.inputs.map(_=>_.text).join("\n")}set text(text){const lines=text.split("\n");for(let i=0;i<this.inputs.length;i++){this.inputs[i].text=i<lines.length?lines[i]:""}}set disabled(tf){}get isValid(){return _tools.iter.every(this.inputs.map(_=>_.isValid))}setPreviewTerm(which){this.previewTerm=which<0||!this.inputs[which].isValid?null:this.inputs[which].value;this.notify()}updateTerms(){const variables=this.kind.value.variables;const inputs=[];const termNodes=[];for(let i=0;i<variables.length;i++){const label=dom.renderTeX(variables[i]+" =",dom.SPAN());const oldText=i<this.inputs.length?this.inputs[i].text:"";const input=new _widgetsInput.LineInput(s=>this.parseTerm(s),60,oldText);input.attach(()=>this.notify());inputs.push(input);const preview=dom.SPAN({"class":"preview"},["show"]);preview.addEventListener("mouseover",()=>this.setPreviewTerm(i));preview.addEventListener("mouseout",()=>this.setPreviewTerm(-1));termNodes.push(dom.P({},[label," ",input.node," ",preview]))}dom.replaceChildren(this.node,termNodes);this.inputs=inputs;this.setPreviewTerm(-1)}handleChange(){for(let input of this.inputs){input.handleChange()}this.notify()}parseTerm(text){const formula=(0,_logic.parseProposition)(text);const predicates=this.predicates.value;const predicateNames=new Set(predicates[1]);(0,_logic.traverseProposition)(prop=>{if(prop instanceof _logic.AtomicProposition&&!predicateNames.has(prop.symbol)){throw new Error("Unknown linear predicate '"+prop.symbol+"'")}},formula);return formula}}

},{"./dom.js":1,"./figure.js":2,"./geometry.js":3,"./inspector-widgets-inspector.js":4,"./linalg.js":7,"./logic.js":8,"./presets.js":10,"./system.js":11,"./tools.js":12,"./widgets-input.js":13,"./widgets-plot.js":14}],6:[function(require,module,exports){
"use strict";var dom=_interopRequireWildcard(require("./dom.js"));var _inspectorWidgetsSetup=require("./inspector-widgets-setup.js");var _inspectorWidgetsInspector=require("./inspector-widgets-inspector.js");var _logic=require("./logic.js");var presets=_interopRequireWildcard(require("./presets.js"));var _system=require("./system.js");var _tools=require("./tools.js");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}}newObj.default=obj;return newObj}}document.addEventListener("DOMContentLoaded",function(){const contentNode=(0,_tools.just)(document.getElementById("application"));const keybindings=new dom.Keybindings;function startInspector(system,objective,analyseWhenReady,session){const problem=new _inspectorWidgetsInspector.ProblemSummary(system,objective);const inspector=new _inspectorWidgetsInspector.SystemInspector(system,objective,keybindings,analyseWhenReady,session);dom.replaceChildren(contentNode,[problem.node,inspector.node]);contentNode.scrollIntoView()}const problemSetup=new _inspectorWidgetsSetup.ProblemSetup((lss,predicates,predicateLabels,objective,analyseWhenReady)=>{const system=lss.decompose(predicates,predicateLabels);startInspector(system,objective,analyseWhenReady,null)});const sessionManager=new _inspectorWidgetsSetup.SessionManager(problemSetup,session=>{if(session.objective==null||session.snapshots==null)throw new Error("Invalid session file");const objective=_logic.Objective.deserialize(session.objective);const root=session.snapshots.root;if(root==null)throw new Error("Session does not contain snapshots");const[snapshot,_]=session.snapshots.snapshots[root];const system=_system.AbstractedLSS.deserialize(snapshot.system);startInspector(system,objective,false,session)});dom.replaceChildren(contentNode,[sessionManager.node,problemSetup.node]);sessionManager.loadPreset();for(let node of document.querySelectorAll(".math")){dom.renderTeX(node.innerHTML.replace(/&amp;/g,"&").replace(/&gt;/g,">").replace(/&lt;/g,"<"),node)}});

},{"./dom.js":1,"./inspector-widgets-inspector.js":4,"./inspector-widgets-setup.js":5,"./logic.js":8,"./presets.js":10,"./system.js":11,"./tools.js":12}],7:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.assertEqualDims=assertEqualDims;exports.norm2=norm2;exports.dot=dot;exports.add=add;exports.sub=sub;exports.midpoint=midpoint;exports.areClose=areClose;exports.apply=apply;exports.applyRight=applyRight;exports.eye=eye;exports.det=det;exports.inv=inv;exports.transpose=transpose;exports.matmul=matmul;exports.minkowski=exports.TOL=exports.MathError=exports.DimensionMismatch=void 0;var _tools=require("./tools.js");class DimensionMismatch extends Error{}exports.DimensionMismatch=DimensionMismatch;class MathError extends Error{}exports.MathError=MathError;const TOL=1e-8;exports.TOL=TOL;function assertEqualDims(n,m){if(n!=m){throw new DimensionMismatch(String(n)+" != "+String(m))}}function norm2(v){let squares=0;for(let x of v){squares+=x*x}return Math.sqrt(squares)}function dot(v,w){assertEqualDims(v.length,w.length);let sum=0;for(let i=0;i<v.length;i++){sum+=v[i]*w[i]}return sum}function add(v,w){assertEqualDims(v.length,w.length);return _tools.arr.zip2map((a,b)=>a+b,v,w)}function sub(v,w){assertEqualDims(v.length,w.length);return _tools.arr.zip2map((a,b)=>a-b,v,w)}function midpoint(v,w){assertEqualDims(v.length,w.length);return _tools.arr.zip2map((a,b)=>a+0.5*(b-a),v,w)}function areClose(v,w){assertEqualDims(v.length,w.length);return norm2(sub(v,w))<TOL}function apply(m,v){assertEqualDims(m[0].length,v.length);return m.map(row=>dot(row,v))}function applyRight(m,v){return matmul([v],m)[0]}function eye(size){const m=[];for(let i=0;i<size;i++){const row=new Array(size);row.fill(0);row[i]=1;m.push(row)}return m}function det(m){assertEqualDims(m.length,m[0].length);switch(m.length){case 1:return m[0][0];case 2:return m[0][0]*m[1][1]-m[0][1]*m[1][0];default:throw new _tools.NotImplementedError;}}function inv(m){assertEqualDims(m.length,m[0].length);const d=det(m);if(Math.abs(d)<TOL){throw new MathError("matrix not invertible")}else{switch(m.length){case 1:return[[1/d]];case 2:return[[m[1][1]/d,-m[0][1]/d],[-m[1][0]/d,m[0][0]/d]];default:throw new _tools.NotImplementedError;}}}function transpose(m){const result=[];for(let j=0;j<m[0].length;j++){const row=[];for(let i=0;i<m.length;i++){row.push(m[i][j])}result.push(row)}return result}function matmul(m,n){assertEqualDims(m[0].length,n.length);const result=[];for(let i=0;i<m.length;i++){const row=[];for(let j=0;j<n[0].length;j++){let akkumulator=0;for(let k=0;k<n.length;k++){akkumulator+=m[i][k]*n[k][j]}row.push(akkumulator)}result.push(row)}return result}const minkowski={xmy(xs,ys){const out=[];for(let x of xs){for(let y of ys){out.push(sub(x,y))}}return out},axpy(A,xs,ys){const out=[];for(let x of xs){const Ax=apply(A,x);for(let y of ys){out.push(add(Ax,y))}}return out}};exports.minkowski=minkowski;

},{"./tools.js":12}],8:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.parseProposition=parseProposition;exports.texifyProposition=texifyProposition;exports.traverseProposition=traverseProposition;exports.unicodeifyTransitionLabel=unicodeifyTransitionLabel;exports.AutomatonState=exports.OnePairStreettAutomaton=exports.Implication=exports.Disjunction=exports.Conjunction=exports.Negation=exports.Top=exports.AtomicProposition=exports.Objective=void 0;var _parser=require("./parser.js");var _tools=require("./tools.js");class Objective{constructor(kind,terms,coSafeInterpretation){this.kind=kind;if(terms.length!==kind.variables.length)throw new Error("Number of terms ("+terms.length+") does not match number of variables ("+kind.variables.length+")");this.propositions=new Map(_tools.arr.zip2(kind.variables,terms));this.automaton=OnePairStreettAutomaton.parse(kind.automaton);this.allStates=_tools.sets.map(_=>_.label,this.automaton.states.values());this.coSafeInterpretation=coSafeInterpretation!=null&&coSafeInterpretation;if(this.coSafeInterpretation&&!this.automaton.isCoSafeCompatible)throw new Error("Co-safe interpretation chosen, but automaton is not co-safe compatible")}static deserialize(json){return new Objective(json.kind,json.terms.map(parseProposition),json.coSafeInterpretation)}getState(label){return(0,_tools.just)(this.automaton.states.get(label),"automaton state "+label+" does not exist")}getProposition(symbol){return(0,_tools.just)(this.propositions.get(symbol),"no formula for symbol "+symbol+" exists")}valuationFor(predicates){return atom=>{const formula=this.getProposition(atom.symbol);return formula.evalWith(_=>predicates.has(_.symbol))}}nextState(predicates,label){const state=this.getState(label);const next=state.successor(this.valuationFor(predicates));return next==null?null:next.label}isCoSafeFinal(label){const state=this.getState(label);return this.coSafeInterpretation&&state.isFinal&&this.automaton.acceptanceSetF.has(state)}toShapes(){const shapes=this.automaton.toShapes(this.kind.automatonPlacement);let xmin=Infinity;let xmax=-Infinity;let ymin=Infinity;let ymax=-Infinity;for(let[x,y,_]of _tools.obj.values(this.kind.automatonPlacement)){if(x<xmin)xmin=x;if(x>xmax)xmax=x;if(y<ymin)ymin=y;if(y>ymax)ymax=y}shapes.extent=[[xmin-120,xmax+120],[ymin-80,ymax+80]];return shapes}serialize(){return{kind:this.kind,terms:this.kind.variables.map(_=>this.getProposition(_).stringify()),coSafeInterpretation:this.coSafeInterpretation}}}exports.Objective=Objective;class AtomicProposition{constructor(symbol){this.symbol=symbol}evalWith(valuate){return valuate(this)}stringify(){return this.symbol}}exports.AtomicProposition=AtomicProposition;class Top{evalWith(valuate){return true}stringify(){return"TRUE"}}exports.Top=Top;class Negation{constructor(arg){this.args=[arg]}evalWith(valuate){return!this.args[0].evalWith(valuate)}stringify(){return"(!"+this.args[0].stringify()+")"}}exports.Negation=Negation;class Conjunction{constructor(larg,rarg){this.args=[larg,rarg]}evalWith(valuate){return this.args[0].evalWith(valuate)&&this.args[1].evalWith(valuate)}stringify(){return"("+this.args[0].stringify()+" & "+this.args[1].stringify()+")"}}exports.Conjunction=Conjunction;class Disjunction{constructor(larg,rarg){this.args=[larg,rarg]}evalWith(valuate){return this.args[0].evalWith(valuate)||this.args[1].evalWith(valuate)}stringify(){return"("+this.args[0].stringify()+" | "+this.args[1].stringify()+")"}}exports.Disjunction=Disjunction;class Implication{constructor(larg,rarg){this.args=[larg,rarg]}evalWith(valuate){return!this.args[0].evalWith(valuate)||this.args[1].evalWith(valuate)}stringify(){return"("+this.args[0].stringify()+" -> "+this.args[1].stringify()+")"}}exports.Implication=Implication;const PROP_OPS=[{op:"->",precedence:20,associativity:1,cls:Implication,tex:"\\rightarrow"},{op:"|",precedence:30,associativity:-1,cls:Disjunction,tex:"\\vee"},{op:"&",precedence:40,associativity:-1,cls:Conjunction,tex:"\\wedge"},{op:"!",precedence:50,associativity:0,cls:Negation,tex:"\\neg"}];function getOpOf(prop){for(let op of PROP_OPS){if(prop instanceof op.cls){return op}}throw new Error("unknown operator")}const parsePropositionAST=(0,_parser.ASTParser)(/[()!&|]|->|(?:[a-z\\][a-z0-9]*)/,PROP_OPS);function asProposition(node){if(typeof node==="string"){return new AtomicProposition(node)}else{for(let op of PROP_OPS){if(node.op===op.op){return new op.cls(...node.args.map(asProposition))}}throw new _parser.ParseError("unknown operator '"+node.op+"'")}}function parseProposition(text){return asProposition(parsePropositionAST(text))}function texifyProposition(prop,symbolTransform,parentOp,rightArg){if(symbolTransform==null){symbolTransform=_=>_}if(prop instanceof AtomicProposition){return symbolTransform(prop.symbol)}if(prop instanceof Top){return symbolTransform("__TRUE__")}const op=getOpOf(prop);let out="";let needsParentheses=false;if(op.associativity===0){const arg=prop.args[0];if(arg instanceof AtomicProposition){out=op.tex+" "+symbolTransform(arg.symbol)}else{out=op.tex+" ("+texifyProposition(arg,symbolTransform)+")"}}else{const left=texifyProposition(prop.args[0],symbolTransform,op,false);const right=texifyProposition(prop.args[1],symbolTransform,op,true);out=left+" "+op.tex+" "+right;needsParentheses=parentOp!=null&&(parentOp.precedence>op.precedence||parentOp.precedence===op.precedence&&(rightArg&&op.associativity<0||!rightArg&&op.associativity>0))}return needsParentheses?"("+out+")":out}function traverseProposition(fun,prop){fun(prop);if(prop instanceof AtomicProposition){}else if(prop instanceof Top){}else{for(let arg of prop.args){traverseProposition(fun,arg)}}}function unicodeifyTransitionLabel(text){_tools.obj.forEach((k,v)=>{text=(0,_tools.replaceAll)(text,k,v)},{"\\varphi":"\u03C6","\\theta":"\u03B8","\\mu":"\u03BC","\\pi":"\u03C0","\\rho":"\u03C1","\\vee":"\u2228","\\wedge":"\u2227","\\neg":"\xAC","\\rightarrow":"\u2192"," ":""});return text}class OnePairStreettAutomaton{constructor(){this.states=new Map;this.acceptanceSetE=new Set;this.acceptanceSetF=new Set}get isCoSafeCompatible(){const E=this.acceptanceSetE;const F=this.acceptanceSetF;return F.size>0&&!_tools.sets.doIntersect(E,F)&&_tools.sets.difference(this.states.values(),_tools.sets.union(E,F)).size===0&&_tools.iter.every(_tools.iter.map(_=>_.isFinal,F))}takeState(label){let state=this.states.get(label);if(state==null){state=new AutomatonState(label);this.states.set(label,state)}return state}toShapes(placement,propositions){const ss=new Map;const tss=new Map;for(let origin of this.states.values()){const[x,y,loopAngle]=placement[origin.label];const member=(this.acceptanceSetE.has(origin)?"E":"")+(this.acceptanceSetF.has(origin)?"F":"");ss.set(origin.label,[{kind:"state",coords:[x,y],member:member},{kind:"label",coords:[x,y],text:origin.label}]);const ts=new Map;for(let[target,proposition]of origin.transitions){const text=unicodeifyTransitionLabel(texifyProposition(proposition));if(origin.label===target.label){ts.set(origin.label,[{kind:"loop",coords:[x,y],angle:loopAngle},{kind:"loopLabel",text:text,coords:[x,y],angle:loopAngle}])}else{const[xx,yy,_]=placement[target.label];ts.set(target.label,[{kind:"transition",origin:[x,y],target:[xx,yy]},{kind:"transitionLabel",text:text,origin:[x,y],target:[xx,yy]}])}}if(origin.defaultTarget!=null){if(origin.label===origin.defaultTarget.label){ts.set(origin.label,[{kind:"loop",coords:[x,y],angle:loopAngle},{kind:"loopLabel",text:"\u2217",coords:[x,y],angle:loopAngle}])}else{const[xx,yy,_]=placement[origin.defaultTarget.label];ts.set(origin.defaultTarget.label,[{kind:"transition",origin:[x,y],target:[xx,yy]},{kind:"transitionLabel",text:"\u2217",origin:[x,y],target:[xx,yy]}])}}tss.set(origin.label,ts)}return{states:ss,transitions:tss}}stringify(){const transitions=[];const acceptE=[];const acceptF=[];for(let state of this.states.values()){for(let[target,formula]of state.transitions){transitions.push(state.label+">"+formula.stringify()+">"+target.label)}if(state.defaultTarget!=null){transitions.push(state.label+">>"+state.defaultTarget.label)}if(this.acceptanceSetE.has(state)){acceptE.push(state.label)}if(this.acceptanceSetF.has(state)){acceptF.push(state.label)}}return[transitions.join(","),this.initialState.label,acceptE.join(","),acceptF.join(",")].join(" ; ")}static parse(s){const automaton=new OnePairStreettAutomaton;const[transitions,initialState,acceptanceSetE,acceptanceSetF]=s.split(";");for(let transition of transitions.split(",").map(x=>x.trim()).filter(x=>x.length>0)){const opIdx=transition.indexOf(">");const ptIdx=transition.lastIndexOf(">");if(opIdx<0||ptIdx<0||opIdx==ptIdx)throw new Error("Invalid transition '"+transition+"'");const o=transition.substring(0,opIdx).trim();const origin=automaton.takeState(o);const t=transition.substring(ptIdx+1).trim();const target=automaton.takeState(t);const p=transition.substring(opIdx+1,ptIdx).trim();if(p===""){if(origin.defaultTarget!=null)throw new Error("Default target set twice for state '"+o+"'");if(origin.transitions.has(target))throw new Error("Two transitions to target '"+t+"' set for state '"+o+"'");origin.defaultTarget=target}else{const formula=parseProposition(p);if(origin.transitions.has(target)||origin.defaultTarget===target)throw new Error("Two transitions to target '"+t+"' set for state '"+o+"'");origin.transitions.set(target,formula)}}for(let label of acceptanceSetE.split(",").map(x=>x.trim()).filter(x=>x.length>0)){automaton.acceptanceSetE.add(automaton.takeState(label))}for(let label of acceptanceSetF.split(",").map(x=>x.trim()).filter(x=>x.length>0)){automaton.acceptanceSetF.add(automaton.takeState(label))}automaton.initialState=automaton.takeState(initialState.trim());return automaton}}exports.OnePairStreettAutomaton=OnePairStreettAutomaton;class AutomatonState{constructor(label){if(label.startsWith("__"))throw new Error("automaton state labels starting with '__' are reserved");this.label=label;this.transitions=new Map;this.defaultTarget=null}get isFinal(){return this.transitions.size===0&&this.defaultTarget===this}successor(valuation){for(let[target,formula]of this.transitions){if(formula.evalWith(valuation))return target}return this.defaultTarget}proposition(successor){let prop=null;const prevProps=[];for(let[target,formula]of this.transitions){if(target===successor){prop=formula;break}else{prevProps.push(formula)}}const preCond=prevProps.length>0?new Negation(prevProps.reduce((l,r)=>new Disjunction(l,r))):new Top;if(prop!=null){return new Conjunction(preCond,prop)}else if(this.defaultTarget===successor){return preCond}else{return null}}}exports.AutomatonState=AutomatonState;

},{"./parser.js":9,"./tools.js":12}],9:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.ASTParser=ASTParser;exports.printAST=printAST;exports.ParseError=void 0;class ParseError extends Error{}exports.ParseError=ParseError;function ASTParser(tokenPattern,operators){const pcparser=new PCParser(operators);return function(text){const tokenStream=new TokenStream(text,tokenPattern);return pcparser.parse(tokenStream)}}function printAST(node){return typeof node==="string"?node:node.op+"("+node.args.map(printAST).join(", ")+")"}class TokenStream{constructor(text,pattern){this.text=text;this.pattern=RegExp("\\s*("+pattern.source+")\\s*","gy");this.advance()}advance(){if(this.pattern.lastIndex==this.text.length){this.current=null}else{const lastIndex=this.pattern.lastIndex;const match=this.pattern.exec(this.text);if(match==null)throw new ParseError("unable to tokenize '"+this.text.slice(lastIndex)+"'");this.current=match[1]}}list(){const tokens=[];while(this.current!=null){tokens.push(this.current);this.advance()}return tokens}}class PCParser{constructor(operators){this.uProp={};this.bProp={};for(let operator of operators){if(operator.associativity===0){this.uProp[operator.op]=operator.precedence}else{this.bProp[operator.op]=[operator.precedence,operator.associativity<0]}}}parse(tokens){const ast=this.computeExpr(tokens,0);if(tokens.current!=null)throw new ParseError("expected end token but found token "+tokens.current);return ast}computeExpr(tokens,minPrec){let left=this.computeAtom(tokens);while(true){const token=tokens.current;if(token==null||!this.bProp.hasOwnProperty(token)){break}const[prec,lAssoc]=this.bProp[token];if(prec<minPrec){break}tokens.advance();const right=this.computeExpr(tokens,lAssoc?prec+1:prec);left={op:token,args:[left,right]}}return left}computeAtom(tokens){const token=tokens.current;if(token==null)throw new ParseError("unexpected end of token stream");tokens.advance();if(this.uProp.hasOwnProperty(token)){const arg=this.computeExpr(tokens,this.uProp[token]);return{op:token,args:[arg]}}else if(token==="("){const inner=this.computeExpr(tokens,0);if(tokens.current!==")")throw new ParseError("unexpected token "+String(tokens.current)+", expected closing parenthesis");tokens.advance();return inner}else{return token}}}

},{}],10:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.setups=exports.objectives=void 0;const objectives={"Reachability":{name:"Reachability",formula:"\\mathsf{F} \\varphi",variables:["\\varphi"],automaton:"q0>(\\varphi)>q1,q0>>q0,q1>>q1 ; q0 ; q0 ; q1",automatonPlacement:{"q0":[0,0,0],"q1":[300,0,0]}},"Reachability & Avoidance":{name:"Reachability & Avoidance",formula:"(\\neg \\pi) \\mathsf{U} \\varphi",variables:["\\varphi","\\pi"],automaton:"q0>(\\varphi)>q1,q0>(!\\pi)>q0,q1>>q1 ; q0 ; q0 ; q1",automatonPlacement:{"q0":[0,0,0],"q1":[300,0,0]}},"Safety":{name:"Safety",formula:"\\mathsf{G} (\\neg \\pi)",variables:["\\pi"],automaton:"q0>(!\\pi)>q0 ; q0 ; ; ",automatonPlacement:{"q0":[0,0,0]}},"Eventual Safety":{name:"Eventual Safety",formula:"\\mathsf{F} \\mathsf{G} \\neg \\pi",variables:["\\pi"],automaton:"q0>(!\\pi)>q1,q0>>q0,q1>(!\\pi)>q1,q1>>q0 ; q0 ; q0 ; ",automatonPlacement:{"q0":[0,0,0],"q1":[300,0,0]}},"Recurrence":{name:"Recurrence",formula:"\\mathsf{G} \\mathsf{F} \\varphi",variables:["\\varphi"],automaton:"q0>(\\varphi)>q1,q0>>q0,q1>(\\varphi)>q1,q1>>q0 ; q0 ; q0 ; q1",automatonPlacement:{"q0":[0,0,0],"q1":[300,0,0]}},"Safe 2-Recurrence":{name:"Safe 2-Recurrence",formula:"\\mathsf{G} (\\mathsf{F} \\varphi \\wedge \\mathsf{F} \\theta \\wedge \\neg \\pi)",variables:["\\varphi","\\theta","\\pi"],automaton:"q0>(!\\pi & \\varphi & \\theta)>q0,q0>(!(\\pi | \\varphi))>q1,q0>(!(\\pi | \\theta) & \\varphi)>q2,"+"q1>(!(\\pi | \\varphi))>q1,q1>(!\\pi & \\varphi & \\theta)>q0,q1>(!(\\pi | \\theta) & \\varphi)>q2,"+"q2>(!(\\pi | \\theta))>q2,q2>(!\\pi & \\theta)>q0 ; q0 ; q1,q2 ; q0",automatonPlacement:{"q0":[0,75,-10],"q1":[300,150,10],q2:[230,0,170]}}};exports.objectives=objectives;const setups={"Double Integrator":{dimension:{stateSpace:"2-dimensional",controlSpace:"1-dimensional"},equation:{A:"1\n1\n0\n1",B:"0.5\n1"},polytope:{controlSpace:"-1 < x\n x < 1",randomSpace:"-0.1 < x\n   x < 0.1\n-0.1 < y\n   y < 0.1",stateSpace:"-5 < x\n x < 5\n-3 < y\n y < 3"},predicates:"p1: -1 < x\np2:  x < 1\np3: -1 < y\np4:  y < 1",objective:"Reachability\np1 & p2 & p3 & p4\nt"},"Illustrative Example (1D)":{dimension:{stateSpace:"1-dimensional",controlSpace:"1-dimensional"},equation:{A:"1",B:"1"},polytope:{controlSpace:"-1 < x\n x < 1",randomSpace:"-0.1 < x\n   x < 0.1",stateSpace:"0 < x\nx < 4"},predicates:"p1: x > -2\np2: x < 2",objective:"Reachability\np1 & p2\nt"},"Illustrative Example (2D)":{dimension:{stateSpace:"2-dimensional",controlSpace:"2-dimensional"},equation:{A:"1\n0\n0\n1",B:"1\n0\n0\n1"},polytope:{controlSpace:"-1 < x\n x < 1\n-1 < y\n y < 1",randomSpace:"-0.1 < x\n   x < 0.1\n-0.1 < y\n   y < 0.1",stateSpace:"0 < x\nx < 4\n0 < y\ny < 2"},predicates:"p1: x > 2",objective:"Reachability\np1\nt"},"Corridor":{dimension:{stateSpace:"2-dimensional",controlSpace:"2-dimensional"},equation:{A:"1\n0\n0\n1",B:"1\n0\n0\n1"},polytope:{controlSpace:"-0.5 < x\n   x < 0.5\n-0.5 < y\n   y < 0.5",randomSpace:"-0.1 < x\n   x < 0.1\n-0.1 < y\n   y < 0.1",stateSpace:"0 < x\nx < 4\n0 < y\ny < 3"},predicates:"r1: x > 2.7\nr2: x < 1.3\nh1: y < 1.3\nh2: y > 1.7",objective:"Safe 2-Recurrence\nr1\nr2\n!r1 & !r2 & (h1 | h2)\nf"}};exports.setups=setups;

},{}],11:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.itemizedOperatorPartition=itemizedOperatorPartition;exports.ActionSupport=exports.Action=exports.State=exports.AbstractedLSS=exports.LSS=void 0;var _geometry=require("./geometry.js");var linalg=_interopRequireWildcard(require("./linalg.js"));var _tools=require("./tools.js");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}}newObj.default=obj;return newObj}}function itemizedOperatorPartition(items,operator){const parts=[];for(let item of items){const newParts=[];let remaining=operator(item);for(let part of parts){if(remaining.isEmpty){break}const common=remaining.intersect(part.region);if(!common.isEmpty){const notCommon=part.region.remove(common);if(notCommon.isEmpty){part.items.push(item)}else{part.region=notCommon;newParts.push({region:common,items:part.items.concat([item])})}remaining=remaining.remove(common)}}if(!remaining.isEmpty){newParts.push({region:remaining,items:[item]})}parts.push(...newParts)}return parts}class LSS{constructor(A,B,stateSpace,randomSpace,controlSpace){this.A=A;this.B=B;this.xx=stateSpace;this.ww=randomSpace;this.uu=controlSpace;this.dim=stateSpace.dim;this.oneStepReachable=this.post(stateSpace,controlSpace);this.xxExt=stateSpace.union(this.oneStepReachable).simplify()}static deserialize(json){return new LSS(json.A,json.B,_geometry.Polytope.deserialize(json.stateSpace),_geometry.Polytope.deserialize(json.randomSpace),_geometry.Polytope.deserialize(json.controlSpace))}get extent(){return this.xxExt.extent}eval(x,u,w){return linalg.add(linalg.add(linalg.apply(this.A,x),linalg.apply(this.B,u)),w)}post(x,us){const xvs=x.vertices;const wvs=this.ww.vertices;const posts=[];for(let u of us.polytopes){const Bupws=linalg.minkowski.axpy(this.B,u.vertices,wvs);posts.push(_geometry.Polytope.ofDim(this.dim).hull(linalg.minkowski.axpy(this.A,xvs,Bupws)))}return _geometry.Union.from(posts,this.dim).simplify()}pre(x,us,ys){const pres=[];for(let u of us.polytopes){const Bupws=linalg.minkowski.axpy(this.B,u.vertices,this.ww.vertices);for(let y of ys.polytopes){const pre=_geometry.Polytope.ofDim(this.dim).hull(linalg.minkowski.xmy(y.vertices,Bupws));pres.push(x.intersect(pre.applyRight(this.A)))}}return _geometry.Union.from(pres,this.dim).simplify()}preR(x,us,ys){const pontrys=ys.pontryagin(this.ww);if(pontrys.isEmpty){return _geometry.Polytope.ofDim(x.dim).empty()}const prers=[];for(let u of us.polytopes){const Bus=u.vertices.map(uv=>linalg.apply(this.B,uv));for(let pontry of pontrys.polytopes){const poly=_geometry.Polytope.ofDim(this.dim).hull(linalg.minkowski.xmy(pontry.vertices,Bus));prers.push(x.intersect(poly.applyRight(this.A)))}}return _geometry.Union.from(prers,this.dim).simplify()}attr(x,us,ys){return x.remove(this.preR(x,us,this.xxExt.remove(ys)))}attrR(x,us,ys){return x.remove(this.pre(x,us,this.xxExt.remove(ys)))}act(x,y){const Axpw=_geometry.Polytope.ofDim(this.dim).hull(linalg.minkowski.axpy(this.A,x.vertices,this.ww.vertices));return y.minkowski(Axpw.invert()).applyRight(this.B).intersect(this.uu)}actR(x,y){const Axpw=_geometry.Polytope.ofDim(this.dim).hull(linalg.minkowski.axpy(this.A,x.vertices,this.ww.vertices));return y.pontryagin(Axpw).applyRight(this.B).intersect(this.uu)}zNonZero(xs){return xs.minkowski(this.ww.invert()).simplify()}zOne(xs){return xs.pontryagin(this.ww)}decompose(predicates,predicateLabels){const system=new AbstractedLSS(this);const outer=this.oneStepReachable.remove(this.xx);for(let polytope of outer.polytopes){system.newState(polytope,true)}predicateLabels=predicateLabels==null?predicates.map(_=>""):predicateLabels;for(let[label,predicate]of _tools.arr.zip2(predicateLabels,predicates)){if(label.length>0)system.predicates.set(label,predicate)}const partition=itemizedOperatorPartition(_tools.arr.zip2(predicateLabels,predicates),([label,predicate])=>this.xx.split(predicate)[0]);for(let part of partition){if(part.region.polytopes.length!==1)throw new Error("State space was not split properly by linear predicates");system.newState(part.region.polytopes[0],false,part.items.map(_=>_[0]).filter(_=>_.length>0))}let leftOverPoly=this.xx;for(let predicate of predicates){leftOverPoly=leftOverPoly.split(predicate)[1]}if(!leftOverPoly.isEmpty){system.newState(leftOverPoly,false,[])}return system}serialize(){return{A:this.A,B:this.B,stateSpace:this.xx.serialize(),randomSpace:this.ww.serialize(),controlSpace:this.uu.serialize()}}}exports.LSS=LSS;class AbstractedLSS{constructor(lss){this.lss=lss;this.states=new Map;this.predicates=new Map;this._epsPolytope=lss.ww.scale(0.1);this._labelNum=0}static deserialize(json){const system=new AbstractedLSS(LSS.deserialize(json.lss));system._labelNum=json._labelNum;for(let label in json.predicates){system.predicates.set(label,_geometry.Halfspace.deserialize(json.predicates[label]))}for(let jsonState of json.states){const state=State.deserialize(jsonState,system,false);system.states.set(state.label,state)}for(let jsonState of json.states){const state=system.getState(jsonState.label);state._restoreActions(jsonState.actions)}return system}get extent(){return this.lss.extent}newState(polytope,isOuter,predicates){const label=this.genLabel();const state=new State(this,label,polytope,isOuter,predicates);this.states.set(label,state);return state}genLabel(){this._labelNum++;const label="X"+this._labelNum.toString();return this.states.has(label)?this.genLabel():label}getState(label){return(0,_tools.just)(this.states.get(label),"A state with label '"+label+"' does not exist")}getPredicate(label){return(0,_tools.just)(this.predicates.get(label),"A predicate with label '"+label+"' does not exist")}stateOf(x){for(let state of this.states.values()){if(state.polytope.contains(x)){return state}}return null}refine(partitions){const refined=new Map;for(let[state,partition]of partitions){if(state._isEpsSmall)continue;if(!state.polytope.isSameAs(partition))throw new Error("Partition for state "+state.label+" does not cover the entire state");if(partition.polytopes.length===1)continue;const newStates=new Set;for(let poly of partition.polytopes){newStates.add(this.newState(poly,state.isOuter,state.predicates))}refined.set(state,newStates);this.states.delete(state.label)}this.resetActions(new Set(refined.keys()));return refined}resetActions(targets){for(let state of this.states.values()){state.resetActions(targets)}}post(x,us){return this.lss.post(x.polytope,us)}pre(x,us,ys){return this.lss.pre(x.polytope,us,_geometry.Union.from(Array.from(ys,y=>y.polytope),this.lss.dim))}preR(x,us,ys){return this.lss.preR(x.polytope,us,_geometry.Union.from(Array.from(ys,y=>y.polytope),this.lss.dim))}attr(x,us,ys){return this.lss.attr(x.polytope,us,_geometry.Union.from(Array.from(ys,y=>y.polytope),this.lss.dim))}attrR(x,us,ys){return this.lss.attrR(x.polytope,us,_geometry.Union.from(Array.from(ys,y=>y.polytope),this.lss.dim))}act(x,y){return this.lss.act(x.polytope,y.polytope)}actR(x,y){return this.lss.actR(x.polytope,y.polytope)}zNonZero(xs){return this.lss.zNonZero(_geometry.Union.from(Array.from(xs,x=>x.polytope),this.lss.dim))}zOne(xs){return this.lss.zOne(_geometry.Union.from(Array.from(xs,x=>x.polytope),this.lss.dim))}get stateLabels(){return new Set(this.states.keys())}predicateLabelsOf(stateLabel){return(0,_tools.just)(this.states.get(stateLabel),"State with label '"+stateLabel+"' not found.").predicates}actionCountOf(stateLabel){return(0,_tools.just)(this.states.get(stateLabel),"State with label '"+stateLabel+"' not found.").actions.length}supportCountOf(stateLabel,actionId){return(0,_tools.just)(this.states.get(stateLabel),"State with label '"+stateLabel+"' not found.").actions[actionId].supports.length}targetLabelsOf(stateLabel,actionId,supportId){const state=(0,_tools.just)(this.states.get(stateLabel),"State with label '"+stateLabel+"' not found.");return new Set(_tools.iter.map(s=>s.label,state.actions[actionId].supports[supportId].targets))}serializeGameGraph(analysis){const states={};for(let[label,state]of this.states){const result=analysis==null?null:analysis.get(label);let actions=[];if(result==null||result.maybe.size!==0){actions=state.actions.map(action=>action.supports.map(support=>Array.from(support.targets,target=>target.label)))}states[label]={predicates:Array.from(state.predicates),actions:actions}}return states}serialize(includeGraph){const predicates={};for(let[label,predicate]of this.predicates){predicates[label]=predicate.serialize()}return{lss:this.lss.serialize(),predicates:predicates,states:Array.from(_tools.iter.map(_=>_.serialize(includeGraph),this.states.values())),_labelNum:this._labelNum}}}exports.AbstractedLSS=AbstractedLSS;class State{constructor(system,label,polytope,isOuter,predicates){this.system=system;this.label=label;this.polytope=polytope;this.isOuter=isOuter;this.predicates=new Set(predicates==null?[]:predicates);this._actions=null;this.resetActions();this._isEpsSmall=polytope.pontryagin(system._epsPolytope).isEmpty}static deserialize(json,system,restoreActions){const polytope=_geometry.Polytope.deserialize(json.polytope);const state=new State(system,json.label,polytope,json.isOuter,json.predicates);if(restoreActions==null||restoreActions){state._restoreActions(json.actions)}return state}_restoreActions(json){if(json==null)return;this._actions=json.map(_=>Action.deserialize(_,this));const reachable=new Set;for(let action of this._actions){for(let target of action.targets){reachable.add(target)}}this._reachable=reachable}get actions(){if(this._actions!=null){return this._actions}else{const op=target=>this.act(target);this._reachable=this.oneStepReachable(this.system.lss.uu);this._actions=itemizedOperatorPartition(this._reachable,op).map(part=>new Action(this,part.items,part.region.simplify()));return this.actions}}post(us){return this.system.post(this,us)}pre(us,ys){return this.system.pre(this,us,ys)}preR(us,ys){return this.system.preR(this,us,ys)}attr(us,ys){return this.system.attr(this,us,ys)}attrR(us,ys){return this.system.attrR(this,us,ys)}oneStepReachable(us){const post=this.post(us);const out=new Set;for(let state of this.system.states.values()){if(!post.intersect(state.polytope).isEmpty)out.add(state)}return out}act(y){return this.system.act(this,y)}actR(y){return this.system.actR(this,y)}zNonZero(){return this.system.zNonZero([this])}zOne(){return this.system.zOne([this])}refine(partition){return this.system.refine(new Map([[this,partition]]))}resetActions(targets){if(this._actions==null||targets==null||_tools.sets.doIntersect(this._reachable,targets)){this._actions=this.isOuter?[]:null;this._reachable=new Set}}serialize(includeGraph){let actions=null;if(includeGraph!=null&&includeGraph&&this._actions!=null){actions=this._actions.map(_=>_.serialize(includeGraph))}return{label:this.label,polytope:this.polytope.serialize(),isOuter:this.isOuter,predicates:Array.from(this.predicates),actions:actions}}}exports.State=State;class Action{constructor(origin,targets,controls){this.origin=origin;this.targets=new Set(targets);this.controls=controls;this._supports=null}static deserialize(json,origin){const targets=json.targets.map(_=>origin.system.getState(_));const action=new Action(origin,targets,_geometry.Union.deserialize(json.controls));if(json.supports!=null){action._supports=json.supports.map(_=>ActionSupport.deserialize(_,action))}return action}get supports(){if(this._supports!=null){return this._supports}else{const lss=this.origin.system.lss;const zNonZeros=itemizedOperatorPartition(this.targets,_=>_.zNonZero());const zOnes=lss.zOne(_geometry.Union.from(Array.from(this.targets,_=>_.polytope)));this._supports=zNonZeros.map(part=>{const zs=part.region.intersect(zOnes).polytopes;const prePs=[];for(let u of this.controls.polytopes){const Bus=u.vertices.map(_=>linalg.apply(lss.B,_));for(let z of zs){const preP=_geometry.Polytope.ofDim(lss.dim).hull(linalg.minkowski.xmy(z.vertices,Bus));prePs.push(preP.applyRight(lss.A))}}const preP=prePs.length===0?_geometry.Polytope.ofDim(lss.dim).empty():_geometry.Union.from(prePs);return new ActionSupport(this,part.items,preP.intersect(this.origin.polytope).simplify())}).filter(_=>!_.origins.isEmpty);return this.supports}}serialize(includeGraph){let supports=null;if(includeGraph!=null&&includeGraph&&this._supports!=null){supports=this._supports.map(_=>_.serialize())}return{targets:Array.from(this.targets,_=>_.label),controls:this.controls.toUnion().serialize(),supports:supports}}}exports.Action=Action;class ActionSupport{constructor(action,targets,origins){this.action=action;this.targets=new Set(targets);this.origins=origins}static deserialize(json,action){const targets=json.targets.map(x=>action.origin.system.getState(x));return new ActionSupport(action,targets,_geometry.Union.deserialize(json.origins))}serialize(){return{targets:Array.from(this.targets,x=>x.label),origins:this.origins.toUnion().serialize()}}}exports.ActionSupport=ActionSupport;

},{"./geometry.js":3,"./linalg.js":7,"./tools.js":12}],12:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.just=just;exports.xor=xor;exports.replaceAll=replaceAll;exports.hashString=hashString;exports.n2s=n2s;exports.t2s=t2s;exports.UniqueCollection=exports.ObservableMixin=exports.obj=exports.sets=exports.arr=exports.iter=exports.ValueError=exports.NotImplementedError=void 0;class NotImplementedError extends Error{}exports.NotImplementedError=NotImplementedError;class ValueError extends Error{}exports.ValueError=ValueError;function just(val,err){if(val==null)throw new ValueError(err==null?"Value is null but shouldn't be":err);return val}function xor(p,q){return p?!q:q}const iter={some:function(xs){for(let x of xs){if(x)return true}return false},every:function(xs){for(let x of xs){if(!x)return false}return true},sum:function(xs){let s=0;for(let x of xs){s+=x}return s},count:function(xs){let c=0;for(let x of xs){c++}return c},map:function*(fun,xs){for(let x of xs){yield fun(x)}},filter:function*(test,xs){for(let x of xs){if(test(x)){yield x}}},chain:function*(...xss){for(let xs of xss){yield*xs}},argmax:function(value,xs){let maxArg=null;let maxVal=-Infinity;for(let x of xs){const val=value(x);if(val>maxVal){maxArg=x;maxVal=val}}return maxArg}};exports.iter=iter;const arr={zip2map:function(fun,xs,ys){let zs=[];for(let i=0;i<xs.length;i++){zs[i]=fun(xs[i],ys[i])}return zs},zip2:function(xs,ys){return arr.zip2map((x,y)=>[x,y],xs,ys)},cyc2map:function(fun,xs){if(xs.length==0)return[];const zs=[];for(let i=0;i<xs.length-1;i++){zs.push(fun(xs[i],xs[i+1]))}zs.push(fun(xs[xs.length-1],xs[0]));return zs},intersperse:function(delim,items){const out=[];for(let item of items){out.push(item);out.push(delim)}out.pop();return out},sample:function(items){return items[Math.floor(Math.random()*items.length)]}};exports.arr=arr;const sets={areEqual:function(xs,ys){if(xs.size!==ys.size){return false}for(let y of ys){if(!xs.has(y)){return false}}return true},isSubset:function(subs,sups){for(let sub of subs){if(!sups.has(sub)){return false}}return true},doIntersect:function(xs,ys){for(let x of xs){if(ys.has(x)){return true}}return false},union:function(...xss){return new Set(iter.chain(...xss))},intersection:function(xs,ys){return new Set(iter.filter(x=>ys.has(x),xs))},difference:function(xs,ys){return new Set(iter.filter(x=>!ys.has(x),xs))},map:function(fun,xs){return new Set(iter.map(fun,xs))},filter:function(fun,xs){return new Set(iter.filter(fun,xs))}};exports.sets=sets;const obj={forEach:function(fun,kvs){for(let key in kvs){if(kvs.hasOwnProperty(key)){fun(key,kvs[key])}}},map2Array:function(fun,kvs){const out=[];obj.forEach((key,val)=>{out.push(fun(key,val))},kvs);return out},map:function(fun,kvs){const out={};obj.forEach((key,val)=>{out[key]=fun(key,val)},kvs);return out},values:function(kvs){return obj.map2Array((k,v)=>v,kvs)},keys:function(kvs){return obj.map2Array((k,v)=>k,kvs)},merge:function(...kvss){const out={};for(let kvs of kvss){obj.forEach((key,val)=>{out[key]=val},kvs)}return out},clone:function(kvs){return Object.assign({},kvs)},fromMap:function(fun,ks){const out={};for(let k of ks){out[k]=fun(k)}return out}};exports.obj=obj;function replaceAll(haystack,needle,substitute){return haystack.split(needle).join(substitute)}function hashString(s){let hash=0;if(s.length!==0){for(let i=0;i<s.length;i++){hash=(hash<<5)-hash+s.charCodeAt(i);hash|=0}}return hash}function n2s(x,places){if(places==null)places=5;return x.toFixed(places).replace(/\.?0*$/,"")}const MSINS=1000;const MSINM=60*MSINS;const MSINH=60*MSINM;function t2s(x){const hor=Math.floor(x/MSINH);const min=Math.floor((x-hor*MSINH)/MSINM);const sec=Math.floor((x-hor*MSINH-min*MSINM)/MSINS);if(sec===0&&min===0&&hor===0){return(x/1000).toFixed(3)+" s"}else{const parts=[];if(hor>0)parts.push(hor+" h");if(min>0)parts.push(min+" min");if(sec>0)parts.push(sec+" s");return parts.join(" ")}}class ObservableMixin{constructor(){this.observers=[];this.isSendingNotifications=true}attach(observer,callImmediately){this.observers.push(observer);if(callImmediately===true)observer()}detach(observer){let idx=this.observers.indexOf(observer);if(idx<0){throw new Error("observer was not attached")}this.observers.splice(idx,1)}notify(event){if(this.isSendingNotifications){for(let observer of this.observers){observer(event)}}}}exports.ObservableMixin=ObservableMixin;class UniqueCollection{constructor(hash,areEqual){this._hash=hash;this._areEqual=areEqual;this._buckets=new Map;this._size=0}get size(){return this._size}has(value){const hash=this._hash(value);const bucket=this._buckets.get(hash);if(bucket!=null){for(let item of bucket){if(this._areEqual(item,value)){return true}}}return false}take(value){const hash=this._hash(value);let bucket=this._buckets.get(hash);if(bucket==null){bucket=this._newBucket(hash);bucket.add(value);this._size++;return value}for(let item of bucket){if(this._areEqual(item,value)){return item}}bucket.add(value);this._size++;return value}_newBucket(hash){const bucket=new Set;this._buckets.set(hash,bucket);return bucket}*[Symbol.iterator](){for(let values of this._buckets.values()){yield*values}}}exports.UniqueCollection=UniqueCollection;

},{}],13:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.inputTextRotation=inputTextRotation;exports.MatrixInput=exports.CheckboxInput=exports.RadioInput=exports.DropdownInput=exports.MultiLineInput=exports.LineInput=exports.ValidationError=void 0;var dom=_interopRequireWildcard(require("./dom.js"));var _tools=require("./tools.js");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}}newObj.default=obj;return newObj}}class ValidationError extends Error{}exports.ValidationError=ValidationError;;function inputTextRotation(input,texts){if(texts.length<1)throw new Error("texts must contain at least one choice");return function(){const idx=texts.indexOf(input.text);input.text=idx<0?texts[0]:texts[(idx+1)%texts.length]}}class LineInput extends _tools.ObservableMixin{constructor(parse,size,initialText){super();this.parse=parse;this.node=dom.INPUT({"type":"text"});if(size!=null){this.size=size}if(initialText!=null){this.text=initialText}this.node.addEventListener("change",()=>this.handleChange())}get value(){return this.parse(this.text)}get text(){return this.node.value}set text(text){this.node.value=text;this.handleChange()}set disabled(tf){this.node.disabled=tf}get isValid(){return this.node.checkValidity()}set size(size){this.node.size=size}handleChange(){try{this.value;this.node.setCustomValidity("")}catch(e){this.node.setCustomValidity("Parse Error: "+e.message)}this.notify()}}exports.LineInput=LineInput;class MultiLineInput extends _tools.ObservableMixin{constructor(parseLine,size,initialText){super();this.node=dom.TEXTAREA();this.node.addEventListener("change",()=>this.handleChange());this.parseLine=parseLine;if(size!=null){this.size=size}if(initialText!=null){this.text=initialText}}get value(){return this.text.split("\n").filter(line=>line.length>0).map((line,i)=>{try{return this.parseLine(line)}catch(e){e.message="Line "+(i+1)+": "+e.message;throw e}})}get text(){return this.node.value}set text(text){this.node.value=text;this.handleChange()}set disabled(tf){this.node.disabled=tf}get isValid(){return this.node.checkValidity()}set size(size){this.node.rows=size[0];this.node.cols=size[1]}handleChange(){try{this.value;this.node.setCustomValidity("")}catch(e){this.node.setCustomValidity("Parse Error: "+e.message)}this.notify()}}exports.MultiLineInput=MultiLineInput;class DropdownInput extends _tools.ObservableMixin{constructor(options,initialText){super();this.node=dom.SELECT();this.node.addEventListener("change",()=>this.handleChange());this.isValid=true;this.setOptions(options,initialText)}get value(){return this._options[this.text]}get text(){return this.node.value}set text(text){if(!this._options.hasOwnProperty(text))throw new Error("text '"+text+"' not in options: "+_tools.obj.keys(this._options).join(", "));this.node.value=text;this.handleChange()}set disabled(tf){this.node.disabled=tf}setOptions(options,initialText){this._options=options;dom.replaceChildren(this.node,_tools.obj.map2Array((k,v)=>dom.OPTION({},[k]),options));this.text=initialText!=null?initialText:Object.keys(options)[0]}handleChange(){this.notify()}static rangeOptions(start,stop,step){const options={};for(let i=start;i<stop;i+=step){options[String(i)]=i}return options}}exports.DropdownInput=DropdownInput;let ID_GEN=0;class RadioInput extends _tools.ObservableMixin{constructor(options,initialText,nodeify){super();this.nodeify=nodeify==null?null:nodeify;this.isValid=true;this._disabled=false;this.name="radio_id_"+ID_GEN++;this.node=dom.DIV();this.setOptions(options,initialText)}get value(){return this._options[this.text]}get text(){for(let radio of this._radios){if(radio.checked)return radio.value}throw new Error("no radio is selected")}set text(text){if(!this._options.hasOwnProperty(text))throw new Error("text '"+text+"' not in options: "+_tools.obj.keys(this._options).join(", "));for(let radio of this._radios){radio.checked=radio.value===text}this.notify()}set disabled(tf){this._disabled=tf;for(let radio of this._radios){radio.disabled=tf}}setOptions(options,initialText){this._radios=[];this._options=options;dom.replaceChildren(this.node,_tools.obj.map2Array((text,_)=>{const radio=dom.INPUT({"type":"radio","name":this.name,"value":text});radio.addEventListener("change",()=>this.handleChange());radio.disabled=this._disabled;this._radios.push(radio);return dom.LABEL({},[radio,this.nodeify==null?text:this.nodeify(text)])},options));this.text=initialText!=null?initialText:Object.keys(options)[0]}handleChange(){this.notify()}}exports.RadioInput=RadioInput;class CheckboxInput extends _tools.ObservableMixin{constructor(initialValue,label){super();this.isValid=true;this._box=dom.INPUT({"type":"checkbox"});this._box.addEventListener("change",()=>this.handleChange());this._box.checked=initialValue!=null&&initialValue;this.node=dom.LABEL({},label==null?[this._box]:[this._box,label])}get value(){return this._box.checked}get text(){return this.value?"t":"f"}set text(text){this._box.checked=text==="t";this.handleChange()}set disabled(tf){this._box.disabled=tf}handleChange(){this.notify()}}exports.CheckboxInput=CheckboxInput;class MatrixInput extends _tools.ObservableMixin{constructor(parse,shape,size,initialText){super();this.parse=parse;this._shape=shape;this._size=size;this._disabled=false;this.node=dom.TABLE({"class":"matrix"});this._createLineInputs();if(initialText!=null){this.text=initialText}}get value(){let[nrows,ncols]=this._shape;let value=[];for(let i=0;i<nrows;i++){let row=[];for(let j=0;j<ncols;j++){row.push(this.lineInputs[i*ncols+j].value)}value.push(row)}return value}get text(){return this.lineInputs.map(lineInput=>lineInput.text).join("\n")}set text(text){this.isSendingNotifications=false;_tools.arr.zip2map((lineInput,text)=>{lineInput.text=text},this.lineInputs,text.split("\n"));this.isSendingNotifications=true;this.handleChange()}set disabled(tf){this._disabled=tf;for(let lineInput of this.lineInputs){lineInput.disabled=tf}}get isValid(){for(let lineInput of this.lineInputs){if(!lineInput.isValid){return false}}return true}set size(size){this._size=size;for(let lineInput of this.lineInputs){lineInput.size=size}}get shape(){return this._shape}set shape(shape){let[nrowsOld,ncolsOld]=this._shape;let oldTexts=this.text.split("\n");this.isSendingNotifications=false;this._shape=shape;this._createLineInputs();let[nrows,ncols]=shape;for(let i=0;i<Math.min(nrows,nrowsOld);i++){for(let j=0;j<Math.min(ncols,ncolsOld);j++){this.lineInputs[i*ncols+j].text=oldTexts[i*ncolsOld+j]}}this.isSendingNotifications=true;this.handleChange()}_createLineInputs(){const[nrows,ncols]=this._shape;this.lineInputs=[];const callback=()=>this.handleChange();const trs=[];for(let i=0;i<nrows;i++){const tds=[];for(let j=0;j<ncols;j++){const input=new LineInput(this.parse,this._size,"");input.attach(callback);input.disabled=this._disabled;tds.push(dom.create("td",{},[input.node]));this.lineInputs.push(input)}trs.push(dom.create("tr",{},tds))}dom.replaceChildren(this.node,trs)}handleChange(){this.notify()}}exports.MatrixInput=MatrixInput;

},{"./dom.js":1,"./tools.js":12}],14:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.ShapePlot=exports.AxesPlot=exports.InteractivePlot=void 0;var linalg=_interopRequireWildcard(require("./linalg.js"));var dom=_interopRequireWildcard(require("./dom.js"));var _tools=require("./tools.js");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}}newObj.default=obj;return newObj}}function toStr(x){return x.toFixed(3)}class InteractivePlot{constructor(size,figure,projection){this._referenceProjection=projection;const resetButton=dom.create("a",{"href":""},["reset"]);resetButton.addEventListener("click",e=>{this.projection=this._referenceProjection;e.preventDefault()});const saveButton=dom.create("a",{"href":"","download":"plot.svg"},["export"]);saveButton.addEventListener("click",()=>{saveButton.setAttribute("href","data:image/svg+xml;base64,"+window.btoa(this.axesPlot.source))});const coordsDisplay=dom.SPAN({"class":"coords"});this.menu=dom.DIV({"class":"menu"},[coordsDisplay,"hold shift to pan and zoom :: ",resetButton," :: ",saveButton]);this.axesPlot=new AxesPlot(size,figure,projection);this.node=dom.DIV({"class":"plot"},[this.menu,this.axesPlot.node]);const shapePlot=this.axesPlot.shapePlot;shapePlot.node.addEventListener("mousemove",e=>{const coords=shapePlot.getCoords(e.clientX,e.clientY);dom.replaceChildren(coordsDisplay,[coords.map(_=>(0,_tools.n2s)(_,2)).join(", ")])});shapePlot.node.addEventListener("wheel",e=>{if(e.shiftKey){this.projection=this.projection.zoom(e.deltaY>0?1.12:1/1.12);e.preventDefault()}});let panningState=null;shapePlot.node.addEventListener("mouseleave",()=>{dom.removeChildren(coordsDisplay);if(panningState!=null){panningState=null;dom.setCursor("auto")}});shapePlot.node.addEventListener("mousedown",e=>{if(e.buttons==1&&e.shiftKey){panningState=shapePlot.getCoords(e.clientX,e.clientY);e.preventDefault();dom.setCursor("grabbing")}});shapePlot.node.addEventListener("mouseup",e=>{if(panningState!=null&&e.target!=shapePlot.node){this.projection=this.projection.translate(panningState,shapePlot.getCoords(e.clientX,e.clientY));panningState=null;dom.setCursor("auto");e.stopPropagation()}});shapePlot.node.addEventListener("click",e=>{if(panningState!=null){this.projection=this.projection.translate(panningState,shapePlot.getCoords(e.clientX,e.clientY));panningState=null;dom.setCursor("auto");e.stopPropagation()}})}get size(){return this.axesPlot.size}set size(size){this.axesPlot.size=size}get projection(){return this.axesPlot.projection}set projection(projection){this.axesPlot.projection=projection}set referenceProjection(projection){this._referenceProjection=projection}get figure(){return this.axesPlot.figure}addMenuElement(node){dom.appendChildren(this.menu,[" :: ",node])}}exports.InteractivePlot=InteractivePlot;class AxesPlot{constructor(size,figure,projection){this.ticks=dom.createSVG("g",{"stroke":"#000","stroke-width":"1"});this.tickLabels=dom.createSVG("g",{"font-family":"DejaVu Sans, sans-serif","font-size":"8pt"});this.shapePlot=new ShapePlot(size,figure,projection);this.shapePlot.node.setAttribute("x","5");this.shapePlot.node.setAttribute("y","5");this.node=dom.createSVG("svg",{xmlns:dom.SVGNS},[this.tickLabels,this.shapePlot.node,this.ticks]);this.draw()}get size(){return this.shapePlot.size}set size(size){this.shapePlot.size=size;this.draw()}get figure(){return this.shapePlot.figure}get projection(){return this.shapePlot.projection}set projection(projection){this.shapePlot.projection=projection;this.draw()}get source(){return this.node.outerHTML}draw(){let[sizeX,sizeY]=this.size;this.node.setAttribute("width",String(sizeX+45));this.node.setAttribute("height",String(sizeY+25));const ticks=[];const labels=[];for(let tick of this.projection.getXTicks(Math.ceil(sizeX/43))){let x=5+tick[0]*sizeX;ticks.push(this._createTickLine(x,x,sizeY+1,sizeY+4.5));labels.push(this._createTickLabel(x,sizeY+20,"middle",tick[1]))}for(let tick of this.projection.getYTicks(Math.ceil(sizeY/30))){let y=(1-tick[0])*sizeY+5;ticks.push(this._createTickLine(sizeX+1,sizeX+4.5,y,y));labels.push(this._createTickLabel(12+sizeX,y+4,"start",tick[1]))}dom.replaceChildren(this.ticks,ticks);dom.replaceChildren(this.tickLabels,labels)}_createTickLine(x1,x2,y1,y2){return dom.createSVG("line",{"x1":toStr(x1),"y1":toStr(y1),"x2":toStr(x2),"y2":toStr(y2)})}_createTickLabel(x,y,anchor,label){return dom.createSVG("text",{"x":toStr(x),"y":toStr(y),"text-anchor":anchor},[label])}}exports.AxesPlot=AxesPlot;class ShapePlot{constructor(size,figure,projection,drawBorder){this._projection=projection;this.figure=figure;this.figure.attach(e=>{if(e!=null&&e.event=="newLayer"){let group=new ShapeGroup(this,e.layer);this.groups.push(group)}this.draw()});this.groups=[];for(let layer of figure.layers){this.groups.push(new ShapeGroup(this,layer))}this._background=dom.createSVG("rect",{x:"0",y:"0",width:"0",height:"0",stroke:"none",fill:"#FFFFFF"});this._drawBorder=drawBorder==null||drawBorder;this._border=dom.createSVG("rect",{x:"0.5",y:"0.5",width:"0",height:"0",stroke:"#000000","stroke-width":"1",fill:"none"});this.node=dom.createSVG("svg",{xmlns:dom.SVGNS});this.size=size}get size(){return[this._sizeX,this._sizeY]}set size(size){this._sizeX=size[0];this._sizeY=size[1];this.node.setAttribute("width",String(this._sizeX));this.node.setAttribute("height",String(this._sizeY));this._background.setAttribute("width",String(this._sizeX));this._background.setAttribute("height",String(this._sizeY));this._border.setAttribute("width",String(this._sizeX-1));this._border.setAttribute("height",String(this._sizeY-1));this.draw()}get projection(){return this._projection}set projection(projection){this._projection=projection;this.draw()}getCoords(clientX,clientY){let rect=this.node.getBoundingClientRect();let x=Math.floor(clientX-rect.left)/(rect.width-1)*rect.width;let y=Math.floor(clientY-rect.top)/(rect.height-1)*rect.height;return this.projection.bwd(this.scaleBwd([x,y]))}scaleFwd(coords){let[x,y]=coords;return[x*this._sizeX,(1-y)*this._sizeY]}scaleBwd(coords){let x=coords[0]/this._sizeX;let y=1-coords[1]/this._sizeY;return[x,y]}project(shape){return this.projection.project(shape)}draw(){const children=[this._background];for(let group of this.groups){children.push(group.node);group.draw()}if(this._drawBorder){children.push(this._border)}dom.replaceChildren(this.node,children)}}exports.ShapePlot=ShapePlot;class ShapeGroup{constructor(shapePlot,layer){this.shapePlot=shapePlot;this.layer=layer;this.layer.attach(()=>this.draw());this.node=dom.createSVG("g",this.layer.style)}draw(){const children=[];for(let shape of this.layer.shapes){const primitives=this.shapePlot.project(shape);const shapeStyle=shape.style==null?{}:shape.style;const events=shape.events==null?{}:shape.events;for(let primitive of primitives){const style=_tools.obj.merge(primitive.style==null?{}:primitive.style,shapeStyle);if(primitive.kind==="polygon"){let node=dom.createSVG("polygon",{points:primitive.points.map(point=>{return this.fwd(point).map(toStr).join(",")}).join(" ")});dom.setAttributes(node,style);dom.addEventListeners(node,events);children.push(node)}else if(primitive.kind==="label"){let xy=this.fwd(primitive.coords);let node=dom.snLabel.toSVG(primitive.text);node.setAttribute("x",toStr(xy[0]));node.setAttribute("y",toStr(xy[1]));dom.setAttributes(node,style);dom.addEventListeners(node,events);children.push(node)}else if(primitive.kind==="marker"){const[x,y]=this.fwd(primitive.coords);const node=dom.createSVG("circle",{cx:toStr(x),cy:toStr(y),r:toStr(primitive.size)});dom.setAttributes(node,style);dom.addEventListeners(node,events);children.push(node)}else if(primitive.kind==="arrow"){let[x1,y1]=this.fwd(primitive.origin);let[x2,y2]=this.fwd(primitive.target);if(linalg.areClose(primitive.origin,primitive.target)){const node=dom.createSVG("circle",{cx:toStr(x1),cy:toStr(y1),r:"3"});dom.setAttributes(node,style);dom.addEventListeners(node,events);children.push(node)}else{let nvec=[x2-x1,y2-y1];let norm=linalg.norm2(nvec);nvec=[nvec[0]/norm,nvec[1]/norm];if(primitive.deltaO!=null){const[dxO,dyO]=primitive.deltaO;x1+=dxO*nvec[0]-dyO*nvec[1];y1+=dxO*nvec[1]+dyO*nvec[0]}if(primitive.deltaT!=null){const[dxT,dyT]=primitive.deltaT;x2+=dxT*nvec[0]-dyT*nvec[1];y2+=dxT*nvec[1]+dyT*nvec[0]}const line=dom.createSVG("line",{x1:toStr(x1),y1:toStr(y1),x2:toStr(x2),y2:toStr(y2)});const scale=6/Math.sqrt(2);const l=[x2-(nvec[0]-nvec[1])*scale,y2-(nvec[0]+nvec[1])*scale];const r=[x2-(nvec[0]+nvec[1])*scale,y2-(nvec[1]-nvec[0])*scale];const triangle=dom.createSVG("polygon",{points:[[x2,y2],l,r].map(p=>p.map(toStr).join(",")).join(" ")});dom.setAttributes(line,style);dom.addEventListeners(line,events);dom.setAttributes(triangle,style);dom.addEventListeners(triangle,events);children.push(line,triangle)}}else if(primitive.kind==="loop"){const[x,y]=this.fwd(primitive.coords);const line=dom.createSVG("path",{d:"M -6,-20 C -18,-35 -6,-40 0,-40 C 6,-40 18,-35 7,-22",fill:"none",transform:"translate("+toStr(x)+" "+toStr(y)+") rotate("+toStr(primitive.angle)+")"});const triangle=dom.createSVG("polygon",{points:"4.95,-26.63 12.63,-23.05 7,-21",transform:"translate("+toStr(x)+" "+toStr(y)+") rotate("+toStr(primitive.angle)+")"});dom.setAttributes(line,style);line.setAttribute("fill","none");dom.addEventListeners(line,events);dom.setAttributes(triangle,style);dom.addEventListeners(triangle,events);children.push(line,triangle)}else if(primitive.kind==="__label"){const[x1,y1]=this.fwd(primitive.p1);const[x2,y2]=this.fwd(primitive.p2);const nvec=[x2-x1,y2-y1];const scale=-primitive.offset/linalg.norm2(nvec);const x=0.5*(x1+x2)+nvec[1]*scale;const y=0.5*(y1+y2)-nvec[0]*scale;const angle=180*Math.atan2(nvec[1],nvec[0])/Math.PI;let textAnchor="middle";if(angle>15&&angle<165)textAnchor="start";if(angle<-15&&angle>-165)textAnchor="end";const text=dom.createSVG("text",{"x":toStr(x),"y":toStr(y),"text-anchor":textAnchor,"transform":"rotate("+0+" "+toStr(x)+" "+toStr(y)+")"},[primitive.text]);dom.setAttributes(text,style);dom.addEventListeners(text,events);children.push(text)}else{throw new Error("unknown primitive kind '"+primitive.kind+"'")}}}dom.replaceChildren(this.node,children)}fwd(coords){return this.shapePlot.scaleFwd(coords)}}

},{"./dom.js":1,"./linalg.js":7,"./tools.js":12}],15:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.Communicator=void 0;class Communicator{constructor(idPrefix){this._idPrefix=idPrefix;this._idCounter=0;this._callbacks=new Map;this._handlers=new Map;this._host=null}get host(){if(this._host==null)throw new Error("No host attached");return this._host}set host(host){this._host=host;this._host.onmessage=e=>this._receive(e.data)}request(kind,data){const message={kind:kind,data:data,id:this._genId()};return new Promise((resolve,reject)=>{this._callbacks.set(message.id,answer=>{this._callbacks.delete(message.id);if(answer.kind==="error"){reject(new Error(answer.data))}else{resolve(answer.data)}});this.host.postMessage(message)})}onRequest(kind,handler){this._handlers.set(kind,handler)}postAnswer(msg,data){this.host.postMessage({id:msg.id,kind:msg.kind,data:data})}postError(msg,data){this.host.postMessage({id:msg.id,kind:"error",data:data})}_genId(){return this._idPrefix+this._idCounter++}_receive(raw){if(typeof raw==="object"&&raw!=null){const message={id:"",kind:"",data:null};if(raw.hasOwnProperty("id")&&typeof raw.id==="string"){message.id=raw.id}else{throw new Error("No/Invalid id in message '"+JSON.stringify(raw)+"'")}if(raw.hasOwnProperty("kind")&&typeof raw.kind==="string"){message.kind=raw.kind}else{throw new Error("No/Invalid kind in message '"+JSON.stringify(raw)+"'")}if(raw.hasOwnProperty("data")){message.data=raw.data}const callback=this._callbacks.get(message.id);if(callback!=null){callback(message);return}const handler=this._handlers.get(message.kind);if(handler!=null){try{this.postAnswer(message,handler(message.data))}catch(err){this.postError(message,err.message)}return}throw new Error("No handler for request of kind '"+message.kind+"'")}else{throw new Error("Received invalid message: '"+JSON.stringify(raw)+"'")}}}exports.Communicator=Communicator;

},{}]},{},[6]);
