Holistic refinement procedures seek patterns in the entire product game graph.
Geometric refinement procedures are that can work without the game graph are limited in their scope, usually restricted to insights from a single-step lookahead. 
Deeper insight into the game graph based on multi-step behaviour is expensive to obtain, especially because the game graph grows rapidly when the number of state space partition elements increases.

Here, an approach based on the extraction of simpler sub-problems from the product game is presented.
The idea behind this approach is that once enough sub-problems have been solved, a solution for the full problems is likely to emerge.
After a cursory discussion of possible approaches, a transition-based decomposition into a series of reachability/avoidance problems is presented that, when combined with positive robust refinement, results in a computationally cheap but powerful refinement technique.


\startsubsection[title={Subset Approaches}]

    Construction of the full product game graph is expensive due to the exponential complexity of the computation of player actions.
    Every satisfying strategy that requires only a subset of the entire product game can obviously also be realized in the full product game.
    This property can be exploited by positive refinement techniques to reduce computational demands.
    Negative refinement based on a partial game graph in general does not benefit from this property as the full product game allows more behaviour than any of its subsets.

    A notable subset extraction consists of choosing a fixed control input region for every state of the product game, such that only a single action is enabled in every player 1 state.
    In this subset, the dynamics of the associated LSS become piecewise linear and player 1 has no control abilities anymore, dropping out of the game which is reduced to a 1½-player game, i.e.\ an MDP.
    Because the complexity of an MDP is much lower than that of a 2½-player game, insights about problematic patters in the game graph are more accessible and analysis results can be obtained faster.
    One can imagine a positive refinement procedure that reduces the product game to an MDP by associating fixed actions to every game state, executes a few iterations of refinement in this reduced system and transfers the results back to the full system.
    Experience with a prototype implementation of such a scheme however revealed some important drawbacks.
    The process of choosing a fixed action for every player 1 state is non-trivial and requires a certain amout of foresight in order to lead to an effective refinement procedure.
    Badly chosen control regions will significantly limit the potential of the refinement procedure.
    Once the system has been equipped with a piecewise dynamics, jaggedness in the refinement progress was very common, resulting in many small states being generated to account for the highly non-convex intermediate solutions.
    Once jaggedness has been introduced into the state space partition, it is hard to remove and the increasing computational cost of dealing with small polytopes starts to offset the gains from the removal of a player from the game.
    The MDP-reduction approach was therefore abandoned and another way of extracting useful subsets from the product game explored.

    Instead of reducing the number of actions per state, one can directly reduce the number of states.
    This makes sense when the remaining subset of states and actions forms a meaningful sub-problem of the entire product game.
    It is not uncommon to encounter objectives made up of multiple separable sub-objectives, e.g.\ a safety property in conjunction with a recurrence, which is a sequence of inifinitly many reachability problems.
    If these sub-objectives can be separated in the product game and solved individually, one can expect that a solution for the composite objective emerges.
    For refinement this is advantageous as the sub-problems will often provide more immediate feedback between refinement and analysis.
    Analysis of simple sub-problems might be possible without the need to construct a game abstraction altogether.
    Saftey properties e.g. can be verified with only the $\ActR$-operator.
    Parallel refinement of the sub-problems is generally possible but restricted by the fact that state space partition is shared between the individual sub-problems in the product game.

\stopsubsection


\placefigure[top]{
    Illustration of how jaggedness in a positive refinement target region causes very fine partitioning and how post-processing of $\RefinePos$ can reduce the number of generated state space partition elements.
    See section \in[TODO] for a detailed discussion.
}{
    \bTABLE
        \setupTABLE[frame=off]
        \bTR
            \bTD[nc=2] a) no post-processing \eTD
        \eTR
        \bTR
            \bTD \externalfigure[refinement-transition-jagged-ref-attrr][width=0.47\textwidth] \eTD
            \bTD \externalfigure[refinement-transition-jagged-ref-ana][width=0.47\textwidth] \eTD
        \eTR
        \bTR
            \bTD[nc=2] b) convex hull \eTD
        \eTR
        \bTR
            \bTD \externalfigure[refinement-transition-jagged-hull-attrr][width=0.47\textwidth] \eTD
            \bTD \externalfigure[refinement-transition-jagged-hull-ana][width=0.47\textwidth] \eTD
        \eTR
        \bTR
            \bTD[nc=2] c) small state suppression, one iteration \eTD
        \eTR
        \bTR
            \bTD \externalfigure[refinement-transition-jagged-sup1-attrr][width=0.47\textwidth] \eTD
            \bTD \externalfigure[refinement-transition-jagged-sup1-ana][width=0.47\textwidth] \eTD
        \eTR
        \bTR
            \bTD[nc=2] d) small state suppression, two iterations \eTD
        \eTR
        \bTR
            \bTD \externalfigure[refinement-transition-jagged-sup2-attrr][width=0.47\textwidth] \eTD
            \bTD \externalfigure[refinement-transition-jagged-sup2-ana][width=0.47\textwidth] \eTD
        \eTR
    \eTABLE
}

\startsubsection[title={Transition-based Reachability Decomposition},reference=sec:refinement-transition-decomposition]

    Systematic way to decompose any objective into a series of co-safe reachability problems based on transitions.
    When all are solved, can be combined into a solution for the product game.
    % TODO formalize the strategy stitch-up
    $\ProductGame$ has copy of the LSS game graph for every automaton state.
    A trace through the system must reach regions associated with automaton transitions in an order that satisfies the specification.
    Stuttering equivalence of traces in next-free LTL allows to take as much time as needed as long as it is finite.
    Therefore, each transition individually has a corresponding co-safe reachability problem in the LSS.
    If the satisfying regions of every one of these almost-sure reachability problems can be determined, a solution for the original problem emerges by piecing together satisfying strategies from the reachability problems, if they exist.
    Because the reachability problems are co-safe, winning strategies will satisfy lead to the required automaton transitions in finite time and the composite strategy cannot get stuck in any of the individual reachability tasks.

    To construct a reachability system for a transition from $q$ to $q'$ in the automaton:
    Same LSS $\LSS$, start with the same partition as current state-space abstraction but only a simple co-safe reachability/avoidance winning condition.
    Elements of the current state space partition are therefore separated into 3 sets:
    First,

    \startformula
        \ReachStates{q}{q'} = \Set{ \State{i} \mid \Tuple{\State{i}}{q} \in P_1 \MidAnd \State{i} \notin \NoStates{q} \MidAnd ( \QNext{i}{q} = q' \MidOr \YesStates{q} ) } \EndComma
    \stopformula

    the elements whose union has to be reached.
    These are parts where a transition to the transition target automaton state happens with any of the next player 1 actions in the product game.
    It also includes all parts that have already been recognized as satisfying for the origin $q$ by a previous analysis.
    Second,

    \startformula
        \RefineStates{q}{q'} = \Set{ \State{i} \mid \Tuple{\State{i}}{q} \in P_1 \MidAnd \State{i} \notin \NoStates{q} \MidAnd \QNext{i}{q} = q } \EndComma
    \stopformula

    the elements which do not trigger an automaton transition with their player 1 actions.
    These elements will be refined.
    And finally,

    \startformula
        \AvoidStates{q}{q'} = \IndexedStates{i}{I} \setminus \left( \ReachStates{q}{q'} \cup \RefineStates{q}{q'} \right) \EndComma
    \stopformula

    the elements where a transition to any other automaton state happens with the next player 1 action, as well as all elements from the no-set of the previous analysis.
    These sets are disjunct except for the special case $q = q'$, where $\ReachStates{q}{q'} \cap \RefineStates{q}{q'} \ne \emptyset$.

\stopsubsection


\startsubsection[title={Robust Reachability Refinement},reference=sec:refinement-transition-reachability]

    In section \in[sec:refinement-holistic-positive] a positive refinement procedure was presented based on the $\RefinePos$ kernel.
    Limitation was that yes-states have to exists for method to be applicable.
    While this is not generally a given, any co-safe objective has yes-states guaranteed.
    In particular, this includes the avoid-reach systems from the transition decomposition given in the previous section.
    Avoid-reach allows unique association of states as satisfying, unknown or non-satisfying.

    Positive robust refinement has progress guarantee and one-step robust reachability can be decided with the $\ActR$ operator without need for game construction (see section \in[sec:refinement-robust]).
    Restriction to robust reachability allows skipping of expensive game construction for analysis.
    While this means that the probabilistic dynamics is ignored completely, abstraction step is removed and entire procedure has polynomial complexity.
    The idea is to perform multiple robust steps between analysis to obtain best of both worlds: multi-step refinement in the robust framework, but consideration of probabilistic dynamics by analysing every couple of refinements.

    First pick a transition and extract reachability problem.
    Refine every state wrt target region using AttrR+ refinement.
    Use progress guarantee to immediately extend region of yes-states.
    Iterate a few times.
    Transfer partition to full system and analyse.
    Evolution of \cite[Svorenova2017] positive refinement to multi-step procedure.

    Additional tweaks possible to improve method.
    Known that small states cannot be targeted individually due to probabilistic dynamics have no self loops and are therefore unlikely to be a problem if surrounded by bigger states for which robust satisfaction can be established.
    Expansion of target region can be accelerated by considering all small polytopes as satisfying (without proper probabilistic check).
    This brings some of the probabilistic tolerance back into the robust dynamics at the cost of losing the progress guarantee for a few special cases (pratcise shows that ignoring small states is not an issue as long as they are safe).
    Post-processing with additional loss of progress guarantees but possibility of generation of less states and reduced non-convexness.

\stopsubsection


\startsubsection[title={Layered Robust Reachability Refinement},reference=sec:refinement-transition-layered]

    Problem with pure AttrR+ refinement is that progress guarantee only works for AttrR-generated states.
    For some, reachability can be decided with ActR and small states can be ignored but purely robust view means over-refinement and conservative analysis, slowing progress.
    Analysing system fully from time to time required, but relatively expensive due to need for action computation.

    They also introduced the idea of a layer decomposition that works only for refinement but splits problem into multiple decoupled subproblems.
    Problem of \cite[Svorenova2017]: they used Pre, which required much refinement until entire region is decided.
    Even though parallelization, some subproblems were still very expensive.
    For robust refinement, importance of the PreR also recognized by \cite[Svorenova2017].
    Propsal: combine transition decomposition, layer decomposition and robust refinement.
    Use PreR which is more aligned with robust refinement and provides guarantee that single-step robust solution can be found.
    Hybrid approach between multi-step and single-step: general idea of moving from layer to layer is multi-step, but transitions inside layers are single step.
    Solution for outer layers depends on solution of inner layers.

    First extract reachability problem for transition.
    Then decompose reachability problems into PreR layers.
    Solve single-step reachability problem for each layer.
    Combine into solution for transition reachability problem.
    Apply partition to product game.

    To combat problem of \epsilon-limit behaviour, shrink layer-generating control space.
    Other optimizations from robust refinement still apply (target expansion, ignoring of safe, small states, post-processing).

\stopsubsection


\startsubsection[title={Transition Selection},reference=refinement-transition-selection]

    If refinement wrt every transition has taken place, full problem should be decidable.
    The state space partition of the product system is shared between all copies for the automaton states.
    The individual reachability problems for each transition are therefore weakly linked, i.e.\ they can all be solved independently in parallel and then combined into one partition or they can be solved sequentially such that the partitions from earlier refinements potentially provide partial solutions to later reachability problems.
    Finding a \quotation{best} order of these refinements is again a non-trivial task.
    For co-safe objectives, it makes sense to work backwards from the final states, which are guaranteed to be satisfying.
    For infinite objectives a best path through the automaton is not obvious and multiple paths may even be required to find all satisfying initial states.
    Related to controller synthesis problem.

\stopsubsection

