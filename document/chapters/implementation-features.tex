\placefigure[top][fig:implementation-features-setup]{
    The problem setup screen of the interactive application.
}{
    \externalfigure[implementation-features-setup][width=\textwidth]
}

\placefigure[top][fig:implementation-features-inspector]{
    The problem exploration screen of the interactive application.
}{
    \externalfigure[implementation-features-inspector][width=\textwidth]
}

\in{Figure}[fig:implementation-features-setup] shows the problem setup screen of the created application.
The user is able to specify the state-, random- and control space in 1 and 2 dimensions as well as the evolution equation and the set of linear predicates used in the initial partitioning of the state space.
A preview of the state space configuration provides instantaneous feedback to user input.
The objective can be chosen from a list of predefined GR(1) formulae, LTL-to-automaton translation is not implemented.
While the structure of the temporal logic formulae is fixed, they contain placeholder variables that can be defined by the user by combining the linear predicates with connectives from propositional logic.

\in{Figure}[fig:implementation-features-inspector] shows the exploration screen, which is shown once the problem setup has been submitted by the user.
Its main interface element is a visualization of the state space and its partition.
The view is customizable by panning and zooming and can be exported as an SVG image.
The selection of state space partition elements reveals information about the associated product game states in the \quotation{State} tab to the right of the system view.
Player actions from the game graph are shown there and $\ActC$ and $\PreP$ regions can be highlighted.
The product game can be explored further with the selection of a state from the objective automaton, displayed below the state space view.
State-space elements are coloured according to the membership of the corresponding player 1 states in $P_\Yes$, $P_\No$ and $P_\Maybe$.

Accessible in the tabs on the right are also controls for analysis and refinement procedures.
The presented holistic refinement algorithms from \in{Section}[sec:refinement-holistic] as well as the robust refinement for automaton transitions in the product game from \in{Section}[sec:refinement-transition] are implemented and can be applied to the system with custom configurations.
A snapshot system can save the current state of the system abstraction and restore it later, allowing the user to try and compare different refinement approaches.
Snapshots can be exported to disk and imported again from the problem setup screen.
Brief reports with performance metrics and information about the product game are logged after every refinement and analysis invocation.
Traces can be sampled with a synthesized round-robin controller and the individual trace steps inspected.

Built-in help texts provide assistance and explanations of the interface to the user.
Their are available in the appendix of this document.

