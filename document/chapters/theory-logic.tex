A temporal logic is an extension of propositional logic by a set of temporal connectives, enabling the expression of statements about not just the current but also the future state of a system.
While formulae of propositional logic are evaluated with a single valuation, temporal logic formulae are evaluated with a sequence or a tree of valuations, describing the evolution of the system state in time.

A comprehensive and rigorous introduction to temporal logics is given e.g. by \cite[Baier2008]. % TODO another reference
Here, a summarized look at the basics of linear time logic is presented and supplemented by brief survey of related temporal logics.


\startsubsection[title={Linear Temporal Logic},reference=sec:theory-logic-ltl]

    Linear temporal logic (LTL) is an extension of propositional logic applied to discrete-time infinite sequences of valuations of propositional atoms.
    LTL formulae are able to express the temporal order of events occurring in such a sequence.
    As the name suggests, LTL is concerned with a linear, path-based understanding of time, considering one specific path through time when evaluated, with exactly one successor for each state in the sequence.

    The syntax of LTL formulae over a set of atomic propositions $AP$ follows the grammar
    
    \startformula
        \varphi \coloncolonequals \True \mid a \mid \varphi_1 \wedge \varphi_2 \mid \neg \varphi \mid \Next \varphi \mid \varphi_1 \Until \varphi_2 \EndComma
    \stopformula

    where $a \in AP$.
    $\wedge$ and $\neg$ are the known propositional operators \quotation{and} and \quotation{not}.
    $\Next$ and $\Until$ are temporal operators named \quotation{next} and \quotation{until}, respectively.
    $\True$ is the tautology symbol.
    Operator precedence is adopted from propositional logic where possible, $\Next$ binds as strongly as $\neg$ and $\Until$ takes precedence over all propositional binary operators.

    LTL formulae are interpreted over paths $w = w_0 w_1 ... \in (2^{AP})^\omega$ which are sequences of valuations and the words in a formula's language over the alphabet $AP$.
    The semantics of LTL, expressed by the satisfaction relation $\vDash$, is 

    \startformula
        \startalign[n=3,align={right,left,left}]
            \NC w \vDash \NC \True \NC ~~\text{unconditionally (tautology),} \NR
            \NC w \vDash \NC a \NC \iff a \in w_0 \EndComma \NR
            \NC w \vDash \NC \neg \varphi \NC \iff w \nvDash \varphi \EndComma \NR
            \NC w \vDash \NC \varphi_1 \wedge \varphi_2 \NC \iff w \vDash \varphi_1 \;\text{and}\; w \vDash \varphi_2 \EndComma \NR
            \NC w \vDash \NC \Next \varphi \NC \iff w_1 w_2 ... \vDash \varphi \EndComma \NR
            \NC w \vDash \NC \varphi_1 \Until \varphi_2 \NC \iff \exists j \ge 0 : w_j w_{j+1} ... \vDash \varphi_2 \;\text{and}\; \forall 0 \le i \lt j : w_i w_{i+1} ... \vDash \varphi_1 \EndPeriod \NR
        \stopalign
    \stopformula

    Other connectives are derived, such as

    \startformula
        \startalign[n=3,align={right,left,middle}]
            \NC \varphi_1 \vee \varphi_2 \NC \colonequals \neg(\neg \varphi_1 \wedge \neg \varphi_2) ~~~\NC \text{\quotation{or},} \NR
            \NC \Finally \varphi \NC \colonequals \True \Until \varphi \NC \text{\quotation{finally},} \NR
            \NC \Globally \varphi \NC \colonequals \neg \Finally \neg \varphi \NC \text{\quotation{globally}.} \NR
        \stopalign
    \stopformula

    Paths are usually derived from a transition system which might have more than one possible successor to a state.
    Therefore multiple futures, i.e. multiple paths, are realizable when starting in such states.
    The sematics of LTL is extended to a state-based notion in the following way:

    \startformula
        s \vDash \phi \iff \forall w ~\text{starting in}~ s: w \vDash \phi \EndPeriod
    \stopformula

    If and only if all possible paths starting in some state $s$ satisfy an LTL formula $\varphi$, $s$ is said to satisfy the the formula.

\stopsubsection


\startsubsection[title={Other Temporal Logics},reference=sec:theory-logic-other]

    The path based, linear time semantics of LTL was extended to states by looking at all possible paths starting from a common initial state.
    In a branching time framework, the future is not a collection of paths starting in the present but a tree of possible futures, branching further outward whenever there are multiple successors of a moment (i.e. state) in time.
    Computation Tree Logic (CTL) is a temporal logic with this understanding of time and allows reasoning over the branching future with quantifiers $\exists$ (there is some future) and $\forall$ (for all possible futures).
    The expressiveness of CTL only partially overlaps with LTL, i.e. some properties can be expressed by both LTL and CTL while some properties can only be expressed with LTL and some properties can only be expressed by CTL. % TODO reference
    Despite the overlapping expressiveness, model checking approaches for linear and branching time properties are quite different. % TODO is this interesting information? Yes, if reference(s) for examples are added
    Both LTL and CTL are unified in the temporal logic CTL*, that additionally extends the expressiveness of both.

    LTL and CTL are only concerned with the ordering of events in time but one might want to formulate properties that include the distance between events in time. % TODO phrasing
    Temporal logic can be equipped with the concept of a clock that measures time in discrete units and operators that depend on the amount of time as measured by this clock.
    Therefore, properties such as \quotation{in x units of time} or \quotation{for x units of time} can be expressed.
    Timed CTL \cite[authoryears][Baier2008] or Metric Time Logic \cite[authoryears][TODO] are examples of temporal logics that include this concept of time intervals.

    Not only the view of time (linear, branching) but also the properties of the transition system under consideration influence what is expressible in a temporal logic. % TODO phrasing, this is really about the "construction" of a temporal logic
    For example, if the transition system exhibits probabilistic behaviour and/or associates rewards to paths, one should be able to express qualitative and/or quantitative probabilistic and/or reward properties, too.
    Therefore many variants of temporal logics for such purposes have been constructed, e.g. Probabilistic CTL or Probabilistic Reward CTL \cite[authoryears][Baier2008].

\stopsubsection


\startreusableMPgraphic{automaton-reachability}
    with spacing((30,10)) matrix.a(3,6);
    node_dash.a[1][1](btex $q_0$ etex);
    node_double.a[1][4](btex $q_1$ etex);
    incoming(0, "") (a[1][1]) 180;
    loop.rt(.4, btex \small ${\neg \varphi}$ etex) (a[1][1]) 90;
    arrow.top(.5, btex \small ${\varphi}$ etex) (a[1][1],a[1][4]) a[1][1].c..a[1][4].c;
    loop.rt(.4, btex \small ${\True}$ etex) (a[1][4]) 90;
\stopreusableMPgraphic

\startreusableMPgraphic{automaton-avoidance}
    with spacing((30,10)) matrix.a(3,6);
    node_dash.a[1][1](btex $q_0$ etex);
    node_double.a[1][4](btex $q_1$ etex);
    incoming(0, "") (a[1][1]) 180;
    loop.rt(.4, btex \small ${\neg \theta}$ etex) (a[1][1]) 90;
    arrow.top(.5, btex \small ${\varphi}$ etex) (a[1][1],a[1][4]) a[1][1].c..a[1][4].c;
    loop.rt(.4, btex \small ${\True}$ etex) (a[1][4]) 90;
\stopreusableMPgraphic

\startreusableMPgraphic{automaton-recurrence}
    with spacing((30,10)) matrix.a(3,6);
    node_dash.a[1][1](btex $q_0$ etex);
    node_double.a[1][4](btex $q_1$ etex);
    incoming(0, "") (a[1][1]) 180;
    loop.rt(.4, btex \small ${\neg \varphi}$ etex) (a[1][1]) 90;
    arrow.top(.5, btex \small ${\varphi}$ etex) (a[1][1],a[1][4]) a[1][1].c..a[0][2].c..a[0][3].c..a[1][4].c;
    loop.rt(.4, btex \small ${\varphi}$ etex) (a[1][4]) 90;
    arrow.bot(.5, btex \small ${\neg \varphi}$ etex) (a[1][4],a[1][1]) a[1][4].c..a[2][3].c..a[2][2].c..a[1][1].c;
\stopreusableMPgraphic

\startreusableMPgraphic{automaton-safety}
    with spacing((30,10)) matrix.a(3,3);
    node.a[1][1](btex $q_0$ etex);
    incoming(0, "") (a[1][1]) 180;
    loop.rt(.4, btex \small ${\neg \theta}$ etex) (a[1][1]) 90;
\stopreusableMPgraphic

\startreusableMPgraphic{automaton-eventualsafety}
    with spacing((30,10)) matrix.a(3,6);
    node_dash.a[1][1](btex $q_0$ etex);
    node.a[1][4](btex $q_1$ etex);
    incoming(0, "") (a[1][1]) 180;
    loop.rt(.4, btex \small ${\,\theta}$ etex) (a[1][1]) 90;
    arrow.top(.5, btex \small ${\neg \theta}$ etex) (a[1][1],a[1][4]) a[1][1].c..a[0][2].c..a[0][3].c..a[1][4].c;
    loop.rt(.4, btex \small ${\neg \theta}$ etex) (a[1][4]) 90;
    arrow.bot(.5, btex \small ${\theta}$ etex) (a[1][4],a[1][1]) a[1][4].c..a[2][3].c..a[2][2].c..a[1][1].c;
\stopreusableMPgraphic

\startsubsection[title={Automata for LTL Objectives},reference=sec:theory-logic-automata]

    Every LTL formula can be represented by an \omega-automaton constructed such that the formula and automaton accept the same language of words over the alphabet $2^{AP}$.
    Tools for the automatic translation of temporal logic formulae to various types of \omega-automata have beed developed, e.g. by \cite[Kretinsky2018], \cite[Duret2016] and \cite[Gastin2001].

    Table \in[tab:theory-logic-objectives] presents five basic LTL formulas and corresponding \omega-automata with one-pair Streett acceptance conditions.
    The automata for objectives reachability, recurrence and eventual safety are complete, whereas reachability/avoidance and safety are incomplete.
    Noteworthy is the Streett pair of the eventual safety automaton., which expresses that state $q_0$ must not be visited infinitely often.
    The empty set in the pair cannot be visited infinitely often, therefore the condition can only be fulfilled by visiting $q_0$ only a finitely often.

    \placetable[top][tab:theory-logic-objectives]{
        Description of four basic linear time objectives and their corresponding \omega-automata with acceptance condition.
    }{
        \setupTABLE[frame=off,option=stretch]
        \setupTABLE[r][each][bottomframe=on]
        \setupTABLE[r][last][bottomframe=off]
        \setupTABLE[c][1][align={justified,lohi}]
        \setupTABLE[c][2][toffset=2mm,align={middle,lohi}]
        \bTABLE
            \bTR
                \bTD \underbar{Reachability}: $\Finally \varphi$. \par Eventually reach a state where $\varphi$ is satisfied. \par One-pair Streett condition: $(\Set{q_0}, \Set{q_1})$ \eTD
                \bTD {\leavevmode\reuseMPgraphic{automaton-reachability}} \eTD
            \eTR
            \bTR
                \bTD \underbar{Reachability/Avoidance}: $\neg \theta \Until \varphi$. \par Avoid satisfying $\theta$ until a state satisfying $\varphi$ is reached. \par One-pair Streett condition: $(\Set{q_0}, \Set{q_1})$ \eTD
                \bTD {\leavevmode\reuseMPgraphic{automaton-avoidance}} \eTD
            \eTR
            \bTR
                \bTD \underbar{Recurrence}: $\Globally \Finally \varphi$. \par Satisfy $\varphi$ again and again. \par One-pair Streett condition: $(\Set{q_0}, \Set{q_1})$ \eTD
                \bTD {\leavevmode\reuseMPgraphic{automaton-recurrence}} \eTD
            \eTR
            \bTR
                \bTD \underbar{Safety}: $\Globally \neg \theta$. \par Forever avoid states where $\theta$ is satisfied. \par Acceptance expressed through incompletness of $\delta$. \eTD
                \bTD {\leavevmode\reuseMPgraphic{automaton-safety}} \eTD
            \eTR
            \bTR
                \bTD \underbar{Eventual Safety}: $\Finally \Globally \neg \theta$. \par Eventually, $\theta$ can never be satisfied. \par One-pair Streett condition: $(\Set{q_0}, \emptyset)$ \eTD
                \bTD {\leavevmode\reuseMPgraphic{automaton-eventualsafety}} \eTD
            \eTR
        \eTABLE
    }

\stopsubsection


\startsubsection[title={Fragments of LTL},reference=sec:theory-logic-fragments]

    Model checking with general LTL specifications is computationally demanding and in fact PSPACE-hard \cite[authoryears][Baier2008].
    Fragments of LTL exist that offer more favorable computational complexity and simple automaton constructions at the cost of restrictions in expressivity.
    However, if designed carefully, such restricted subsets of LTL can still include many properties that are relevant in practical applications.

    One such fragment is the subset of Generalized Ractivity(1) formulas of form

    \placeformula[fml:theory-logic-gr]
    \startformula
        \bigwedge_{i = 1 ... n} \Globally \Finally \mu_i \rightarrow \bigwedge_{i = 1 ... m} \Globally \Finally \pi_i
    \stopformula

    where $\mu_i$ and $\pi_i$ are propositional formulas \cite[authoryears][TODO].

    It was first introduced by \cite[TODO] and is used frequently in robotics applications \cite[authoryears][TODO].
    The restriction to formulas of form (\in[fml:theory-logic-gr]) allows for the use of model checking algorithms with polynomial complexity.
    An extended variant of GR(1) contains all formulas with form

    \placeformula[fml:theory-logic-grextended]
    \startformula
        \Big( \displaystyle\bigwedge_{i = 1 ... n} \mu_i \Big) \Longrightarrow \Big( \displaystyle\bigwedge_{i = 1 ... m} \pi_i \Big) \EndComma
    \stopformula

    where every \math{\mu_i} and \math{\pi_i} is representable by a deterministic \omega-automaton with Büchi acceptance condition.
    For the entire GR(1) formula, an \omega-automaton with one-pair Streett acceptance condition can then be constructed based on the individual Büchi automata for the terms $\mu_i$ and $\pi_i$. % TODO: reference, Svorenova?
    Therefore, all objectives in Table \in[tab:theory-logic-objectives] are part of the (extended) GR(1) fragment.
    In this work GR(1) always refers to the extended variant.

    Linear temporal logic as defined above is interpreted over infinite sequences.
    However, for a subset of formulas, satisfiability can be decided based on a finite prefix of the sequence.
    These formulas from the class of co-safe LTL \cite[authoryears][TODO].
    % TODO see [5] of Lacerda 2014, syntactic restrictions
    Co-safe objectives occur in many real-world scenarios, e.g.\ in robotics where typical objectives of a robot are usually not infinite procedures or allowed to take infinite time, but are isolated, finite tasks that can be chained to form more complex behaviour. % TODO: references that use co-safe objectives
    In Table \in[fig:tab-theory-logic-objectives]), both reachability and reachability/avoidance are co-safe objectives.

    %Co-safe objectives are also useful when dealing with problems where some accumulated cost is supposed to be minimized.
    %In an infinite setting costs might accumulate forever and not yield a finite value that can be optimized. % TODO: reference (Lacerda 2014?)

\stopsubsection

